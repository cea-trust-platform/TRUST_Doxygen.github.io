<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: Op_Diff_VEFP1NCP1B_Face Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Op_Diff_VEFP1NCP1B_Face Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Op_Diff_VEFP1NCP1B_Face" --><!-- doxytag: inherits="Op_Diff_VEF_Face" -->
<p>class <a class="el" href="classOp__Diff__VEF__Face.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ...">Op_Diff_VEF_Face</a><br/>
Cette classe represente l'operateur de diffusion<br/>
La discretisation est VEF<br/>
Le champ diffuse est scalaire<br/>
Le champ de diffusivite est uniforme  
 <a href="classOp__Diff__VEFP1NCP1B__Face.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Op_Diff_VEFP1NCP1B_Face:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOp__Diff__VEFP1NCP1B__Face.png" usemap="#Op_Diff_VEFP1NCP1B_Face_map" alt=""/>
  <map id="Op_Diff_VEFP1NCP1B_Face_map" name="Op_Diff_VEFP1NCP1B_Face_map">
<area href="classOp__Diff__VEF__Face.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ..." alt="Op_Diff_VEF_Face" shape="rect" coords="442,280,653,304"/>
<area href="classOp__Diff__VEF__base.html" title="class Op_Diff_VEF_base Classe de base des operateurs de convection VEF" alt="Op_Diff_VEF_base" shape="rect" coords="442,224,653,248"/>
<area href="classOperateur__Diff__base.html" title="classe Operateur_Diff_base Cette classe est la base de la hierarchie des operateurs representant un t..." alt="Operateur_Diff_base" shape="rect" coords="331,168,542,192"/>
<area href="classOp__VEF__Face.html" alt="Op_VEF_Face" shape="rect" coords="552,168,763,192"/>
<area href="classOperateur__base.html" title="classe Operateur_base Classe est la base de la hierarchie des objets representant un operateur utilis..." alt="Operateur_base" shape="rect" coords="221,112,432,136"/>
<area href="classSupport__Champ__Masse__Volumique.html" alt="Support_Champ_Masse_Volumique" shape="rect" coords="442,112,653,136"/>
<area href="classObjet__U.html" title="classe Objet_U Cette classe est la classe de base des Objets de TRUST Dans les classes derivees de Ob..." alt="Objet_U" shape="rect" coords="0,56,211,80"/>
<area href="classMorEqn.html" title="classe MorEqn Classe qui regroupe les fonctionnalites de liaison avec une Equation. Le membre MorEqn::mon_equation contient une reference vers un objet Equation_base. Les classes qui sont des &quot;Morceaux d&#39;equation&quot; sont associe par une liaison 1-1 a leur equation en heritant de MorEqn, par exemple: Operateur_base, Solveur_Masse, Source_base ..." alt="MorEqn" shape="rect" coords="221,56,432,80"/>
<area href="classChamps__compris__interface.html" title="classe Champs_compris_interface Cette classe contient une interface de methodes destinees a gerer les..." alt="Champs_compris_interface" shape="rect" coords="442,56,653,80"/>
<area href="classProcess.html" title="Classe de base de TRUST (notamment Objet_U). Elle fournit quelques services de base accessibles de pa..." alt="Process" shape="rect" coords="0,0,211,24"/>
<area href="classOp__Diff__VEFP1NCP1B__Face__Var.html" title="class Op_Diff_VEFP1NCP1B_Face_Var Cette classe represente l&#39;operateur de diffusion La discretisation ..." alt="Op_Diff_VEFP1NCP1B_Face_Var" shape="rect" coords="442,392,653,416"/>
</map>
 </div></div>

<p><a href="classOp__Diff__VEFP1NCP1B__Face-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a7973c6b7879524574364017de66c9186">~Op_Diff_VEFP1NCP1B_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aa1240a59d726eae3194711dadb4e5e08">taille_memoire</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ab7390cb60bca5cc34ed160c711fbf286">duplique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a797f4cea7d040a417a0c3f2236df851e">get_info</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a797f4cea7d040a417a0c3f2236df851e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aef4397519e8b079cab62f05a5a491326">Op_Diff_VEFP1NCP1B_Face</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a0c7833289430f6a53298a97b059f7301">associer</a> (const <a class="el" href="classZone__dis.html">Zone_dis</a> &amp;, const <a class="el" href="classZone__Cl__dis.html">Zone_Cl_dis</a> &amp;, const <a class="el" href="classChamp__Inc.html">Champ_Inc</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a67fc124061be17772b3fd1728709213f">completer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Associe l'operateur a la zone_dis, la zone_Cl_dis,<br/>
et a l'inconnue de son equation.  <a href="#a67fc124061be17772b3fd1728709213f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a758c8869b8f0b8bd04a888995a9e3249">ajouter</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a2f86fceb1e62fd028ed023cecf1ac447">calculer</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aed99737b6470f55a7423b4c6c956db05">calculer_dt_stab</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul dt_stab.  <a href="#aed99737b6470f55a7423b4c6c956db05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a639f6fb13c3e7f345f8d70f098eaf4c2">zone_Cl_VEFPreP1B</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aee6ed8e488e0a0ba6c17621a7dd10115">contribuer_a_avec</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on assemble la matrice.  <a href="#aee6ed8e488e0a0ba6c17621a7dd10115"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253">dimensionner</a> (<a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on dimensionne notre matrice.  <a href="#af8e127ec31241c8d2aab78ad951aa253"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a9fb46e714ef90e6b6eb46ce7bca4d375">ajouter_contribution</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a6d131deb7d32ff2c7830981433018b9c">contribuer_au_second_membre</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">on ajoute la contribution du second membre.  <a href="#a6d131deb7d32ff2c7830981433018b9c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classObjet__U.html">Objet_U</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aaf50145420cf06ef2d6470743f248209">cree_instance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a6484f8248047d53c2ab60be7ab09c892">info</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Donne des informations sur le type de l'Objet_U.  <a href="#a6484f8248047d53c2ab60be7ab09c892"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html">Op_Diff_VEFP1NCP1B_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a5ab35137c633662d0a2ba13e40869a22">self_cast</a> (<a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
<a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html">Op_Diff_VEFP1NCP1B_Face</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#afb8b825e9fab55e68bafcb4016a8abe7">self_cast</a> (const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">methode ajoutee pour caster en python  <a href="#afb8b825e9fab55e68bafcb4016a8abe7"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classType__info.html">Type_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a45a7b1c4e61735e310ffe9238a64150a">info_obj</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a40338f037cc176acacb1a23eab51e65e">printOn</a> (<a class="el" href="classSortie.html">Sortie</a> &amp;x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
A surcharger dans les classes derivees.  <a href="#a40338f037cc176acacb1a23eab51e65e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a16d0bd30f8c55391616349f7fc3c1f1a">readOn</a> (<a class="el" href="classEntree.html">Entree</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NE FAIT RIEN<br/>
A surcharger dans les classes derivees.  <a href="#a16d0bd30f8c55391616349f7fc3c1f1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a0939691aa4e08464a51cb16c33a62d51">initialiser</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996">remplir_nu_p1</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcule la diffusivite "nu_p1" aux sommets du maillage<br/>
en fonction de la diffusivite "nu_elem" aux elements.<br/>
On suppose que nu_elem a son espace virtuel a jour,<br/>
que nu_p1 est dimensionne nb_dim==1 avec la structure domaine.md_vector_sommets()<br/>
En sortie l'espace virtuel de nu_p1 est mis a jour<br/>
L'interpolateur calculs pour un sommet la moyenne (non ponderee) des<br/>
diffusivites sur les elements adjacents a ce sommet.  <a href="#a997bacd7fe35872ff44036e9e9f40996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a054036b7f0ee412cb3a959885d915f2f">calculer_gradient_elem</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#afb9be14ba93fdea98e9f53d952752034">calculer_gradient_aretes</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a529ec43db5b4b872207a7bb2dd40a7ba">calculer_divergence_elem</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a3315f6694fb97261a1fdefe4d52d83b1">calculer_divergence_aretes</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a325ae974e29dd047801de2efaeea1174">corriger_div_pour_Cl</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a7d0688de99484ee5807a0846219ebe2d">calculer_laplacien_som</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a16f33e9d0867d5888e2faf4d87c85989">calculer_flux_bords_elem</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aeb1ae7dfd65857f58bbe29defb6bf747">calculer_flux_bords_som</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a4de56f9fddbc93956dc697dcf31f7583">calculer_flux_bords_aretes</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a992a4048490448ef27d6ef07e730eda5">calculer_dt_stab_elem</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f0227976726b0e66cbe318901d690d3">calculer_dt_stab_som</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ac2cf135bf96f42a0eca42e7ff3c30d48">calculer_dt_stab_aretes</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">ajouter_contribution_elem</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aca6b2aa015252cbc0919765131e98774">ajouter_contribution_aretes</a> (const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a79b580276b1459de268cf4cfcd7b0665">coeff_matrice_som</a> (const int &amp;, <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ac34445bdca920e590a8d84ca2c1099ff">coeff_matrice_som_CL</a> (const int &amp;, <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a40963269ea0e5eee6023bcef8f4b5162">coeff_matrice_som_symetrie</a> (const int &amp;, <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a706eb5baeef2cc4eddd0ea43fb11f73c">coeff_matrice_som_perio</a> (const int &amp;, const int &amp;, <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;, <a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a> (const int &amp;face, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aef8420d4ce23c86e97333c7eeefb08cc">gradient_som</a> (const int &amp;, int &amp;, <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a> (const int &amp;, int &amp;, <a class="el" href="classIntVect.html">IntVect</a> &amp;, <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a> (int, int, int &amp;, int &amp;, int &amp;, int &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a0e34a4eb1127c6810d661018f42e840c">isFaceOfSymetry</a> (<a class="el" href="classArrOfBit.html">ArrOfBit</a> &amp;, int &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ae2379b34f16ef970c39d7c515f51547c">liste_face</a> (<a class="el" href="classIntLists.html">IntLists</a> &amp;, int &amp;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">test</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a> (<a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoubleTab.html">DoubleTab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a41feb4e425bf215a43112ffa45f0e0f7">is_laplacian_built_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>class <a class="el" href="classOp__Diff__VEF__Face.html" title="class Op_Diff_VEF_Face Cette classe represente l&#39;operateur de diffusion La discretisation est VEF Le ...">Op_Diff_VEF_Face</a><br/>
Cette classe represente l'operateur de diffusion<br/>
La discretisation est VEF<br/>
Le champ diffuse est scalaire<br/>
Le champ de diffusivite est uniforme </p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00053">53</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7973c6b7879524574364017de66c9186"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::~Op_Diff_VEFP1NCP1B_Face" ref="a7973c6b7879524574364017de66c9186" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_Diff_VEFP1NCP1B_Face::~Op_Diff_VEFP1NCP1B_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="aef4397519e8b079cab62f05a5a491326"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::Op_Diff_VEFP1NCP1B_Face" ref="aef4397519e8b079cab62f05a5a491326" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Op_Diff_VEFP1NCP1B_Face::Op_Diff_VEFP1NCP1B_Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">69</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">decentrage_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00141">is_laplacian_filled_</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00134">test_</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Initialisation des attributs</span>
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>=1.e-3;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>=1;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>=1;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>=0;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>=0;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>=1.;<span class="comment">//alphaE+alphaS;</span>
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>=1;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a>=0;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a758c8869b8f0b8bd04a888995a9e3249"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::ajouter" ref="a758c8869b8f0b8bd04a888995a9e3249" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Diff_VEFP1NCP1B_Face::ajouter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a6a6dd6a49657d8d316b230a23cdd8daa">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">1002</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Matrice__Base_8h_source.html#l00230">Matrice_Base::ajouter_multvect()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00969">calculer_divergence_aretes()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00826">calculer_divergence_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01334">calculer_flux_bords_aretes()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">calculer_flux_bords_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">calculer_flux_bords_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00724">calculer_gradient_aretes()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">calculer_gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00731">corriger_div_pour_Cl()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01093">corriger_pour_diffusivite()</a>, <a class="el" href="Domaine_8cpp_source.html#l00435">Domaine::creer_tableau_sommets()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00137">gradient_p0_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">gradient_p1_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00139">gradient_pa_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00140">laplacien_p1_</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Op__VEF__Face_8cpp_source.html#l00384">Op_VEF_Face::modifier_flux()</a>, <a class="el" href="Zone_8h_source.html#l01266">Zone::nb_aretes_tot()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00083">Op_Diff_VEF_base::nu_</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00060">Op_Diff_VEF_base::phi_psi_diffuse()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00268">Op_Diff_VEF_base::remplir_nu()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02229">remplir_nu_p1()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02310">remplir_nu_pA()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00134">test_</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01086">calculer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_aretes_tot=zone.<a class="code" href="classZone.html#a59ae0ababf85ce303a7c6f339430e335" title="renvoie le nombre d&#39;aretes total (reelles+virtuelles).">nb_aretes_tot</a>();

<span class="comment">// Recuperation de la diffusivite</span>
  <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);

<span class="comment">// Pour tenir compte de la porosite</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> marq = <a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face = zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu,nu_p1,nu_pA;
  <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,porosite_elem);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inconnue1;
  <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(inconnue,inconnue1,marq,porosite_face);

<span class="comment">// Pour des raisons pratiques</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; inconnue2 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,inconnue1);
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resu2 = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
  <a class="code" href="classDoubleVect.html">DoubleVect</a> resu3(resu2);
  resu3=0.;

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>)
    {
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>=0.;
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a054036b7f0ee412cb3a959885d915f2f">calculer_gradient_elem</a>(inconnue2);

      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(nu,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;

      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a529ec43db5b4b872207a7bb2dd40a7ba">calculer_divergence_elem</a>(resu3);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a16f33e9d0867d5888e2faf4d87c85989">calculer_flux_bords_elem</a>(inconnue2);
    }
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
    {
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>=0.;
      nu_pA.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(nb_aretes_tot);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(nu,nu_pA);

      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#afb9be14ba93fdea98e9f53d952752034">calculer_gradient_aretes</a>(inconnue2);

      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(nu_pA,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>);

      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3315f6694fb97261a1fdefe4d52d83b1">calculer_divergence_aretes</a>(resu3);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4de56f9fddbc93956dc697dcf31f7583">calculer_flux_bords_aretes</a>(inconnue2);
    }
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a325ae974e29dd047801de2efaeea1174">corriger_div_pour_Cl</a>(inconnue2,nu,resu3);

<span class="comment">// Le corriger_div_pour_Cl() doit etre fait AVANT le calcul</span>
<span class="comment">// de la partie p1 car la matrice est deja codee pour tenir</span>
<span class="comment">// compte des coefficients periodiques</span>
<span class="comment">// REMARQUE IMPORTANTE : pour des raisons techniques inherentes</span>
<span class="comment">// a TrioU, le calcul du dt_stab a lieu AVANT l&#39;application</span>
<span class="comment">// de la fonction ajouter(). Or le dt_stab a besoin de la matrice</span>
<span class="comment">// pour etre correctement calcule par consequent, la matrice</span>
<span class="comment">// laplacien_p1_ est construite dans la fonction calculer_dt_stab()</span>
<span class="comment">// et est seulement reutilisee ici.</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
    {
      zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Base.html#a6ccb4d20d3877cf09f5178ff72af5406" title="Operation de multiplication-accumulation (saxpy) matrice vecteur. Operation: r = r + A*x...">ajouter_multvect</a>(inconnue2,resu3);

      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inconnue2);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9e35f1eae54ef9533a3409a26826428f">corriger_pour_diffusivite</a>(nu_p1,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>*=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aeb1ae7dfd65857f58bbe29defb6bf747">calculer_flux_bords_som</a>(inconnue2);
    }

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">test</a>();

  resu2+=resu3;
  resu.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classOp__VEF__Face.html#a6c8ce571769b4f2e20b07cbb7a6944f2">modifier_flux</a>(*<span class="keyword">this</span>);
  <span class="keywordflow">return</span> resu;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9fb46e714ef90e6b6eb46ce7bca4d375"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::ajouter_contribution" ref="a9fb46e714ef90e6b6eb46ce7bca4d375" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::ajouter_contribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a26ac1a17852f374c25d0fe1af5cfe997">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">2183</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01625">ajouter_contribution_aretes()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01346">ajouter_contribution_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00628">Zone_VF::creer_tableau_aretes()</a>, <a class="el" href="Domaine_8cpp_source.html#l00435">Domaine::creer_tableau_sommets()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00083">Op_Diff_VEF_base::nu_</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00060">Op_Diff_VEF_base::phi_psi_diffuse()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00268">Op_Diff_VEF_base::remplir_nu()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02229">remplir_nu_p1()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02310">remplir_nu_pA()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00134">test_</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00156">contribuer_a_avec()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();

<span class="comment">// Marqueur pour tenir compte de la porosite</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());

<span class="comment">// Lignes pour tenir compte de la porosite</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem=zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a> porosite_face(zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>());
  <span class="keywordflow">if</span> (!marq) porosite_face=1.;

<span class="comment">// Lignes pour tenir compte de la diffusivite</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu,nu_p1,nu_pA;
  <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
  <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,porosite_elem);

<span class="comment">// RESTE juste a gerer la porosite a la face</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>)
    <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">ajouter_contribution_elem</a>(inconnue,porosite_face,nu,matrice);
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
    {
      zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(inconnue,porosite_face,nu_p1,matrice);
    }
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
    {
      zone_VEF.<a class="code" href="classZone__VF.html#ae77f9ddf0711c0bcf2162921698d0bea">creer_tableau_aretes</a>(nu_pA);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(nu,nu_pA);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aca6b2aa015252cbc0919765131e98774">ajouter_contribution_aretes</a>(inconnue,porosite_face,nu_pA,matrice);
    }

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f8b23049afd6589ab4f1fa9619458f9">test</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aca6b2aa015252cbc0919765131e98774"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::ajouter_contribution_aretes" ref="aca6b2aa015252cbc0919765131e98774" args="(const DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::ajouter_contribution_aretes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01625">1625</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="a10ecca846d2d639a93ea61ed25cc5458"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::ajouter_contribution_elem" ref="a10ecca846d2d639a93ea61ed25cc5458" args="(const DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::ajouter_contribution_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01346">1346</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00079">Op_Diff_VEF_base::la_zone_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00071">Front_VF::num_premiere_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00090">Op_Diff_VEF_base::viscA()</a>, and <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__VEF.html" title="class Zone_VEF Classe instanciable qui derive de Zone_VF. Cette classe contient les informations geom...">Zone_VEF</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces = zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins = zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

<span class="comment">// int nb_faces_tot = zone_VEF.nb_faces_tot();</span>
  <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordtype">int</span> nb_faces_elem = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keywordtype">int</span> nb_comp = inconnue.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();

  <span class="keywordtype">int</span> i,j,num_face;
  <span class="keywordtype">int</span> elem1,elem2;

  <span class="keywordtype">double</span> val;
  <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) coeff*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;

  <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      <span class="keywordtype">int</span> num1 = le_bord.<a class="code" href="classFront__VF.html#a4986f0c65653fe9eb40bbbff5a97bf16" title="Numero de la premiere face du bord dans la liste des faces.">num_premiere_face</a>();
      <span class="keywordtype">int</span> num2 = num1 + le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keywordtype">int</span> fac_asso;
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              elem1 = face_voisins(num_face,0);
              fac_asso = la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(num_face-num1)+num1;

<span class="comment">// A la fin de la boucle :</span>
<span class="comment">// si ok=1, alors num_face appartient bien a elem1</span>
<span class="comment">// si ok=0, alors num_face n&#39;appartient pas a elem1 et</span>
<span class="comment">// fac_asso appartient a elem1</span>
              <span class="keywordtype">int</span> ok=1;
              <span class="keywordtype">int</span> fac_loc=0;
              <span class="keywordflow">while</span> ((fac_loc&lt;nb_faces_elem) &amp;&amp; (elem_faces(elem1,fac_loc)!=num_face)) fac_loc++;
              <span class="keywordflow">if</span> (fac_loc==nb_faces_elem) ok=0;

              <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
                <span class="keywordflow">if</span> ( ( (j= elem_faces(elem1,i)) &gt; num_face ) &amp;&amp; (j != fac_asso ) )
                  {
                    val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem1,nu(elem1));

<span class="comment">// int fac_loc=0;</span>
<span class="comment">// while ((fac_loc&lt;nb_faces_elem) &amp;&amp; (elem_faces(elem1,fac_loc)!=num_face)) fac_loc++;</span>
<span class="comment">// if (fac_loc==nb_faces_elem) ok=0;</span>

                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
                      {
                        <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
                        <span class="keywordtype">int</span> j0=j*nb_comp+nc;

                        matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                        matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;

                        <span class="keywordflow">if</span> (!ok) n0=fac_asso*nb_comp+nc;
                        <span class="keywordflow">if</span> (j&lt;nb_faces)
                          {
                            matrice(j0,n0)-=val*porosite_face((n0-nc)/nb_comp)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                            matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                          }

                      }
                  }

<span class="comment">// Deuxieme element</span>
              elem2 = face_voisins(num_face,1);

              <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
                <span class="keywordflow">if</span> ( ( (j= elem_faces(elem2,i)) &gt; num_face ) &amp;&amp; (j != fac_asso ) )
                  {
                    val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem2,nu(elem2));

                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
                      {
                        <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
                        <span class="keywordtype">int</span> j0=j*nb_comp+nc;

                        matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                        matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                      }
                  }

            }<span class="comment">//fin du for sur &quot;num_face&quot;</span>
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">for</span> (num_face=num1; num_face&lt;num2; num_face++)
            {
              elem1 = face_voisins(num_face,0);

              <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
                <span class="keywordflow">if</span> ( (j= elem_faces(elem1,i)) &gt; num_face )
                  {
                    val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem1,nu(elem1));
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
                      {
                        <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
                        <span class="keywordtype">int</span> j0=j*nb_comp+nc;

                        matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                        matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                        <span class="keywordflow">if</span> (j&lt;nb_faces) <span class="comment">//necessaire ????</span>
                          {
                            matrice(j0,n0)-=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                            matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                          }

                      }
                  }
            }
        }
    }

<span class="comment">// On ne remplit que les lignes reelles</span>
  <span class="keywordflow">for</span> (num_face=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>(); num_face&lt;nb_faces; num_face++)
    {
      elem1 = face_voisins(num_face,0);
      elem2 = face_voisins(num_face,1);

      <span class="keywordflow">for</span> (i=0; i&lt;nb_faces_elem; i++)
        {
          <span class="keywordflow">if</span> ( (j=elem_faces(elem1,i)) &gt; num_face )
            {
              val = <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem1,nu(elem1));
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
                {
                  <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
                  <span class="keywordtype">int</span> j0=j*nb_comp+nc;

                  matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                  matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                  <span class="keywordflow">if</span> (j&lt;nb_faces)
                    {
                      matrice(j0,n0)-=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                      matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                    }
                }
            }

<span class="comment">// if (elem2!=-1) //test non necessaire car la face est reelle</span>
          <span class="keywordflow">if</span> ( (j=elem_faces(elem2,i)) &gt; num_face )
            {
              val= <a class="code" href="classOp__Diff__VEF__base.html#a0abfc9af2ce36a8d4554d0e679940257">viscA</a>(num_face,j,elem2,nu(elem2));
              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nc=0; nc&lt;nb_comp; nc++)
                {
                  <span class="keywordtype">int</span> n0=num_face*nb_comp+nc;
                  <span class="keywordtype">int</span> j0=j*nb_comp+nc;

                  matrice(n0,n0)+=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                  matrice(n0,j0)-=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                  <span class="keywordflow">if</span> (j&lt;nb_faces)
                    {
                      matrice(j0,n0)-=val*porosite_face(num_face)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                      matrice(j0,j0)+=val*porosite_face(j)*<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
                    }

                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae979dc98da8579c81ed4abf017475277"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::ajouter_contribution_som" ref="ae979dc98da8579c81ed4abf017475277" args="(const DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::ajouter_contribution_som </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">1518</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00975">calculer_laplacien_som()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <a class="code" href="classIntVect.html">IntVect</a> liste_som(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);<span class="comment">//pour triangles et tetraedres</span>

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient0(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient1(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

  <span class="keyword">const</span> <span class="keywordtype">int</span> premiere_face_int=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();

  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> ind_face=0;
  <span class="keywordtype">int</span> n_bord=0;
  <span class="keywordtype">int</span> num1=0,num2=0;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coeff_perio(nb_faces_tot);
  coeff_perio=1.;
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
            coeff_perio(face)=0.5;
          }
    }

<span class="comment">// </span>
<span class="comment">// Partie P1 du laplacien discret :</span>
<span class="comment">// on tourne sur les lignes donc nous n&#39;avons</span>
<span class="comment">// besoin que de remplir les lignes reelles.</span>
<span class="comment">// ATTENTION : le remplissage des lignes reelles</span>
<span class="comment">// peut induire le calcul d&#39;un coefficient</span>
<span class="comment">// lie a une colonne virtuelle</span>
<span class="comment">// </span>

  <span class="comment">/* Faces internes */</span>
  <span class="keywordflow">for</span> (face=premiere_face_int; face&lt;nb_faces; face++)
    {
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a79b580276b1459de268cf4cfcd7b0665">coeff_matrice_som</a>(face,liste_som,
                        gradient0,gradient1,
                        porosite_face,nu_som,
                        coeff_perio,matrice);
    }

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keywordtype">int</span> faceAss=0;

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));

<span class="comment">// On prend la plus petite des faces pour etre sur de n&#39;oublier</span>
<span class="comment">// aucune face de bord</span>
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a706eb5baeef2cc4eddd0ea43fb11f73c">coeff_matrice_som_perio</a>(face,faceAss,liste_som,
                                      gradient0,gradient1,
                                      porosite_face,nu_som,
                                      coeff_perio,matrice);

            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a40963269ea0e5eee6023bcef8f4b5162">coeff_matrice_som_symetrie</a>(face,liste_som,
                                       gradient0,gradient1,
                                       porosite_face,nu_som,
                                       coeff_perio,matrice);
          }

      <span class="keywordflow">else</span>
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac34445bdca920e590a8d84ca2c1099ff">coeff_matrice_som_CL</a>(face,liste_som,
                                 gradient0,gradient1,
                                 porosite_face,nu_som,
                                 coeff_perio,matrice);
          }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c7833289430f6a53298a97b059f7301"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::associer" ref="a0c7833289430f6a53298a97b059f7301" args="(const Zone_dis &amp;, const Zone_Cl_dis &amp;, const Champ_Inc &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::associer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classZone__dis.html">Zone_dis</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_dis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classZone__Cl__dis.html">Zone_Cl_dis</a> &amp;&#160;</td>
          <td class="paramname"><em>zone_cl_dis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChamp__Inc.html">Champ_Inc</a> &amp;&#160;</td>
          <td class="paramname"><em>ch_diffuse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__base.html#a7a704b3a4f79b03ee0b1d301495b25f7">Op_Diff_VEF_base</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00199">199</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00081">Op_Diff_VEF_base::inconnue_</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00079">Op_Diff_VEF_base::la_zone_vef</a>, <a class="el" href="Frontiere__dis__base_8cpp_source.html#l00146">Frontiere_dis_base::le_nom()</a>, <a class="el" href="Field__base_8h_source.html#l00138">Field_base::nature_du_champ()</a>, <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__Inc_8h_source.html#l00043">Deriv_Champ_Inc_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Zone__Cl__dis_8h_source.html#l00032">Deriv_Zone_Cl_dis_base::valeur()</a>, <a class="el" href="Zone__dis_8h_source.html#l00029">Deriv_Zone_dis_base::valeur()</a>, and <a class="el" href="Field__base_8h_source.html#l00044">vectoriel</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zvef = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>,zone_dis.<a class="code" href="classDeriv__Zone__dis__base.html#a30ff47fc0684fe134e8c74c35b268941">valeur</a>());
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a>&amp; zclvef = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a>,zone_cl_dis.<a class="code" href="classDeriv__Zone__Cl__dis__base.html#a6b56880f00b604e1f13970ec6d5bc077">valeur</a>());

<span class="comment">// On bloque la symetrie dans l operateur de diffusion P1NC sur vitesse (OK pour scalaire)</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;zclvef.nb_cond_lim(); i++)
    {
      <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a> la_cl = zclvef.les_conditions_limites(i);
      <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) &amp;&amp; (ch_diffuse.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>().<a class="code" href="classField__base.html#a75bf4e0a6258589a83801c0383d049cc" title="Renvoie la nature d&#39;un champ (scalaire, multiscalaire, vectoriel).">nature_du_champ</a>()==<a class="code" href="Field__base_8h.html#a1b86c8f670a9b34da7f628a821fb646ba66d795f4e2fbb5636a3966c73964c5e7">vectoriel</a>) )
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;\nBoundary conditions of &#39;Symetrie&#39; type with P1NCP1B diffusion operator are only allowed for Conduction equation!&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Here you use a P1NCP1B diffusion operator in a &#39;&quot;</span> &lt;&lt; <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot;&#39; equation where&quot;</span> &lt;&lt; finl;
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;boundary condition number &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;, on boundary &#39;&quot;</span> &lt;&lt; la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>().<a class="code" href="classFrontiere__dis__base.html#a5a7eb46dc3af8a7d4225adc1814845d8" title="Renvoie le nom de la frontiere geometrique.">le_nom</a>() &lt;&lt; <span class="stringliteral">&quot;&#39; has been assigned to: &#39;&quot;</span> &lt;&lt; la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>().<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() &lt;&lt; <span class="stringliteral">&quot;&#39;.&quot;</span> &lt;&lt; finl;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
        }
    }

  <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>,ch_diffuse.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>()))
    {
      <span class="keyword">const</span> <a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>&amp; inco = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__P1NC.html">Champ_P1NC</a>,ch_diffuse.<a class="code" href="classDeriv__Champ__Inc__base.html#a9e0b743a3e124e7114fa977b36b68225">valeur</a>());
      <a class="code" href="classOp__Diff__VEF__base.html#abbeb435814253a33ecaf170b6f03829f">inconnue_</a> = inco;
    }

  <a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a> = zvef;
  <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a> = zclvef;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2f86fceb1e62fd028ed023cecf1ac447"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer" ref="a2f86fceb1e62fd028ed023cecf1ac447" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#ab00338d4ecfa38493b45a6e1ff4b2b71">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01086">1086</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  resu = 0;
  <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a758c8869b8f0b8bd04a888995a9e3249">ajouter</a>(inconnue,resu);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3315f6694fb97261a1fdefe4d52d83b1"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_divergence_aretes" ref="a3315f6694fb97261a1fdefe4d52d83b1" args="(DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer_divergence_aretes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00969">969</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> div;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a529ec43db5b4b872207a7bb2dd40a7ba"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_divergence_elem" ref="a529ec43db5b4b872207a7bb2dd40a7ba" args="(DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer_divergence_elem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00826">826</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00137">gradient_p0_</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l01069">Op_Diff_VEF_Face::verifier()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem=0,face_loc=0,face=0,compi=0,compj=0;

  <span class="keywordtype">double</span> signe=0.;

  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
      {
        face=elem_faces(elem,face_loc);

        signe=1.;
        <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1.;

        <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
          <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
            div[face*dim_ch_+compi]-=
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)
              *signe*face_normales(face,compj);
      }

  div.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B divergence P0 : &quot;</span>, div);
  <span class="keywordflow">return</span> div;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa940ce85caaf77638f592302b1fd8561"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_divergence_som" ref="aa940ce85caaf77638f592302b1fd8561" args="(DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer_divergence_som </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00862">862</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">gradient_p1_</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00538">Zone_VF::nb_som_face()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l01069">Op_Diff_VEF_Face::verifier()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> sigma(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem=0,face_loc=0,face_loc2=0,face=0;
  <span class="keywordtype">int</span> compi=0,compj=0,som=0,ind_face=0;
  <span class="keywordtype">int</span> num1=0, num2=0,som_loc=0;

  <span class="keyword">static</span> <span class="keywordtype">double</span> coeff_som=1./(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
  <span class="keywordtype">double</span> signe=0.;

<span class="comment">// Algorithme sans tenir compte des CL</span>
  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
      {
        som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som_elem(elem,face_loc));
        face=elem_faces(elem,face_loc);

        signe=1;
        <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1;

        <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
          sigma[compj]=signe*face_normales(face,compj);

        <span class="keywordflow">for</span>(face_loc2=0; face_loc2&lt;nb_faces_elem; face_loc2++)
          <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
              div[elem_faces(elem,face_loc2)*dim_ch_+compi]-=
                coeff_som*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)*sigma[compj];
      }

<span class="comment">// Les conditions aux limites</span>
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets = zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient_bord(dim_ch_,dimension);

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());
      num1 = 0;
      num2 = le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann.html" title="Classe Neumann Cette classe est la classe de base de la hierarchie des conditions aux limites de type...">Neumann</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
          <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__val__ext.html" title="Classe Neumann_val_ext Cette classe est la classe de base de la hierarchie des conditions aux limites...">Neumann_val_ext</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
          <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
          <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
         )
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
<span class="comment">// Le numero de la face (qui peut etre virtuelle)</span>
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

<span class="comment">// Le numero de l&#39;element voisin</span>
              elem=face_voisins(face,0);
              assert(elem!=-1);

<span class="comment">// Calcul du gradient au milieu de la face de bord</span>
<span class="comment">// On prend une integration numerique approchee</span>
              gradient_bord=0.;
              <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_face; som_loc++)
                {
                  som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));

                  <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                    <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                      gradient_bord(compi,compj)+=
                        <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj);
                }
              gradient_bord/=<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;

<span class="comment">// Calcul divergence au bord : formule d&#39;integration numerique</span>
<span class="comment">// exacte pour polynome d&#39;ordre 1</span>
              <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                  div[face*dim_ch_+compi]-=
                    gradient_bord(compi,compj)
                    *face_normales(face,compj);

            }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>

        }<span class="comment">//fin du if sur &quot;Neumann_paroi&quot;, &quot;Neumann&quot;, &quot;Symetrie&quot;</span>

    }<span class="comment">//fin du for sur &quot;n_bords&quot;</span>

  div.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B divergence P1 : &quot;</span>, div);
  <span class="keywordflow">return</span> div;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aed99737b6470f55a7423b4c6c956db05"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab" ref="aed99737b6470f55a7423b4c6c956db05" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcul dt_stab. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>double<br/>
 Signification: renvoie toujours 1.e30<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__base.html#aff568f5f8471618e59de045b44da5c84">Op_Diff_VEF_base</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">237</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00423">calculer_dt_stab_aretes()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00323">calculer_dt_stab_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00628">Zone_VF::creer_tableau_aretes()</a>, <a class="el" href="Domaine_8cpp_source.html#l00435">Domaine::creer_tableau_sommets()</a>, <a class="el" href="Double_8h_source.html#l00072">DMAXFLOAT</a>, <a class="el" href="Double_8h_source.html#l00075">DMINFLOAT</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Process_8cpp_source.html#l00167">Process::mp_min()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00083">Op_Diff_VEF_base::nu_</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00060">Op_Diff_VEF_base::phi_psi_diffuse()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00268">Op_Diff_VEF_base::remplir_nu()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02229">remplir_nu_p1()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02310">remplir_nu_pA()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__VF_8h_source.html#l00736">Zone_VF::volumes_entrelaces()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes_entrelaces=zone_VEF.<a class="code" href="classZone__VF.html#a64f0b549e5aea1656855113e3510f418">volumes_entrelaces</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_elem = zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> coeffOperateur(nb_faces_tot);
  coeffOperateur=0.;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu;

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> marq = <a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());

  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> ind_face=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> n_bord=0;

  <span class="keywordtype">double</span> dt_stab=<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;

<span class="comment">// Calcul de la porosite</span>
  <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
  <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,porosite_elem);

<span class="comment">// Calcul : contribution des parties P0, P1 et Pa au dt_stab</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a992a4048490448ef27d6ef07e730eda5">calculer_dt_stab_elem</a>(nu,coeffOperateur);
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
    {
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu_p1;
      zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a4f0227976726b0e66cbe318901d690d3">calculer_dt_stab_som</a>(nu_p1,coeffOperateur);
    }
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
    {
      <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu_pA;
      zone_VEF.<a class="code" href="classZone__VF.html#ae77f9ddf0711c0bcf2162921698d0bea">creer_tableau_aretes</a>(nu_pA);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3b64900128cbb94e4b8980e5ac10b49d">remplir_nu_pA</a>(nu,nu_pA);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ac2cf135bf96f42a0eca42e7ff3c30d48">calculer_dt_stab_aretes</a>(nu_pA,coeffOperateur);
    }
<span class="comment">// Calcul : modification pour tenir compte de la matrice de masse</span>
  <span class="keywordflow">for</span> (face=0; face&lt;nb_faces; face++)
    {
      coeffOperateur(face)/=volumes_entrelaces(face);
      assert(coeffOperateur(face)&gt;=0.);
      coeffOperateur(face)=1./(coeffOperateur(face)+<a class="code" href="Double_8h.html#a0a3fffa6d17ad8f7de4bb337c6266561">DMINFLOAT</a>);
    }

<span class="comment">// Calcul : modification pour les faces de Dirichlet</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
          <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
         )
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
            coeffOperateur(face)=1.e20;
          }
    }

<span class="comment">// Calcul du pas de temps de stabilite</span>
<span class="comment">// : on en a besoin que sur les faces reelles</span>
  <span class="keywordflow">for</span> (face=0; face&lt;nb_faces; face++)
    <span class="keywordflow">if</span> (coeffOperateur(face)&lt;dt_stab)
      dt_stab=coeffOperateur(face);

  dt_stab=<a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_min</a>(dt_stab);
  <span class="keywordflow">return</span> dt_stab;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2cf135bf96f42a0eca42e7ff3c30d48"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_aretes" ref="ac2cf135bf96f42a0eca42e7ff3c30d48" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_aretes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffOperateur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00423">423</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Error in Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_aretes()&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Function not coded&quot;</span>&lt;&lt;finl;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Exit&quot;</span>&lt;&lt;finl;
  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a992a4048490448ef27d6ef07e730eda5"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_elem" ref="a992a4048490448ef27d6ef07e730eda5" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffOperateur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00323">323</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00083">Op_Diff_VEF_base::nu_</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__VF_8h_source.html#l00419">Zone_VF::volumes()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes=zone_VEF.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();

  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> face=0,face_loc=0;
  <span class="keywordtype">int</span> faceAss=0,faceAss_loc=0;
  <span class="keywordtype">int</span> dim=0;
  <span class="keywordtype">int</span> ind_face=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> n_bord=0;

  <span class="keywordtype">double</span> psc=0.;
  <span class="keywordtype">double</span> volume=0.;
  <span class="keywordtype">double</span> nu_elem=0.;
  <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=0.;

  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    {
      volume=volumes(elem);
      nu_elem=<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>(elem);

      <span class="keywordflow">for</span> (face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
        {
          face=elem_faces(elem,face_loc);

          psc=0.;
          <span class="keywordflow">for</span> (dim=0; dim&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; dim++)
            psc+=face_normales(face,dim)*face_normales(face,dim);

          coeff=nu_elem;
          coeff/=volume;
          coeff*=psc;
          coeff*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
          coeffOperateur(face)+=<a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>;
        }
    }

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              faceAss_loc=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
              faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(faceAss_loc);

              <span class="keywordflow">if</span> (face&lt;faceAss)
                {
                  coeffOperateur(faceAss)+=coeffOperateur(face);
                  coeffOperateur(face)=coeffOperateur(faceAss);
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4f0227976726b0e66cbe318901d690d3"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_som" ref="a4f0227976726b0e66cbe318901d690d3" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_dt_stab_som </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeffOperateur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">402</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00975">calculer_laplacien_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00141">is_laplacian_filled_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00140">laplacien_p1_</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00099">Matrice_Morse::nb_lignes()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();

  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> face_C=0;

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>()&lt;2) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">dimensionner</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>);
  <span class="keywordflow">if</span> (!<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a7d0688de99484ee5807a0846219ebe2d">calculer_laplacien_som</a>(nu_som);

<span class="comment">// REMARQUE : on multiplie par -1 car laplacien_p1_=+Delta</span>
  <span class="keywordflow">for</span> (face=0; face&lt;nb_faces; face++)
    {
      face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//pour le cas vectoriel</span>
      coeffOperateur(face)+=-1.*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>(face_C,face_C);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4de56f9fddbc93956dc697dcf31f7583"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_aretes" ref="a4de56f9fddbc93956dc697dcf31f7583" args="(const DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_aretes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01334">1334</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Op_Dift_VEF_P1NCP1B_Face::calculer_flux_bords_aretes() not coded&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Exit&quot;</span>&lt;&lt;finl;
  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16f33e9d0867d5888e2faf4d87c85989"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_elem" ref="a16f33e9d0867d5888e2faf4d87c85989" args="(const DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">1129</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Operateur__base_8h_source.html#l00168">Operateur_base::flux_bords_</a>, <a class="el" href="Neumann__paroi_8cpp_source.html#l00089">Neumann_paroi::flux_impose()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00137">gradient_p0_</a>, <a class="el" href="Echange__impose__base_8cpp_source.html#l00193">Echange_impose_base::h_imp()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Echange__impose__base_8cpp_source.html#l00132">Echange_impose_base::T_ext()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();

  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> n_bord=0,ind_face=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> compi=0,compj=0;

  <span class="keywordtype">double</span> surface=0.;
  <span class="keywordtype">double</span> Text=0.;

  <span class="keywordtype">double</span> coeff_conv=1.;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) coeff_conv=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; la_cl_paroi=
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*
                                        la_cl_paroi.<a class="code" href="classNeumann__paroi.html#a76b977c608b621e7dd7106401ab44936" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face,compi)*
                                        surface;
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; la_cl_paroi=
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                {
                  Text=la_cl_paroi.<a class="code" href="classEchange__impose__base.html#ad2ef464a05e25ba48a5c75af56352440" title="Renvoie la valeur de la temperature imposee sur la i-eme composante du champ de frontiere.">T_ext</a>(ind_face,compi);

                  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*la_cl_paroi.<a class="code" href="classEchange__impose__base.html#a1e75de051a3afbd228374eabc5be9485" title="Renvoie la valeur du coefficient d&#39;echange de chaleur impose sur la i-eme composante du champ de fron...">h_imp</a>(ind_face,compi)*surface;
                  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)*=(Text-inconnue[face*dim_ch_+compi]);
                }
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
                <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
                <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
              )
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=0.;
            }
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              elem=face_voisins(face,0);
              assert(elem!=-1);

<span class="comment">// le coefficient de convexite est deja dans gradient_p0_</span>
              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)
                                          *face_normales(face,compj);
            }
        }
    }<span class="comment">//fin du for sur n_bord</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeb1ae7dfd65857f58bbe29defb6bf747"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_som" ref="aeb1ae7dfd65857f58bbe29defb6bf747" args="(const DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_flux_bords_som </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">1227</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00054">Zone_VF::face_surfaces()</a>, <a class="el" href="Operateur__base_8h_source.html#l00168">Operateur_base::flux_bords_</a>, <a class="el" href="Neumann__paroi_8cpp_source.html#l00089">Neumann_paroi::flux_impose()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">gradient_p1_</a>, <a class="el" href="Echange__impose__base_8cpp_source.html#l00193">Echange_impose_base::h_imp()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Zone__VF_8h_source.html#l00538">Zone_VF::nb_som_face()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Echange__impose__base_8cpp_source.html#l00132">Echange_impose_base::T_ext()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();

  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> som=0,som_loc=0;
  <span class="keywordtype">int</span> n_bord=0,ind_face=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> compi=0,compj=0;

  <span class="keywordtype">double</span> surface=0.;
  <span class="keywordtype">double</span> Text=0.;
  <span class="keywordtype">double</span> coeff_conv=1.;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; la_cl_paroi=
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*
                                        la_cl_paroi.<a class="code" href="classNeumann__paroi.html#a76b977c608b621e7dd7106401ab44936" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face,compi)*
                                        surface;
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; la_cl_paroi=
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              surface=zone_VEF.<a class="code" href="classZone__VF.html#a40c3382b189a4fc508cf1c3e37b04b21">face_surfaces</a>(face);

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                {
                  Text=la_cl_paroi.<a class="code" href="classEchange__impose__base.html#ad2ef464a05e25ba48a5c75af56352440" title="Renvoie la valeur de la temperature imposee sur la i-eme composante du champ de frontiere.">T_ext</a>(ind_face,compi);

                  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=coeff_conv*la_cl_paroi.<a class="code" href="classEchange__impose__base.html#a1e75de051a3afbd228374eabc5be9485" title="Renvoie la valeur du coefficient d&#39;echange de chaleur impose sur la i-eme composante du champ de fron...">h_imp</a>(ind_face,compi)*surface;
                  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)*=(Text-inconnue[face*dim_ch_+compi]);
                }
            }
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__homogene.html" title="Classe Neumann_homogene Cette classe est la classe de base de la hierarchie des conditions aux limite...">Neumann_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
                <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__sortie__libre.html" title="classe Neumann_sortie_libre Cette classe represente une frontiere ouverte sans vitesse imposee Pour l...">Neumann_sortie_libre</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()) ||
                <a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>())
              )
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)=0.;
            }
        }
      <span class="keywordflow">else</span>
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

<span class="comment">// le coefficient de convexite est deja dans gradient_p1_</span>
              <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_face; som_loc++)
                {
                  som=face_sommets(face,som_loc);
                  som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

                  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                    <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                      <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)+=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)*
                                               face_normales(face,compj);
                }

              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>(face,compi)/=nb_som_face;
            }
        }
    }<span class="comment">//fin du for sur n_bord</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="afb9be14ba93fdea98e9f53d952752034"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_gradient_aretes" ref="afb9be14ba93fdea98e9f53d952752034" args="(const DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer_gradient_aretes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00724">724</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00139">gradient_pa_</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a054036b7f0ee412cb3a959885d915f2f"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_gradient_elem" ref="a054036b7f0ee412cb3a959885d915f2f" args="(const DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer_gradient_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">433</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00137">gradient_p0_</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l01069">Op_Diff_VEF_Face::verifier()</a>, <a class="el" href="Zone__VF_8h_source.html#l00419">Zone_VF::volumes()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volumes = zone_VEF.<a class="code" href="classZone__VF.html#aea771c835e561469d2d21dbca5fac1cf" title="renvoie le volume de la maille i.">volumes</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keywordtype">int</span> elem=0,face_loc=0,face=0,compi=0,compj=0;

  <span class="keywordtype">double</span> signe=0.;
  <span class="keywordtype">double</span> volume=0.;

<span class="comment">// Valeurs INTEGRALES du gradient_p0_</span>
  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
      {
        face=elem_faces(elem,face_loc);

        signe=1;
        <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1;

        <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
          <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)+=signe*
                                            inconnue[face*dim_ch_+compi]*
                                            face_normales(face,compj);
      }

<span class="comment">// Valeurs NODALES du gradient_p0_</span>
  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    {
      volume = volumes(elem);

      <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
        <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
          <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>(elem,compi,compj)/=(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume);
    }

<span class="comment">// REMARQUE : cet echange_espace_virtuel() est NECESSAIRE</span>
<span class="comment">// dans le cas ou alphaS==1 et/ou alphaA=1</span>
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>*=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B Gradient P0 : &quot;</span>,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>);

  <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5e85dd4ed5a586f2787a149790ba0714"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_gradient_som" ref="a5e85dd4ed5a586f2787a149790ba0714" args="(const DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::calculer_gradient_som </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">486</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Cond__lim__base_8h_source.html#l00196">Cond_lim_base::champ_front()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Domaine_8h_source.html#l00500">Domaine::coord_sommets()</a>, <a class="el" href="Domaine_8cpp_source.html#l00435">Domaine::creer_tableau_sommets()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">gradient_p1_</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00040">Zone_VEF_PreP1b::nb_som()</a>, <a class="el" href="Zone__VF_8h_source.html#l00538">Zone_VF::nb_som_face()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00152">Zone_dis_base::nb_som_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Equation__base_8cpp_source.html#l01120">Equation_base::schema_temps()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Schema__Temps__base_8h_source.html#l00676">Schema_Temps_base::temps_courant()</a>, <a class="el" href="Champ__front_8h_source.html#l00030">Deriv_Champ_front_base::valeur()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Champ__front__txyz_8cpp_source.html#l00154">Champ_front_txyz::valeur_au_temps_et_au_point()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l01069">Op_Diff_VEF_Face::verifier()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#a7fa6f80d06f2f6d193e9311abc68412c">nb_som</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordtype">int</span> elem=0,face_loc=0,som_loc=0,face=0;
  <span class="keywordtype">int</span> compi=0,compj=0,som=0,num1=0,num2=0;
  <span class="keywordtype">int</span> i=0,ind_face=0;
  <span class="keywordtype">int</span> n_bord=0;

  <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=1./(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>)/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);
  <span class="keywordtype">double</span> signe=0.;

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales = zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> secmem(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);
  <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a> sigma(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

  <a class="code" href="classDoubleVect.html">DoubleVect</a> secmemij;
  <a class="code" href="classDoubleVect.html">DoubleVect</a> gradij;
  dom.<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(secmemij);
  dom.<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(gradij);

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();

<span class="comment">// Le second membre du systeme a inverser</span>
  secmem=0.;
  <span class="keywordflow">for</span>(elem=0; elem&lt;nb_elem_tot; elem++)
    {
      sigma = 0;
      <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
        {
          face = elem_faces(elem,face_loc);

          <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            sigma[compi]+=inconnue[face*dim_ch_+compi];
        }

      <span class="keywordflow">for</span>(face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
        {
          som = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som_elem(elem,face_loc));
          face = elem_faces(elem,face_loc);

          signe=1;
          <span class="keywordflow">if</span>(elem!=face_voisins(face,0)) signe=-1;

          <span class="keywordflow">for</span>(compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
              secmem(som,compi,compj)+=coeff_som*signe*
                                       sigma[compi]*face_normales(face,compj);
        }
    }

  secmem.echange_espace_virtuel();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B secmem, avant CL : &quot;</span>, secmem);

<span class="comment">// Les conditions aux limites pour le second membre</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
<span class="comment">// On ne fait rien et c&#39;est normal</span>
        }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>&amp; dirichlet =
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordtype">double</span> x=0.,y=0.,z=0.;
          <span class="keywordtype">double</span> inconnue_pt=0.;
          <span class="keywordtype">double</span> temps = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#abc11e51aa75b4c7aa55c27f71eb2f2c4" title="Renvoie le schema en temps associe a l&#39;equation.">schema_temps</a>().<a class="code" href="classSchema__Temps__base.html#a5054df01edb6d4f7baec7e612d423834" title="Renvoie le temps courant.">temps_courant</a>();

          <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord_sommets = dom.<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();

          <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__front__txyz.html" title="classe Champ_front_txyz Classe derivee de Champ_front_var qui represente les champs aux frontieres an...">Champ_front_txyz</a>,dirichlet.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>()))
            {
              <span class="keyword">const</span> <a class="code" href="classChamp__front__txyz.html" title="classe Champ_front_txyz Classe derivee de Champ_front_var qui represente les champs aux frontieres an...">Champ_front_txyz</a>&amp; champ_front =
                <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classChamp__front__txyz.html" title="classe Champ_front_txyz Classe derivee de Champ_front_var qui represente les champs aux frontieres an...">Champ_front_txyz</a>,dirichlet.<a class="code" href="classCond__lim__base.html#a8cddc02f544ee44bebd5bae0e6a9581c">champ_front</a>().<a class="code" href="classDeriv__Champ__front__base.html#a5405a20c106b868a23805a45c4436a53">valeur</a>());

              <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
                {
                  face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

                  <span class="keywordflow">for</span>(som_loc=0; som_loc&lt;nb_som_face; som_loc++)
                    {
                      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));

<span class="comment">// Formule d&#39;integration numerique exacte pour les polynomes de degre 2</span>
                      <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>==2) <span class="comment">//formule de Simpson</span>
                        {
<span class="comment">// Coordonnees du sommet &quot;som&quot;</span>
                          x=coord_sommets(som,0);
                          y=coord_sommets(som,1);

<span class="comment">// Valeur de l&#39;inconnue au point d&#39;integration</span>
                          <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                            {
                              inconnue_pt=
                                champ_front.<a class="code" href="classChamp__front__txyz.html#a99389bead147fbe4cd5d9839a8e7caea">valeur_au_temps_et_au_point</a>(temps,som,x,y,z,compi);

                              <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                                secmem(som,compi,compj) +=
                                  1./6*(2*inconnue[face*dim_ch_+compi]+inconnue_pt)
                                  *face_normales(face,compj) ;
                            }
                        }<span class="comment">//fin du if sur dimension==2</span>

                      <span class="keywordflow">else</span> <span class="comment">//formule exacte pour les polynomes de degre 2</span>
                        {
<span class="comment">// On suppose que l&#39;element considere est un TETRAEDRE</span>
                          <span class="keywordflow">for</span> (i=1; i&lt;3; i++)
                            {
                              <span class="keywordtype">int</span> som2=face_sommets(face,(som_loc+i)%nb_som_face);
                              som2=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som2);

<span class="comment">// Coordonnees des points d&#39;integration</span>
                              x=(coord_sommets(som,0)+coord_sommets(som2,0))/2.;
                              y=(coord_sommets(som,1)+coord_sommets(som2,1))/2.;
                              z=(coord_sommets(som,2)+coord_sommets(som2,2))/2.;

<span class="comment">// Vitesse au point d&#39;integration</span>
                              <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                                {
                                  inconnue_pt=
                                    champ_front.<a class="code" href="classChamp__front__txyz.html#a99389bead147fbe4cd5d9839a8e7caea">valeur_au_temps_et_au_point</a>(temps,som,x,y,z,compi);

                                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                                    secmem(som, compi, compj) += 1./dimension*
                                                                 1/2.*inconnue_pt*face_normales(face,compj) ;
                                }
                            }
                        }<span class="comment">//fin du else sur la dimension</span>

                    }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>

                }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>

            }<span class="comment">//fin du if sur &quot;Champ_front_txyz&quot;</span>
          <span class="keywordflow">else</span>
            {
              <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
                {
                  face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

                  <span class="keywordflow">for</span>(som_loc=0; som_loc&lt;nb_som_face; som_loc++)
                    {
                      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));

                      <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                        <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                          secmem(som,compi,compj) += 1./dimension*
                                                     inconnue[face*dim_ch_+compi]*face_normales(face,compj) ;

                    }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>

                }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
            }

        }<span class="comment">//fin du if sur &quot;Dirichlet&quot;</span>

      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              <span class="keywordflow">for</span>(som_loc=0; som_loc&lt;nb_som_face; som_loc++)
                {
                  som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(face_sommets(face,som_loc));

                  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                    <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                      secmem(som,compi,compj) += 1./dimension*
                                                 inconnue[face*dim_ch_+compi]*face_normales(face,compj) ;

                }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>

            }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>

        }<span class="comment">//fin du if sur &quot;!Periodique&quot;</span>

    }<span class="comment">//fin du for sur &quot;n_bord&quot;</span>

  secmem.echange_espace_virtuel();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B secmem, apres CL : &quot;</span>, secmem);

<span class="comment">// Calcul de la solution du systeme a inverser</span>
  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
    <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
      {
        <span class="keywordflow">for</span>(i=0; i&lt;nb_som_tot; i++)
          {
            som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
            secmemij(som)=secmem(som,compi,compj);
          }

<span class="comment">// Resolution du systeme</span>
        <span class="keywordflow">for</span>(i=0; i&lt;nb_som; i++)
          {
            som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
            gradij(som)=secmemij(som)/(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som));
          }

        <span class="keywordflow">for</span>(i=0; i&lt;nb_som_tot; i++)
          {
            som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(i);
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)
              =gradij(som);
          }
      }

  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B Gradient P1 : &quot;</span>,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);

  <span class="keywordflow">return</span> <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7d0688de99484ee5807a0846219ebe2d"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::calculer_laplacien_som" ref="a7d0688de99484ee5807a0846219ebe2d" args="(const DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::calculer_laplacien_som </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00975">975</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l00074">Op_Diff_VEF_Face::diffusivite()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00129">Matrice_Morse::get_set_coeff()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00141">is_laplacian_filled_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00140">laplacien_p1_</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00099">Matrice_Morse::nb_lignes()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; diffu=<a class="code" href="classOp__Diff__VEF__Face.html#aedc62e780da1eac2bb6c2756397a219f">diffusivite</a>();

  <span class="keywordtype">bool</span> testl=<span class="keyword">false</span>;
  testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Don__Fonc__xyz.html" title="class Champ_Don_Fonc_xyz Cette classe represente un champ de donnees fonction des variables d&#39;espaces...">Champ_Don_Fonc_xyz</a>,diffu);
  testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Don__lu.html" title="class Champ_Don_lu Cette classe represente un champ de donnees que l&#39;on lit dans un fichier avec les ...">Champ_Don_lu</a>,diffu);
  testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme.html" title="classe Champ_Uniforme Represente un champ constant dans l&#39;espace et dans le temps.">Champ_Uniforme</a>,diffu);
  testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Uniforme__Morceaux.html" title="classe Champ_Uniforme_Morceaux Cette classe represente champ constant par morceaux dans l&#39;espace et c...">Champ_Uniforme_Morceaux</a>,diffu);
  testl|=<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classChamp__Fonc__base.html" title="classe Champ_Fonc_base Classe de base des champs qui sont fonction d&#39;une grandeur calculee au cours d...">Champ_Fonc_base</a>,diffu);
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">is_laplacian_filled_</a>=testl;

  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Morse.html#acd067e8514e5741f52b18a1d99746d11">get_set_coeff</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; inconnue1=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; porosite_face=zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>();

  assert(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>()&gt;2);

  coeff=0.;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(inconnue1,porosite_face,nu_som,<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">laplacien_p1_</a>);
  coeff*=-1;<span class="comment">//pour l&#39;explicite</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a79b580276b1459de268cf4cfcd7b0665"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som" ref="a79b580276b1459de268cf4cfcd7b0665" args="(const int &amp;, IntVect &amp;, DoubleTab &amp;, DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">1633</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">decentrage_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">isInStencil()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00054">maximum()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();

  <span class="keywordtype">int</span> face_C=0;
  <span class="keywordtype">int</span> face2=0,face2_C=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;
  <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
  <span class="keywordtype">int</span> debut=0,size=0;
  <span class="keywordtype">int</span> compi=0,compj=0;
  <span class="keywordtype">int</span> elem0=0,elem1=0;
  <span class="keywordtype">int</span> i=0;
  <span class="keywordtype">int</span> nnz=0;

  <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
  <span class="keywordtype">double</span> coeff_diff=0.;
  <span class="keywordtype">double</span> psc=0.;
  <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;

  <span class="keywordtype">double</span> coeff_conv=1.;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);

<span class="comment">// Quelques verifications</span>
  assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// </span>
<span class="comment">// Partie P1 du laplacien discret</span>
<span class="comment">// </span>
  liste_som=-1;
  gradient0=0.;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,liste_som,gradient0);


  <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
  <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
  coeff_mat=0.;
  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
    {
      som=liste_som(som_loc);
      coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;

      psc=0.;
      <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        psc+=gradient0(compj,som_loc)
             *gradient0(compj,som_loc);

      psc*=coeff_som;
      psc*=nu_som(som);

      coeff_mat+=psc;
    }
  coeff_mat*=coeff_conv;

  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
    {
      face_C=face*dim_ch_+compi;
      matrice(face_C,face_C)+=coeff_mat;
    }


  <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
  <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
  <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
  <span class="comment">/* composantes de la matrice */</span>
  face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
  debut=tab1[face_C]-1;
  size=tab1[face_C+1]-tab1[face_C];

  <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
    {
      face2_C=tab2[debut+i]-1;
      face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>

      <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
        {
          coeff_mat=0.;
          <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
            {
              som=liste_som(som_loc);
              coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);

              <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
                {
                  assert(som_loc0!=-1);
                  gradient1=0.;
                  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);

                  psc=0.;
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    psc+=gradient0(compj,som_loc)
                         *gradient1(compj);

                  psc*=coeff_som;
                  psc*=nu_som(som);
                  coeff_mat+=psc;
                }
            }
          coeff_mat*=coeff_conv;
          coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
          coeff_mat+=coeff_diff;

          <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            {
              face_C=face*dim_ch_+compi;
              face2_C=face2*dim_ch_+compi;

              matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
              matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
              <span class="keywordflow">if</span> (face2&lt;nb_faces)
                {
                  matrice(face2_C,face_C)+=coeff_mat;
                  matrice(face2_C,face2_C)-=coeff_diff;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac34445bdca920e590a8d84ca2c1099ff"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som_CL" ref="ac34445bdca920e590a8d84ca2c1099ff" args="(const int &amp;, IntVect &amp;, DoubleTab &amp;, DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som_CL </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">1770</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">decentrage_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02842">gradient_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">isInStencil()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00054">maximum()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();

  <span class="keywordtype">int</span> face_C=0;
  <span class="keywordtype">int</span> face2=0,face2_C=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;
  <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
  <span class="keywordtype">int</span> debut=0,size=0;
  <span class="keywordtype">int</span> compi=0,compj=0;
  <span class="keywordtype">int</span> elem0=0,elem1=0;
  <span class="keywordtype">int</span> i=0;
  <span class="keywordtype">int</span> nnz=0;

  <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
  <span class="keywordtype">double</span> coeff_diff=0.;
  <span class="keywordtype">double</span> psc=0.;
  <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;

  <span class="keywordtype">double</span> coeff_conv=1.;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);

<span class="comment">// Quelques verifications</span>
  assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// </span>
<span class="comment">// Partie P1 du laplacien discret</span>
<span class="comment">// </span>
  liste_som=-1;
  gradient0=0.;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,liste_som,gradient0);


  <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
  <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
  coeff_mat=0.;
  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
    {
      som=liste_som(som_loc);
      coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;

      psc=0.;
      <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        psc+=gradient0(compj,som_loc)
             *gradient0(compj,som_loc);

      psc*=coeff_som;
      psc*=nu_som(som);

      coeff_mat+=psc;
    }
  coeff_mat*=coeff_conv;

  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
    {
      face_C=face*dim_ch_+compi;
      matrice(face_C,face_C)+=coeff_mat;
    }


  <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
  <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
  <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
  <span class="comment">/* composantes de la matrice */</span>
  face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
  debut=tab1[face_C]-1;
  size=tab1[face_C+1]-tab1[face_C];

  <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
    {
      face2_C=tab2[debut+i]-1;
      face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>

      <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
        {
          coeff_mat=0.;
          <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
            {
              som=liste_som(som_loc);
              coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);

              <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
                {
                  assert(som_loc0!=-1);
                  gradient1=0.;
                  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);

                  psc=0.;
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    psc+=gradient0(compj,som_loc)
                         *gradient1(compj);

                  psc*=coeff_som;
                  psc*=nu_som(som);
                  coeff_mat+=psc;
                }
            }
          coeff_mat*=coeff_conv;
          coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
          coeff_mat+=coeff_diff;

          <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            {
              face_C=face*dim_ch_+compi;
              face2_C=face2*dim_ch_+compi;

              matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
              matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
              <span class="keywordflow">if</span> (face2&lt;nb_faces)
                {
                  matrice(face2_C,face_C)+=coeff_mat;
                  matrice(face2_C,face2_C)-=coeff_diff;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a706eb5baeef2cc4eddd0ea43fb11f73c"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som_perio" ref="a706eb5baeef2cc4eddd0ea43fb11f73c" args="(const int &amp;, const int &amp;, IntVect &amp;, DoubleTab &amp;, DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som_perio </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>faceAss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">2048</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">decentrage_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">isInStencil()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00054">maximum()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();

  <span class="keywordtype">int</span> face_C=0;
  <span class="keywordtype">int</span> face2=0,face2_C=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;
  <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
  <span class="keywordtype">int</span> debut=0,size=0;
  <span class="keywordtype">int</span> compi=0,compj=0;
  <span class="keywordtype">int</span> elem0=0,elem1=0;
  <span class="keywordtype">int</span> i=0;
  <span class="keywordtype">int</span> nnz=0;

  <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
  <span class="keywordtype">double</span> coeff_diff=0.;
  <span class="keywordtype">double</span> psc=0.;
  <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;

  <span class="keywordtype">double</span> coeff_conv=1.;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);

<span class="comment">// Quelques verifications</span>
  assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// </span>
<span class="comment">// Partie P1 du laplacien discret</span>
<span class="comment">// </span>
  liste_som=-1;
  gradient0=0.;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,liste_som,gradient0);


  <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
  <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
  coeff_mat=0.;
  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
    {
      som=liste_som(som_loc);
      coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;

      psc=0.;
      <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        psc+=gradient0(compj,som_loc)
             *gradient0(compj,som_loc);

      psc*=coeff_som;
      psc*=nu_som(som);

      coeff_mat+=psc;
    }
  coeff_mat*=coeff_conv;

  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
    {
      face_C=face*dim_ch_+compi;
      matrice(face_C,face_C)+=coeff_mat;
    }


  <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
  <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
  <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
  <span class="comment">/* composantes de la matrice */</span>
  face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
  debut=tab1[face_C]-1;
  size=tab1[face_C+1]-tab1[face_C];

  <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
    {
      face2_C=tab2[debut+i]-1;
      face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>

      <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
        {
          coeff_mat=0.;
          <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
            {
              som=liste_som(som_loc);
              coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);

              <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
                {
                  assert(som_loc0!=-1);
                  gradient1=0.;
                  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);

                  psc=0.;
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    psc+=gradient0(compj,som_loc)
                         *gradient1(compj);

                  psc*=coeff_som;
                  psc*=nu_som(som);
                  coeff_mat+=psc;
                }
            }
          coeff_mat*=coeff_conv;
          coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
          coeff_mat+=coeff_diff;

          <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            {
              face_C=face*dim_ch_+compi;
              face2_C=face2*dim_ch_+compi;

              matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
              matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
              <span class="keywordflow">if</span> (face2&lt;nb_faces)
                {
                  matrice(face2_C,face_C)+=coeff_mat*coeff_perio(face);
                  matrice(face2_C,face2_C)-=coeff_diff*coeff_perio(face);
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a40963269ea0e5eee6023bcef8f4b5162"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som_symetrie" ref="a40963269ea0e5eee6023bcef8f4b5162" args="(const int &amp;, IntVect &amp;, DoubleTab &amp;, DoubleTab &amp;, const DoubleVect &amp;, const DoubleTab &amp;, const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::coeff_matrice_som_symetrie </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>liste_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>porosite_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_som</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff_perio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">1907</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">decentrage_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00134">Matrice_Morse::get_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00138">Matrice_Morse::get_tab2()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02842">gradient_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">isInStencil()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00054">maximum()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab1=matrice.<a class="code" href="classMatrice__Morse.html#a79b4e334152850bd36e53478debf3061">get_tab1</a>();
  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; tab2=matrice.<a class="code" href="classMatrice__Morse.html#a787b5a63f27063f9c891243d8f188cda">get_tab2</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();

  <span class="keywordtype">int</span> face_C=0;
  <span class="keywordtype">int</span> face2=0,face2_C=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;
  <span class="keywordtype">int</span> som_loc0=0,som_loc1=0;
  <span class="keywordtype">int</span> debut=0,size=0;
  <span class="keywordtype">int</span> compi=0,compj=0;
  <span class="keywordtype">int</span> elem0=0,elem1=0;
  <span class="keywordtype">int</span> i=0;
  <span class="keywordtype">int</span> nnz=0;

  <span class="keywordtype">double</span> coeff_som=0.,coeff_mat=0.;
  <span class="keywordtype">double</span> coeff_diff=0.;
  <span class="keywordtype">double</span> psc=0.;
  <span class="keywordtype">double</span> delta=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;

  <span class="keywordtype">double</span> coeff_conv=1.;
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) coeff_conv=(1.-<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>);

<span class="comment">// Quelques verifications</span>
  assert(gradient0.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(gradient0.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);
  assert(gradient1.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);
  assert(liste_som.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// </span>
<span class="comment">// Partie P1 du laplacien discret</span>
<span class="comment">// </span>
  liste_som=-1;
  gradient0=0.;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,liste_som,gradient0);


  <span class="comment">/* gradient associe a &quot;face&quot; : calcul du coefficient */</span>
  <span class="comment">/* diagonal de la matrice associee a l&#39;inconnue */</span>
  coeff_mat=0.;
  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
    {
      som=liste_som(som_loc);
      coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;

      psc=0.;
      <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        psc+=gradient0(compj,som_loc)
             *gradient0(compj,som_loc);

      psc*=coeff_som;
      psc*=nu_som(som);

      coeff_mat+=psc;
    }
  coeff_mat*=coeff_conv;

  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
    {
      face_C=face*dim_ch_+compi;
      matrice(face_C,face_C)+=coeff_mat;
    }


  <span class="comment">/* calcul des coefficients extra-diagonaux de la matrice laplacien */</span>
  <span class="comment">/* la matrice etant diagonale par bloc, on effectue le calcul du */</span>
  <span class="comment">/* produit scalaire une seule fois avant de l&#39;affecter aux differentes */</span>
  <span class="comment">/* composantes de la matrice */</span>
  <span class="comment">/* REMARQUE : la matrice est modifiee pour tenir compte des CL de */</span>
  <span class="comment">/* symetrie, mais on ne calcule pas les modifications associees -&gt; */</span>
  <span class="comment">/* c&#39;est la fonction Op_VEF_Face::modifier_pour_Cl() qui le fera */</span>
  face_C=face*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;
  debut=tab1[face_C]-1;
  size=tab1[face_C+1]-tab1[face_C];
  size-=(dim_ch_-1);<span class="comment">//-&gt; pour ne pas calculer les coefficients inutiles</span>

  <span class="keywordflow">for</span> (i=1; i&lt;size; i++) <span class="comment">//i=0 -&gt; face2_C=face_C -&gt; deja rempli</span>
    {
      face2_C=tab2[debut+i]-1;
      face2=face2_C/<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>;<span class="comment">//division euclidienne</span>

      <span class="keywordflow">if</span> (face2&gt;face)<span class="comment">//pour la symetrie de l&#39;operateur</span>
        {
          coeff_mat=0.;
          <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
            {
              som=liste_som(som_loc);
              coeff_som=volume_aux_sommets(som)*<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face2,som,elem0,som_loc0,elem1,som_loc1);

              <span class="keywordflow">if</span> (elem0!=-1)<span class="comment">//les deux faces se &quot;voient&quot;</span>
                {
                  assert(som_loc0!=-1);
                  gradient1=0.;
                  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face2,som,elem0,som_loc0,elem1,som_loc1,gradient1);

                  psc=0.;
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    psc+=gradient0(compj,som_loc)
                         *gradient1(compj);

                  psc*=coeff_som;
                  psc*=nu_som(som);
                  coeff_mat+=psc;
                }
            }
          coeff_mat*=coeff_conv;
          coeff_diff=-1.*delta*<a class="code" href="Op__Diff__VEFP1NCP1B__Face_8cpp.html#a4e834c1f122c09080eb7a6226c2f1185">maximum</a>(0.,coeff_mat);
          coeff_mat+=coeff_diff;

          <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            {
              face_C=face*dim_ch_+compi;
              face2_C=face2*dim_ch_+compi;

              matrice(face_C,face2_C)+=coeff_mat*coeff_perio(face2);
              matrice(face_C,face_C)-=coeff_diff*coeff_perio(face2);
              <span class="keywordflow">if</span> (face2&lt;nb_faces)
                {
                  matrice(face2_C,face_C)+=coeff_mat;
                  matrice(face2_C,face2_C)-=coeff_diff;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a67fc124061be17772b3fd1728709213f"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::completer" ref="a67fc124061be17772b3fd1728709213f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::completer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associe l'operateur a la zone_dis, la zone_Cl_dis,<br/>
et a l'inconnue de son equation. </p>

<p><p>&lt; pour ajout _Mx (moment) </p>
</p>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a285ea15814727e4fef62ba5e449ddd12">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00229">229</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a67fc124061be17772b3fd1728709213f" title="Associe l&#39;operateur a la zone_dis, la zone_Cl_dis, et a l&#39;inconnue de son equation.">Op_Diff_VEF_Face::completer</a>();

  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0939691aa4e08464a51cb16c33a62d51">initialiser</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="aee6ed8e488e0a0ba6c17621a7dd10115"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::contribuer_a_avec" ref="aee6ed8e488e0a0ba6c17621a7dd10115" args="(const DoubleTab &amp;, Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::contribuer_a_avec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>inco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on assemble la matrice. </p>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a176eefa93fd3cdd5b4dc26ceeead69d2">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00156">156</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a9fb46e714ef90e6b6eb46ce7bca4d375">ajouter_contribution</a>(inco, matrice);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d131deb7d32ff2c7830981433018b9c"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::contribuer_au_second_membre" ref="a6d131deb7d32ff2c7830981433018b9c" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::contribuer_au_second_membre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on ajoute la contribution du second membre. </p>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#ab4814d4168e093446417d260c10a5b9d">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00165">165</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>References <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l01011">Op_Diff_VEF_Face::contribue_au_second_membre()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classOp__Diff__VEF__Face.html#a7ff6076120f4733b8c65baf366320e0a">contribue_au_second_membre</a>(resu);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af61161babbf0b5a57042d39601c47e3e"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::corriger_Cl_test" ref="af61161babbf0b5a57042d39601c47e3e" args="(DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::corriger_Cl_test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03912">3912</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, and <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordtype">int</span> n_bord=0, num1=0, num2=0;
  <span class="keywordtype">int</span> face=0, <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=0;
  <span class="keywordtype">int</span> ind_face=0, comp=0;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=
                le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));

              <span class="keywordflow">if</span> (face&lt;<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>)
                <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
                  {
                    resu[face*dim_ch_+comp]+=resu[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp];
                    resu[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp]=resu[face*dim_ch_+comp];
                  }
            }
        }
    }
  resu.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a325ae974e29dd047801de2efaeea1174"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::corriger_div_pour_Cl" ref="a325ae974e29dd047801de2efaeea1174" args="(const DoubleVect &amp;, const DoubleTab &amp;, DoubleVect &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp; Op_Diff_VEFP1NCP1B_Face::corriger_div_pour_Cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>inconnue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00731">731</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00046">face_associee</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Neumann__paroi_8cpp_source.html#l00089">Neumann_paroi::flux_impose()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Echange__impose__base_8cpp_source.html#l00193">Echange_impose_base::h_imp()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00061">Front_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Zone__VF_8h_source.html#l00062">Zone_VF::surface()</a>, <a class="el" href="Echange__impose__base_8cpp_source.html#l00132">Echange_impose_base::T_ext()</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Op__Diff__VEF__Face_8cpp_source.html#l01069">Op_Diff_VEF_Face::verifier()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classConds__lim.html">Conds_lim</a>&amp; les_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>();
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords =les_cl.<a class="code" href="classvect__impl.html#a78155bfbd6b61f4710b9830641ed1694">size</a>();
  <span class="keywordtype">int</span> n_bord=0, num1=0, num2=0;
  <span class="keywordtype">int</span> face=0, face_asso_loc=0, <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=0;
  <span class="keywordtype">int</span> ind_face=0, comp=0;

  <span class="keywordtype">double</span> flux=0.;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

<span class="comment">// Reinitialisation de num1 et num2</span>
      num1 = 0;
      num2 = le_bord.<a class="code" href="classFront__VF.html#a341e2fcb5117b96e745fd7078ba86bab" title="Nombre de faces reelles du bord.">nb_faces</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
<span class="comment">// periodicite</span>
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              face_asso_loc=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
              <a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(face_asso_loc);

              <span class="keywordflow">if</span> (face&lt;<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>)
                <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
                  {
                    div[face*dim_ch_+comp]+=div[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp];
                    div[<a class="code" href="AssembleurPP1BUtil_8cpp.html#a3e374d53ebc7860e1c2f0b7906f2936d">face_associee</a>*dim_ch_+comp]=div[face*dim_ch_+comp];
                  }

            }<span class="comment">//fin du if sur for &quot;ind_face&quot;</span>

        }<span class="comment">//fin de la periodicite</span>

      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>&amp; la_cl_paroi =
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classNeumann__paroi.html" title="Classe Neumann_paroi Cette condition limite correspond a un flux impose pour l&#39;equation de transport ...">Neumann_paroi</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              assert(face_voisins(face,0)!=-1);

              <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
                {
                  flux=la_cl_paroi.<a class="code" href="classNeumann__paroi.html#a76b977c608b621e7dd7106401ab44936" title="Renvoie la valeur du flux impose sur la i-eme composante du champ representant le flux a la frontiere...">flux_impose</a>(ind_face,comp)
                       *zone_VEF.<a class="code" href="classZone__VF.html#af42306af8f7398c037e978377924ebe8">surface</a>(face);

                  div[face*dim_ch_+comp]+=flux;
                }
            }

        }<span class="comment">//fin if sur &quot;Neumann&quot;</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>&amp; la_cl_paroi=
            <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classEchange__externe__impose.html" title="Classe Echange_externe_impose: Cette classe represente le cas particulier de la classe Echange_impose...">Echange_externe_impose</a>, la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face = le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

              <span class="keywordflow">for</span> (comp=0; comp&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; comp++)
                {
                  flux=la_cl_paroi.<a class="code" href="classEchange__impose__base.html#a1e75de051a3afbd228374eabc5be9485" title="Renvoie la valeur du coefficient d&#39;echange de chaleur impose sur la i-eme composante du champ de fron...">h_imp</a>(ind_face,comp)
                       *zone_VEF.<a class="code" href="classZone__VF.html#af42306af8f7398c037e978377924ebe8">surface</a>(face);
                  flux*=(la_cl_paroi.<a class="code" href="classEchange__impose__base.html#ad2ef464a05e25ba48a5c75af56352440" title="Renvoie la valeur de la temperature imposee sur la i-eme composante du champ de frontiere.">T_ext</a>(ind_face,comp)-inconnue[face*dim_ch_+comp]);

                  div[face*dim_ch_+comp]+=flux;
                }
            }
        }
    }<span class="comment">//fin du for sur &quot;n_bords&quot;</span>

  div.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
  <a class="code" href="classOp__Diff__VEF__Face.html#aa3a7ae47654aef0e801eb78dc6a980af">Debog::verifier</a>(<span class="stringliteral">&quot;OpDifP1NCP1B divergence apres CL : &quot;</span>, div);
  <span class="keywordflow">return</span> div;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e35f1eae54ef9533a3409a26826428f"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::corriger_pour_diffusivite" ref="a9e35f1eae54ef9533a3409a26826428f" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp; Op_Diff_VEFP1NCP1B_Face::corriger_pour_diffusivite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01093">1093</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l02107">tab_multiply_any_shape()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="DoubleVect_8cpp.html#ae2081ab8f1947e8400a928ca3b172e29">tab_multiply_any_shape</a>(grad, nu);
  <span class="keywordflow">return</span> grad;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf50145420cf06ef2d6470743f248209"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::cree_instance" ref="aaf50145420cf06ef2d6470743f248209" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classObjet__U.html">Objet_U</a> * Op_Diff_VEFP1NCP1B_Face::cree_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#abb52c1902aa9a40d16a0e1a9156047ee">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#afff71c1340acef437b2eb99ba4277af2">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="af8e127ec31241c8d2aab78ad951aa253"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::dimensionner" ref="af8e127ec31241c8d2aab78ad951aa253" args="(Matrice_Morse &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::dimensionner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> &amp;&#160;</td>
          <td class="paramname"><em>matrice</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on dimensionne notre matrice. </p>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a9a49b2ab5126a0b775ecc4fc596fa892">Op_Diff_VEF_Face</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">3016</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l00346">Matrice_Morse::dimensionner()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00119">Matrice_Morse::get_set_tab1()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00124">Matrice_Morse::get_set_tab2()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00081">Op_Diff_VEF_base::inconnue_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03159">isFaceOfSymetry()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00079">Op_Diff_VEF_base::la_zone_vef</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02323">liste_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00204">next()</a>, <a class="el" href="IntLists_8h_source.html#l00069">IntLists::size()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>, <a class="el" href="Ref__Champ__Inc__base_8h_source.html#l00028">Ref_Champ_Inc_base::valeur()</a>, <a class="el" href="Champ__Inc__base_8cpp_source.html#l00221">Champ_Inc_base::valeurs()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_comp = <a class="code" href="classOp__Diff__VEF__base.html#abbeb435814253a33ecaf170b6f03829f">inconnue_</a>.<a class="code" href="classRef__Champ__Inc__base.html#a17553641a4c06730e1562125e07b3490">valeur</a>().<a class="code" href="classChamp__Inc__base.html#adb537f43f1649e103a8980314c7ed175" title="Renvoie le tableau des valeurs du champ au temps courant.">valeurs</a>().<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();

  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> i=0,size=0;
  <span class="keywordtype">int</span> comp=0,nnz=0,debut=0,face_f77=0,face_C=0;
  <span class="keywordtype">int</span> nb_faces_of_symetry=0;
  <span class="keywordtype">int</span> <a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>=0;

  <a class="code" href="classArrOfBit.html">ArrOfBit</a> is_symetry(nb_faces_tot);

  <a class="code" href="classIntVect.html">IntVect</a>&amp; tab1 = matrice.<a class="code" href="classMatrice__Morse.html#a7a49c763706dcfaed900f9d2cbb68716">get_set_tab1</a>();
  <a class="code" href="classIntVect.html">IntVect</a>&amp; tab2 = matrice.<a class="code" href="classMatrice__Morse.html#af11c5853518e9e6db4c7e6e6acc8d7fd">get_set_tab2</a>();

  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> faces_faces;

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a> &amp;&amp; !<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a> &amp;&amp; !<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
    <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">Op_VEF_Face::dimensionner</a>(<a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>(), <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>(), matrice);

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>)
    {
<span class="comment">// Calcul de la liste des faces</span>
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae2379b34f16ef970c39d7c515f51547c">liste_face</a>(faces_faces,nnz);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0e34a4eb1127c6810d661018f42e840c">isFaceOfSymetry</a>(is_symetry,nb_faces_of_symetry);

<span class="comment">// Dimensionnement des tableaux de la matrice</span>
<span class="comment">// REMARQUE : par essence, ce dimensionnement sera toujours plus GRAND</span>
<span class="comment">// que le dimensionnement par defaut issu de OP_VEF_FACE</span>
<span class="comment">// REMARQUE : pour tenir compte des contraintes dues aux faces de</span>
<span class="comment">// symetrie, le dimensionnement de la matrice doit etre legerement</span>
<span class="comment">// elargie</span>
      size=nnz*nb_comp;<span class="comment">//dimensionnement sans face de symetrie</span>
<span class="comment">// size+=nb_faces_of_symetry*(nb_comp-1)*nb_comp;//dimensionnement avec faces de symetrie</span>
<span class="comment">// pour chaque face de symetrie pour chaque composante on ajoute nb_comp coeffs pour chaque face liee</span>
      <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
        <span class="keywordflow">if</span> (is_symetry[face])
          {
            <span class="keywordtype">int</span> nb_v=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
            size+=nb_v*(nb_comp-1)*nb_comp;
          }

      matrice.<a class="code" href="classMatrice__Morse.html#ae95f9ed88a8a3fc637cd2a705cead9c8" title="Size the matrix with n lines and n columns and nnz zero-values coefficients.">dimensionner</a>(nb_faces_tot*nb_comp,size);

<span class="comment">// Initialisation des grandeurs connues pour tab1</span>
      tab1[nb_faces_tot*nb_comp]=size+1;
      tab1[0]=1;

<span class="comment">// Remplissage de tab1</span>

      <span class="comment">/* pour les autres composantes de la face 0 */</span>
      size=faces_faces[0].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
      <span class="keywordflow">if</span> (is_symetry[0]) size*=(nb_comp);
      <span class="keywordflow">for</span> (comp=1; comp&lt;nb_comp; comp++)
        {
          face_C=comp;
          tab1[face_C]=tab1[face_C-1]+size;
        }

      <span class="comment">/* pour les autres faces */</span>
      <span class="keywordflow">for</span> (face=1; face&lt;nb_faces_tot; face++)
        {
          size=faces_faces[face-1].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
          <span class="keywordflow">if</span> (is_symetry[face-1]) size*=(nb_comp);
          <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
            {
              face_C=face*nb_comp+comp;
              tab1[face_C]=tab1[face_C-1]+size;
              size=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
              <span class="keywordflow">if</span> (is_symetry[face]) size*=(nb_comp);
            }
        }

<span class="comment">// Remplissage de tab2</span>
      <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
        {
          size=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();

          <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
            {
              debut=tab1[face*nb_comp+comp]-1;

              <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
                {
                  face_C=faces_faces[face][i]*nb_comp+comp;
                  face_f77=face_C+1;
                  tab2[debut+i]=face_f77;
                }<span class="comment">//fin du for sur &quot;i&quot;</span>

            }<span class="comment">//fin du for sur &quot;comp&quot;</span>

        }<span class="comment">//fin du for sur &quot;face&quot;</span>

      <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
        <span class="keywordflow">if</span> (is_symetry[face])
          {
            size=faces_faces[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();

            <span class="keywordflow">for</span> (comp=0; comp&lt;nb_comp; comp++)
              {
                debut=tab1[face*nb_comp+comp]-1;
                debut+=size;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> voi=0; voi&lt;size; voi++)
                  {
                    <span class="keywordtype">int</span> face2=faces_faces[face][voi];
                    <span class="keywordflow">for</span> (i=0; i&lt;nb_comp-1; i++)
                      {
<span class="comment">// reste de la division euclidienne</span>
                        next=(comp+i+1)%nb_comp;
                        face_C=face2*nb_comp+<a class="code" href="Zone__VEF__PreP1b_8cpp.html#a24a462bbedad66c2a21f5f6f84b8ec5b">next</a>;
                        face_f77=face_C+1;
                        tab2[debut+i]=face_f77;
<span class="comment">// Cerr &lt;&lt;face*nb_comp+comp&lt;&lt;&quot; face &quot;&lt;&lt;face &lt;&lt; &quot; comp &quot;&lt;&lt; comp&lt;&lt; &quot; face2 &quot;&lt;&lt; face2 &lt;&lt; &quot; comp &quot;&lt;&lt;next &lt;&lt;&quot; jface2 &quot;&lt;&lt; face_C&lt;&lt;finl;</span>
                        assert(debut+i&lt;tab1[face*nb_comp+comp+1]-1);
                      }
                    debut+=nb_comp-1;
                  }

              }<span class="comment">//fin du for sur &quot;comp&quot;</span>

          }<span class="comment">//fin du for sur &quot;face&quot;</span>

    }<span class="comment">//fin du if sur &quot;alphaS&quot;</span>

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
    {
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Dift_VEFP1NCP1B_Face::dimensionner(Matrice_Morse&amp;)&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Le dimensionnement de la matrice implicite avec l&#39;option alphaA&quot;</span>
           &lt;&lt; <span class="stringliteral">&quot; n&#39;est pas encore codee&quot;</span> &lt;&lt; finl;
      <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme&quot;</span> &lt;&lt; finl;
      <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab7390cb60bca5cc34ed160c711fbf286"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::duplique" ref="ab7390cb60bca5cc34ed160c711fbf286" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op_Diff_VEFP1NCP1B_Face::duplique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a76e1d2a3251b4bc234f708cad9d25d57">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#aa87675ae592ed6cf4d7d2498b13211f4">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a797f4cea7d040a417a0c3f2236df851e"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::get_info" ref="a797f4cea7d040a417a0c3f2236df851e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Op_Diff_VEFP1NCP1B_Face::get_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a259460b5e14db3687d7e51e09459ef77">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#af323dc60a80a2885841e342637dee753">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a37f70143adef3313705fb8583168fd93"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::gradient_som" ref="a37f70143adef3313705fb8583168fd93" args="(const int &amp;face, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::gradient_som </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>som_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>elem0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>som_loc0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>som_loc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">2641</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
  <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=coeff/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);

  <span class="keywordtype">int</span> face_opp=0,compj=0;
  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">double</span> signe=0.;

  assert(grad.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==1);

<span class="comment">// </span>
<span class="comment">// Calcul du gradient</span>
<span class="comment">// </span>

  <span class="comment">/* On regarde le premier element voisin */</span>
  assert(elem0!=-1);
  assert(som_loc0!=-1);

<span class="comment">// Calcul du gradient local</span>
  face_opp = elem_faces(elem0,som_loc0);
  signe=1.;
  <span class="keywordflow">if</span>(elem0!=face_voisins(face_opp,0)) signe=-1.;

  <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
    grad(compj)=coeff_som*signe*
                face_normales(face_opp,compj);

  <span class="comment">/* On regarde le deuxieme element voisin */</span>
  <span class="keywordflow">if</span> (elem1==-1)
    {
      <span class="comment">/* Plusieurs possibilite :</span>
<span class="comment">         - &quot;face&quot; est interne reel</span>
<span class="comment">         - &quot;face&quot; est interne virtuel</span>
<span class="comment">         - &quot;face&quot; est de bord reel</span>
<span class="comment">         - &quot;face&quot; est de bord virtuel</span>
<span class="comment">         - &quot;face&quot; une face de joint */</span>
      assert(som_loc1==-1);
      elem=face_voisins(face,1);
      assert(face_voisins(face,0)!=-1);

      <span class="comment">/* &quot;face&quot; est de bord */</span>
      <span class="keywordflow">if</span> (elem==-1 &amp;&amp; face_opp!=face)
        <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
          grad(compj)+=coeff*face_normales(face,compj) ;
    }
  <span class="keywordflow">else</span>
    {
      assert(som_loc1!=-1);
      face_opp=elem_faces(elem1,som_loc1);
      signe=1.;
      <span class="keywordflow">if</span>(elem1!=face_voisins(face_opp,0)) signe=-1.;

<span class="comment">// Calcul du gradient local</span>
      <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj)+=coeff_som*signe*
                     face_normales(face_opp,compj);
    }

  grad/=(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som_glob));
}
</pre></div>
</div>
</div>
<a class="anchor" id="aef8420d4ce23c86e97333c7eeefb08cc"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::gradient_som" ref="aef8420d4ce23c86e97333c7eeefb08cc" args="(const int &amp;, int &amp;, IntVect &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::gradient_som </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>som_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02727">2727</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
  <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=coeff/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();

  <span class="keywordtype">int</span> face_opp=0,compj=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;
  <span class="keywordtype">int</span> loc=0;
  <span class="keywordtype">int</span> elem=0;

  <span class="keywordtype">double</span> signe=0.;
  <span class="keywordtype">double</span> volume=0.;

  assert(som_glob.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  assert(grad.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(grad.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// </span>
<span class="comment">// Calcul du gradient</span>
<span class="comment">// </span>

  nnz=0;
  <span class="comment">/* On regarde le premier element voisin */</span>
  elem=face_voisins(face,0);
  assert(elem!=-1);

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
    {
      som=elem_som(elem,som_loc);
      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

      face_opp=elem_faces(elem,som_loc);
      signe=1.;
      <span class="keywordflow">if</span>(elem!=face_voisins(face_opp,0)) signe=-1.;

<span class="comment">// ajout a la liste et incrementation du repere</span>
      som_glob(som_loc)=som;
      nnz++;

<span class="comment">// Calcul du gradient local</span>
      <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj,som_loc)=coeff_som*signe*
                            face_normales(face_opp,compj);
    }
  assert(nnz==nb_som_elem);

  <span class="comment">/* On regarde le deuxieme element voisin */</span>
  elem=face_voisins(face,1);
  assert(elem!=-1);

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
    {
      som=elem_som(elem,som_loc);
      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

      face_opp=elem_faces(elem,som_loc);
      signe=1.;
      <span class="keywordflow">if</span>(elem!=face_voisins(face_opp,0)) signe=-1.;

<span class="comment">// Localisation dans la liste deja construite</span>
      <span class="keywordflow">for</span> (loc=0; loc&lt;nnz; loc++)
        <span class="keywordflow">if</span> (som_glob[loc]==som)
          <span class="keywordflow">break</span>;

<span class="comment">// ajout a la liste et incrementation du repere</span>
      <span class="keywordflow">if</span> (loc==nnz)
        {
          som_glob(nnz)=som;
          nnz++;
        }

<span class="comment">// Calcul du gradient local</span>
      <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj,loc)+=coeff_som*signe*
                         face_normales(face_opp,compj);
    }
  assert(nnz&lt;=(dimension+2));

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
    {
      som=som_glob(som_loc);
      volume=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som);

<span class="comment">// On divise par la matrice de masse lumpee</span>
      <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj,som_loc)/=volume;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a253bedb1323fa89e08a8d88e2be8798d"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::gradient_som_CL" ref="a253bedb1323fa89e08a8d88e2be8798d" args="(const int &amp;, int &amp;, IntVect &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::gradient_som_CL </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>som_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02842">2842</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00331">coeff</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="DoubleTab_8h_source.html#l00243">DoubleTab::dimension()</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VEF_8h_source.html#l00145">Zone_VEF::face_normales()</a>, <a class="el" href="Zone__VF_8h_source.html#l00609">Zone_VF::face_sommets()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="DoubleTab_8h_source.html#l00264">DoubleTab::nb_dim()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00538">Zone_VF::nb_som_face()</a>, <a class="el" href="IntVect_8h_source.html#l00139">IntVect::size()</a>, <a class="el" href="Zone__VEF__PreP1b_8h_source.html#l00052">Zone_VEF_PreP1b::volume_aux_sommets()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; face_normales=zone_VEF.<a class="code" href="classZone__VEF.html#a5742d75972e4846bf9fbb6ed5715053e">face_normales</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; volume_aux_sommets=zone_VEF.<a class="code" href="classZone__VEF__PreP1b.html#ac8282d378ae480144d75129df4a8c55c">volume_aux_sommets</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_sommets=zone_VEF.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>();

  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>=1./<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>;
  <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_som=coeff/(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+1);

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_face=zone_VEF.<a class="code" href="classZone__VF.html#a990808f967f351edbb83ff11d60b7445" title="renvoie le nombre de sommets par face. Rque : on a suppose que toutes les faces avait le meme nombre ...">nb_som_face</a>();

  <span class="keywordtype">int</span> face_opp=0,compj=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;
  <span class="keywordtype">int</span> loc=0;
  <span class="keywordtype">int</span> elem=0;

  <span class="keywordtype">double</span> signe=0.;
  <span class="keywordtype">double</span> volume=0.;

  assert(som_glob.<a class="code" href="classIntVect.html#ad90cfd411cbbd631ccf1935bb36f7c40" title="Identique a size_reelle()">size</a>()==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);
  assert(grad.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>()==2);
  assert(grad.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1)==<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// </span>
<span class="comment">// Calcul du gradient</span>
<span class="comment">// </span>

  nnz=0;
  <span class="comment">/* On regarde le premier element voisin */</span>
  elem=face_voisins(face,0);
  assert(elem!=-1);

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
    {
      som=elem_som(elem,som_loc);
      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

      face_opp=elem_faces(elem,som_loc);
      signe=1.;
      <span class="keywordflow">if</span>(elem!=face_voisins(face_opp,0)) signe=-1.;

<span class="comment">// ajout a la liste et incrementation du repere</span>
      som_glob(som_loc)=som;
      nnz++;

<span class="comment">// Calcul du gradient local</span>
      <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj,som_loc)=coeff_som*signe*
                            face_normales(face_opp,compj);
    }
  assert(nnz==nb_som_elem);

  <span class="comment">/* On regarde le deuxieme element voisin */</span>
  assert(face_voisins(face,1)==-1);

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_face; som_loc++) <span class="comment">//sommets de &quot;face&quot;</span>
    {
      som=face_sommets(face,som_loc);
      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

      <span class="keywordflow">for</span> (loc=0; loc&lt;nnz; loc++)
        <span class="keywordflow">if</span> (som_glob(loc)==som)
          <span class="keywordflow">break</span>;
      assert(som_loc&lt;nnz);

      <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj,loc)+=coeff*face_normales(face,compj) ;
    }
  assert(nnz&lt;=(dimension+2));

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nnz; som_loc++)
    {
      som=som_glob(som_loc);
      volume=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>*volume_aux_sommets(som);

<span class="comment">// On divise par la matrice de masse lumpee</span>
      <span class="keywordflow">for</span>(compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
        grad(compj,som_loc)/=volume;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6484f8248047d53c2ab60be7ab09c892"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::info" ref="a6484f8248047d53c2ab60be7ab09c892" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> * Op_Diff_VEFP1NCP1B_Face::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Donne des informations sur le type de l'Objet_U. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>const Type_info*<br/>
 Signification: structure regroupant les informations sur le type de l'Objet_U<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a7daa89aeb6a754ff29b17060bfa79aa5">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#a09ed3b6346642466aba90e0fcaa1371f">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a0939691aa4e08464a51cb16c33a62d51"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::initialiser" ref="a0939691aa4e08464a51cb16c33a62d51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::initialiser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">1100</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Zone__VF_8cpp_source.html#l00628">Zone_VF::creer_tableau_aretes()</a>, <a class="el" href="Zone_8cpp_source.html#l01600">Zone::creer_tableau_elements()</a>, <a class="el" href="Domaine_8cpp_source.html#l00435">Domaine::creer_tableau_sommets()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Operateur__base_8h_source.html#l00168">Operateur_base::flux_bords_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00137">gradient_p0_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">gradient_p1_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00139">gradient_pa_</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="Zone__VF_8h_source.html#l00547">Zone_VF::nb_faces_bord()</a>, <a class="el" href="DoubleTab_8cpp_source.html#l00335">DoubleTab::resize()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00229">completer()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; unknown = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> size = unknown.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();

<span class="comment">// Definition des gradients</span>
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, size, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
  zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a600fa15a19c7e1384564dffd83ecab4d" title="creation d&#39;un tableau parallele de valeurs aux elements. Voir MD_Vector_tools::creer_tableau_distribu...">creer_tableau_elements</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">gradient_p0_</a>);

  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, size, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
  zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>);

  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>)
    {
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(0, size, <a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>);
      zone_VEF.<a class="code" href="classZone__VF.html#ae77f9ddf0711c0bcf2162921698d0bea">creer_tableau_aretes</a>(<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">gradient_pa_</a>);
    }

<span class="comment">// Initialisation de l&#39;attribut dim_ch_</span>
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>=size;

<span class="comment">// Dimensionnemt du tableau flux_bords</span>
  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>.<a class="code" href="classDoubleTab.html#ae83b4d31205c53d9c8d2b43da178ce75" title="Change la taille du vecteur (identique a resize_array() pour le traitement des anciennes valeurs et d...">resize</a>(zone_VEF.<a class="code" href="classZone__VF.html#a8815e2276637c0db23868f043dc43e58" title="renvoie le nombre de faces sur lesquelles sont appliquees les conditions limites : bords...">nb_faces_bord</a>(),size);
  <a class="code" href="classOperateur__base.html#a451f51b41518ddbc0d3f586a8177d319" title="Tableau contenant les flux sur les bords de l&#39;operateur.">flux_bords_</a>=0.;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0e34a4eb1127c6810d661018f42e840c"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::isFaceOfSymetry" ref="a0e34a4eb1127c6810d661018f42e840c" args="(ArrOfBit &amp;, int &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::isFaceOfSymetry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArrOfBit.html">ArrOfBit</a> &amp;&#160;</td>
          <td class="paramname"><em>is_symetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03159">3159</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="ArrOfBit_8h_source.html#l00064">ArrOfBit::setbit()</a>, <a class="el" href="ArrOfBit_8h_source.html#l00094">ArrOfBit::size_array()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF=<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();

  <span class="keywordtype">int</span> n_bord=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> ind_face=0;

  assert(is_symetry.<a class="code" href="classArrOfBit.html#a3dc47c19e757ec4c3c757abeec29dc3a" title="Renvoie la taille du tableau en bits.">size_array</a>()==zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>());

<span class="comment">// Preinitialisation</span>
  nnz=0;
  is_symetry=0;

<span class="comment">// Modification pour les faces de symetrie</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classSymetrie.html" title="classe Symetrie Sur les faces de symetrie on a les proprietes suivantes: - composante normale de la v...">Symetrie</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          nnz+=num2;

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            is_symetry.<a class="code" href="classArrOfBit.html#a5c339cfd9dea141737e127131e52aaae" title="Met le bit e a 1.">setbit</a>(le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face));
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a035d8cdf71b99212df20fadc0f2c997e"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::isInStencil" ref="a035d8cdf71b99212df20fadc0f2c997e" args="(int, int, int &amp;, int &amp;, int &amp;, int &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::isInStencil </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>som_glob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elem0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>som_loc0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>som_loc1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">2944</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();

  <span class="keywordtype">int</span> elem00=0,elem11=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;

  elem00=face_voisins(face,0);
  assert(elem00!=-1);

  <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
    {
      som=elem_som(elem00,som_loc);
      som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

      <span class="keywordflow">if</span> (som_glob==som)
        {
          som_loc0=som_loc;
          elem0=elem00;
          <span class="keywordflow">break</span>;
        }
    }
  <span class="keywordflow">if</span> (som_loc==nb_som_elem)
    {
      elem0=-1;
      som_loc0=-1;
    }

  elem11=face_voisins(face,1);
  <span class="keywordflow">if</span> (elem11==-1)
    {
      elem1=-1;
      som_loc1=-1;
    }
  <span class="keywordflow">else</span>
    <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
      {
        som=elem_som(elem11,som_loc);
        som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

        <span class="keywordflow">if</span> (som_glob==som)
          {
            som_loc1=som_loc;
            elem1=elem11;
            <span class="keywordflow">break</span>;
          }
      }
  <span class="keywordflow">if</span> (som_loc==nb_som_elem)
    {
      elem1=-1;
      som_loc1=-1;
    }

<span class="comment">// On ordonne</span>
  <span class="keywordflow">if</span> (elem0==-1 &amp;&amp; elem1!=-1)
    {
      elem0=elem1;
      elem1=-1;
      som_loc0=som_loc1;
      som_loc1=-1;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae2379b34f16ef970c39d7c515f51547c"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::liste_face" ref="ae2379b34f16ef970c39d7c515f51547c" args="(IntLists &amp;, int &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::liste_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIntLists.html">IntLists</a> &amp;&#160;</td>
          <td class="paramname"><em>liste</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02323">2323</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="IntLists_8cpp_source.html#l00286">IntLists::dimensionner()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="Zone__VF_8h_source.html#l00574">Zone_VF::elem_faces()</a>, <a class="el" href="Zone__VF_8h_source.html#l00773">Zone_VF::est_une_face_virt_bord()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00144">Zone_dis_base::nb_elem_tot()</a>, <a class="el" href="Zone_8h_source.html#l00469">Zone::nb_faces_elem()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__VF_8h_source.html#l00527">Zone_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Domaine_8cpp_source.html#l00177">Domaine::nb_som_tot()</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="ArrOfBit_8h_source.html#l00064">ArrOfBit::setbit()</a>, <a class="el" href="IntLists_8h_source.html#l00069">IntLists::size()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF = <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();


  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; som_elem=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_faces=zone_VEF.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> firstFaceInt=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_tot=dom.<a class="code" href="classDomaine.html#a394e61cf1993665886de0fbbd0c0178e" title="Renvoie le nombre total de sommets.">nb_som_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone_VEF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_tot=zone_VEF.<a class="code" href="classZone__VF.html#a50fd21c9535680489015a3c8b88c685a" title="renvoie le nombre total de faces. C&#39;est-a-dire faces reelles + faces virtuelles">nb_faces_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_faces_elem=zone.<a class="code" href="classZone.html#a548fbc7518be2f122b1a5c9589a443c2" title="Renvoie le nombre de face de type i des elements geometriques constituants la zone. Ex: les objets de la classe Prisme ont 2 types de faces: triangle ou quadrangle.">nb_faces_elem</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();

  <span class="keywordtype">int</span> face=0,face2=0;
  <span class="keywordtype">int</span> face_loc=0;
  <span class="keywordtype">int</span> elem=0,elem_loc=0;
  <span class="keywordtype">int</span> som=0,som_loc=0;
  <span class="keywordtype">int</span> i=0,size=0;
  <span class="keywordtype">int</span> n_bord=0,ind_face=0;
  <span class="keywordtype">int</span> num1=0,num2=0;
  <span class="keywordtype">int</span> tmp=0;

  <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a> faces_perio(nb_faces_tot);
  <a class="code" href="classArrOfBit.html">ArrOfBit</a> fait(nb_faces_tot);
  <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a> sommets_faces(nb_som_tot);

<span class="comment">// Il faut creer un second tableau travaillant sur les faces periodiques</span>
<span class="comment">// sinon la matrice pourrait ne pas etre homogene a l&#39;operateur explicite</span>
  <span class="keywordflow">for</span> (face=0; face&lt;nb_faces_tot; face++)
    faces_perio(face)=face;

  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keywordtype">int</span> faceAss=0;

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              faceAss=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
              faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(faceAss);

<span class="comment">// Test afin de ne parcourir que la moitie des faces periodiques</span>
<span class="comment">// sachant que l&#39;algorithme qui suit tient compte de ce choix</span>
<span class="comment">// REMARQUE : ce test marche aussi en parallele ou les faces</span>
<span class="comment">// virtuelles ne sont pas classees</span>
              <span class="keywordflow">if</span> (face&lt;faceAss)
                {
                  faces_perio(face)=faceAss;
                  faces_perio(faceAss)=face;
                }
            }
        }
    }

<span class="comment">// Connectivite liee aux sommets</span>
  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
      {
        som=som_elem(elem,som_loc);
        som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

        <span class="keywordflow">for</span> (face_loc=0; face_loc&lt;nb_faces_elem; face_loc++)
          {
            face=elem_faces(elem,face_loc);

            sommets_faces[som].add(face);
            <span class="keywordflow">if</span> (faces_perio(face)!=face)
              sommets_faces[som].add(faces_perio(face));
          }
      }

  nnz=0;
  liste.<a class="code" href="classIntLists.html#afa2bb253d9d4764110ca8cc4b93649ed" title="Redimensionne un tableau de listes.">dimensionner</a>(nb_faces_tot);
<span class="comment">// REMARQUE IMPORTANTE : IL FAUT ABSOLUMENT COMMENCER</span>
<span class="comment">// PAR REMPLIR LES FACES PERIODIQUES SINON :</span>
<span class="comment">// -LA MATRICE NE POURRA PAS ETRE PERIODIQUE</span>
<span class="comment">// -ET DES COEFFICIENTS POURRAIENT ETRE OUBLIES</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());
          <span class="keywordtype">int</span> faceAss=0;

          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              faceAss=la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face);
              faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(faceAss);

<span class="comment">// Test afin de ne parcourir que la moitie des faces periodiques</span>
<span class="comment">// sachant que l&#39;algorithme qui suit tient compte de ce choix</span>
<span class="comment">// REMARQUE : ce test marche aussi en parallele ou les faces</span>
<span class="comment">// virtuelles ne sont pas classees</span>
              <span class="keywordflow">if</span> (face&lt;faceAss)
                {
<span class="comment">// RAZ du tableau fait</span>
                  fait=0;

<span class="comment">// pour la periodicite</span>
                  size=liste[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
                  <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
                    fait.setbit(liste[face][i]);

<span class="comment">// Pour que le premier element de la liste soit &quot;face&quot;</span>
<span class="comment">// Tient compte de la periodicite</span>
                  <span class="keywordflow">if</span> (size!=0)
                    {
                      tmp=liste[face][0];
                      liste[face][0]=face;
                      liste[face].add(tmp);
                      tmp=liste[faceAss][0];
                      liste[faceAss][0]=faceAss;
                      liste[faceAss].add(tmp);
                    }
                  <span class="keywordflow">else</span>
                    {
                      liste[face].add(face);
                      liste[faceAss].add(faceAss);
                    }

                  fait.setbit(face);
                  fait.setbit(faceAss);
                  nnz+=2;<span class="comment">//car on ajoute 2 coefficients</span>

                  <span class="keywordflow">for</span> (elem_loc=0; elem_loc&lt;2; elem_loc++)
                    {
                      elem=face_voisins(face,elem_loc);
                      assert(elem!=-1);

                      <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
                        {
                          som=som_elem(elem,som_loc);
                          som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

                          size=sommets_faces[som].size();
                          <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
                            {
                              face2=sommets_faces[som][i];

                              <span class="keywordflow">if</span> (!fait[face2])
                                {
                                  fait.setbit(face2);
                                  liste[face].add(face2);
                                  liste[faceAss].add(face2);
                                  liste[face2].add(face);
                                  liste[face2].add(faceAss);
                                  nnz+=4;<span class="comment">//car on ajoute 4 coefficients</span>
                                }

                            }<span class="comment">//fin du for sur &quot;i&quot;</span>
                        }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
                    }<span class="comment">//fin du for sur &quot;elem_loc&quot;</span>
                }<span class="comment">//fin du if sur &quot;face&lt;faceAss&quot;</span>
            }<span class="comment">//fin du for sur &quot;ind_face&quot;</span>
        }<span class="comment">//fin Periodique</span>
    }<span class="comment">//fin n_bord</span>

<span class="comment">// Autres conditions aux limites</span>
  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

      <span class="keywordflow">if</span> (!<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

<span class="comment">// RAZ du tableau fait</span>
            fait=0;

<span class="comment">// pour la periodicite</span>
            size=liste[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
            <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
              fait.setbit(liste[face][i]);

<span class="comment">// Pour que le premier element de la liste soit &quot;face&quot;</span>
<span class="comment">// Tient compte de la periodicite</span>
            <span class="keywordflow">if</span> (size!=0)
              {
                tmp=liste[face][0];
                liste[face][0]=face;
                liste[face].add(tmp);
              }
            <span class="keywordflow">else</span>
              liste[face].add(face);

            fait.setbit(face);
            nnz++;

            elem=face_voisins(face,0);
            assert(elem!=-1);

            <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
              {
                som=som_elem(elem,som_loc);
                som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

                size=sommets_faces[som].size();
                <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
                  {
                    face2=sommets_faces[som][i];

                    <span class="keywordflow">if</span> (!fait[face2])
                      {
                        fait.setbit(face2);
                        liste[face].add(face2);
                        nnz++;
                      }

                  }<span class="comment">//fin du for sur &quot;i&quot;</span>
              }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
          }<span class="comment">//fin du else sur !Periodique</span>
    }<span class="comment">//fin du for sur n_bord</span>

  <span class="keywordflow">for</span> (face=firstFaceInt; face&lt;nb_faces_tot; face++)
    <span class="keywordflow">if</span> (!zone_VEF.<a class="code" href="classZone__VF.html#a33909d3880435e82e84639b51482d2c6" title="renvoie 1 si face est une face virtuelle de bord, 0 sinon">est_une_face_virt_bord</a>(face))
      {
<span class="comment">// RAZ du tableau fait</span>
        fait=0;

<span class="comment">// pour la periodicite</span>
        size=liste[face].<a class="code" href="classIntLists.html#a823946693bc491321765f0e6805204e2" title="retourne le nombre de listes dans le tableau">size</a>();
        <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
          fait.setbit(liste[face][i]);

<span class="comment">// Pour que le premier element de la liste soit &quot;face&quot;</span>
<span class="comment">// Tient compte de la periodicite</span>
        <span class="keywordflow">if</span> (size!=0)
          {
            tmp=liste[face][0];
            liste[face][0]=face;
            liste[face].add(tmp);
          }
        <span class="keywordflow">else</span>
          liste[face].add(face);

        fait.setbit(face);
        nnz++;

        <span class="keywordflow">for</span> (elem_loc=0; elem_loc&lt;2; elem_loc++)
          {
            elem=face_voisins(face,elem_loc);

            <span class="keywordflow">if</span> (elem!=-1) <span class="comment">//pour face interne de joint</span>
              <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
                {
                  som=som_elem(elem,som_loc);
                  som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);

                  size=sommets_faces[som].size();
                  <span class="keywordflow">for</span> (i=0; i&lt;size; i++)
                    {
                      face2=sommets_faces[som][i];

                      <span class="keywordflow">if</span> (!fait[face2])
                        {
                          fait.setbit(face2);
                          liste[face].add(face2);
                          nnz++;
                        }

                    }<span class="comment">//fin du for sur &quot;i&quot;</span>
                }<span class="comment">//fin du for sur &quot;som_loc&quot;</span>
          }<span class="comment">//fin du for sur &quot;elem_loc&quot;</span>
      }<span class="comment">//fin du for sur &quot;face&quot;</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a40338f037cc176acacb1a23eab51e65e"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::printOn" ref="a40338f037cc176acacb1a23eab51e65e" args="(Sortie &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSortie.html">Sortie</a> &amp; Op_Diff_VEFP1NCP1B_Face::printOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSortie.html">Sortie</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
A surcharger dans les classes derivees. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classSortie.html" title="Classe de base des flux de sortie. Elle sait ecrire des types simples&lt;br&gt;(entiers, flottants) et des Ob...">Sortie</a>&amp;<br/>
 Signification: le flot de sortie<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#adf60530aec0f57319212a7f888407910">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#a15c24cace80bbda7a389f243eab73183">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00082">82</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Objet__U_8cpp_source.html#l00132">Objet_U::que_suis_je()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> s &lt;&lt; <a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>() ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16d0bd30f8c55391616349f7fc3c1f1a"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::readOn" ref="a16d0bd30f8c55391616349f7fc3c1f1a" args="(Entree &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEntree.html">Entree</a> &amp; Op_Diff_VEFP1NCP1B_Face::readOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEntree.html">Entree</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>NE FAIT RIEN<br/>
A surcharger dans les classes derivees. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classEntree.html" title="Classe de definition des operateurs et methodes pour toute lecture dans un flot d&#39;entree (fichier...">Entree</a>&amp;<br/>
 Signification: le flot d'entree<br/>
 Contraintes: </dd></dl>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#aac420bbe9ffadd07b51803a9431dd1dd">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#ab8d640dc64abedf5955792366165538f">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">90</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">alphaA</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">coeff_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">convexite_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">decentrage_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Motcle_8cpp_source.html#l00538">Motcles::search()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00134">test_</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">// Les mots a reconnaitre</span>
  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> motlu, accouverte = <span class="stringliteral">&quot;{&quot;</span> , accfermee = <span class="stringliteral">&quot;}&quot;</span> ;
  <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots(6);
  {
    les_mots[0] = <span class="stringliteral">&quot;alphaE&quot;</span>;
    les_mots[1] = <span class="stringliteral">&quot;alphaS&quot;</span>;
    les_mots[2] = <span class="stringliteral">&quot;alphaA&quot;</span>;
    les_mots[3] = <span class="stringliteral">&quot;test&quot;</span>;
    les_mots[4] = <span class="stringliteral">&quot;decentrage&quot;</span>;
    les_mots[5] = <span class="stringliteral">&quot;epsilon&quot;</span>;
  }

<span class="comment">// Verification de la syntaxe</span>
  s &gt;&gt; motlu;
  <span class="keywordflow">if</span> (motlu!=accouverte)
    <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
      {
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Diff_VEFP1NCP1B_Face::readOn()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Depuis la 1.5.5, la syntaxe du mot cle P1NCP1B a change.&quot;</span>
             &lt;&lt; finl;
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Il faut commencer par une accolade ouvrante {&quot;</span> &lt;&lt; finl;
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;et les options eventuelles sont entre les accolades :&quot;</span>
             &lt;&lt; finl;
        <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Diffusion { P1NCP1B } -&gt; Diffusion { P1NCB { } }&quot;</span> &lt;&lt; finl;
        <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
      }


<span class="comment">// Lecture des parametres</span>
  s &gt;&gt; motlu;
  <span class="keywordflow">while</span>(motlu!=accfermee)
    {
      <span class="keywordtype">int</span> rang = les_mots.search(motlu);

      <span class="keywordflow">switch</span>(rang)
        {
        <span class="keywordflow">case</span> 0 :

          s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>;
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> 1 :

          s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>;
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> 2 :

          <span class="keywordflow">if</span> (<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">Objet_U::dimension</a>==3)
            s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">alphaA</a>;
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Diff_VEFP1NCP1B_Face::readOn()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;L&#39;option alphaA ne peut etre activee qu&#39;en &quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;dimension 3&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme&quot;</span> &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> 3 :

          <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">test_</a>=1;
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> 4 :

          s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">decentrage_</a>;
          <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> 5 :

          s &gt;&gt; <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">convexite_</a>;
          <span class="keywordflow">break</span>;

        <span class="keywordflow">default</span> :

          <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>())
            {
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Erreur Op_Diff_VEFP1NCP1B_Face::readOn()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Mot clef &quot;</span> &lt;&lt; motlu &lt;&lt; <span class="stringliteral">&quot; non reconnu&quot;</span> &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Les mots clef reconnus sont : &quot;</span> &lt;&lt; les_mots &lt;&lt; finl;
              <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Sortie du programme&quot;</span> &lt;&lt; finl;
              <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
            }
          <span class="keywordflow">break</span>;
        }<span class="comment">//fin du switch</span>

<span class="comment">// Suite de la lecture</span>
      s &gt;&gt; motlu;
    }<span class="comment">//fin du while</span>

  <span class="keywordflow">if</span> (alphaE &amp;&amp; !alphaS) convexite_=1.;
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alphaS &amp;&amp; !alphaE) convexite_=0.;

  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">coeff_</a>=1.;<span class="comment">//alphaE+alphaS;</span>

  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a997bacd7fe35872ff44036e9e9f40996"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::remplir_nu_p1" ref="a997bacd7fe35872ff44036e9e9f40996" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::remplir_nu_p1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calcule la diffusivite "nu_p1" aux sommets du maillage<br/>
en fonction de la diffusivite "nu_elem" aux elements.<br/>
On suppose que nu_elem a son espace virtuel a jour,<br/>
que nu_p1 est dimensionne nb_dim==1 avec la structure domaine.md_vector_sommets()<br/>
En sortie l'espace virtuel de nu_p1 est mis a jour<br/>
L'interpolateur calculs pour un sommet la moyenne (non ponderee) des<br/>
diffusivites sur les elements adjacents a ce sommet. </p>

<p><p>&lt; Intialise a zero par defaut </p>
</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02229">2229</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Check__espace__virtuel_8cpp_source.html#l00118">assert_espace_virtuel_vect()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Zone_8cpp_source.html#l01607">Zone::md_vector_elements()</a>, <a class="el" href="Domaine_8cpp_source.html#l00441">Domaine::md_vector_sommets()</a>, <a class="el" href="Zone_8h_source.html#l00319">Zone::nb_elem_tot()</a>, <a class="el" href="Domaine_8cpp_source.html#l00184">Domaine::nb_som()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone=zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som = dom.<a class="code" href="classDomaine.html#abc4abc8b8db5bebeb161fae4162a89ce" title="Renvoie le nombre de sommets.">nb_som</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elem_tot=zone.<a class="code" href="classZone.html#aa3a33e8b723618b9092460007153e42d" title="Renvoie le nombre total d&#39;elements de la zone.">nb_elem_tot</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();

  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> som_loc=0,som=0;

  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();

  <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a> nb_elem_per_som(nb_som); <span class="comment">//!&lt; Intialise a zero par defaut</span>
<span class="comment"></span>
  assert(nu_elem.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == zone.<a class="code" href="classZone.html#ab4c6e0d58001c0cc98d4f06e98086544" title="renvoie le descripteur parallele des tableaux aux elements de la zone">md_vector_elements</a>());
  assert(nu_p1.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == dom.<a class="code" href="classDomaine.html#a94843a61bbc3e432cf87ef40c440fb80">md_vector_sommets</a>());
<span class="comment">// On a besoin que l&#39;espace virtuel de nu_elem soit a jour.</span>
  <a class="code" href="Check__espace__virtuel_8cpp.html#a2ea8fcf12c28d0454bdc4126f8c4b186" title="en mode comm_check_enabled(), verifie si l&#39;espace virtuel du vecteur est a jour, si ce n&#39;est pas le c...">assert_espace_virtuel_vect</a>(nu_elem);

<span class="comment">// Calcul effectif de &quot;nu_som&quot;</span>

  nu_p1=0.;

  <span class="keywordflow">for</span> (elem=0; elem&lt;nb_elem_tot; elem++)
    {
      <span class="keyword">const</span> <span class="keywordtype">double</span> nu = nu_elem[elem];
      <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
        {
          som=elem_som(elem,som_loc);
<span class="comment">// Ne pas calculer les valeurs pour les sommets virtuels</span>
<span class="comment">// note BM: l&#39;algo precedent ne calculait pas correctement les valeurs non plus</span>
          <span class="keywordflow">if</span> (som &lt; nb_som)
            {
              som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
              nu_p1(som) += nu;
              nb_elem_per_som(som)++;
            }
        }
    }

  <span class="keywordflow">for</span> (som = 0; som &lt; nb_som; som++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> som_perio = dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
      <span class="keywordtype">int</span> nvoisins = nb_elem_per_som[som_perio];
      <span class="keywordflow">if</span> (nvoisins &gt; 0)
        {
<span class="comment">// La premiere fois qu&#39;on tombe sur ce sommet on fait la division.</span>
<span class="comment">// On traite du meme coup le cas ou le sommet n&#39;a pas d&#39;elements voisins.</span>
          nu_p1(som_perio) /= nvoisins;
          nb_elem_per_som[som_perio] = 0;
        }
      <span class="keywordflow">if</span> (som != som_perio)
        nu_p1(som) = nu_p1(som_perio);
    }
<span class="comment">// Le codage precedent n&#39;avait apparemment pas besoin d&#39;echange espace virtuel.</span>
<span class="comment">// A mon avis (BM) c&#39;est un miracle du au fait qu&#39;on fait les calculs avec epaisseur2</span>
<span class="comment">// (calcul sur nb_som_tot, donc les sommets des elements d&#39;epaisseur 1 sont ok mais</span>
<span class="comment">// pas ceux d&#39;epaisseur 2)</span>
<span class="comment">// Je prefere ce codage: (si on enleve, ca fait des ecarts en parallele)</span>
  nu_p1.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3b64900128cbb94e4b8980e5ac10b49d"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::remplir_nu_pA" ref="a3b64900128cbb94e4b8980e5ac10b49d" args="(const DoubleTab &amp;, DoubleTab &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::remplir_nu_pA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleTab.html">DoubleTab</a> &amp;&#160;</td>
          <td class="paramname"><em>nu_pA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02310">2310</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, and <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Op_Diff_VEFP1NCP1B_Face::remplir_nu_pA() not coded&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
  <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Exit&quot;</span> &lt;&lt; finl;
  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="afb8b825e9fab55e68bafcb4016a8abe7"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::self_cast" ref="afb8b825e9fab55e68bafcb4016a8abe7" args="(const Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html">Op_Diff_VEFP1NCP1B_Face</a> &amp; Op_Diff_VEFP1NCP1B_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>methode ajoutee pour caster en python </p>

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a9a42b56881e49f22d01df805616b86c1">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#ad61478bb3435db203464bed014b7df57">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a5ab35137c633662d0a2ba13e40869a22"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::self_cast" ref="a5ab35137c633662d0a2ba13e40869a22" args="(Objet_U &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html">Op_Diff_VEFP1NCP1B_Face</a> &amp; Op_Diff_VEFP1NCP1B_Face::self_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjet__U.html">Objet_U</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a6f47e475b04a3a6e49c702256eadd605">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#ad688a3038e3ea368f3a069679973c3c5">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="aa1240a59d726eae3194711dadb4e5e08"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::taille_memoire" ref="aa1240a59d726eae3194711dadb4e5e08" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Op_Diff_VEFP1NCP1B_Face::taille_memoire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#abd1eb6819c0e4d597e601624158b68a9">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#a83fa6f97c1a6f39fc90fcefd45ba9852">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00051">51</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
</pre></div>
</div>
</div>
<a class="anchor" id="a4f8b23049afd6589ab4f1fa9619458f9"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::test" ref="a4f8b23049afd6589ab4f1fa9619458f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op_Diff_VEFP1NCP1B_Face::test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">3201</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a>.</p>

<p>References <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01346">ajouter_contribution_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01009">Matrice_Morse::ajouter_multTab_()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">alphaE</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">alphaS</a>, <a class="el" href="Solveur__Masse_8h_source.html#l00087">Solveur_Masse::appliquer()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00862">calculer_divergence_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">calculer_gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03912">corriger_Cl_test()</a>, <a class="el" href="Domaine_8cpp_source.html#l00435">Domaine::creer_tableau_sommets()</a>, <a class="el" href="Double_8h_source.html#l00255">dabs()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">dim_ch_</a>, <a class="el" href="Objet__U_8h_source.html#l00079">Objet_U::dimension</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>, <a class="el" href="Zone_8cpp_source.html#l00262">Zone::domaine()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00277">DoubleVect::echange_espace_virtuel()</a>, <a class="el" href="MorEqn_8h_source.html#l00082">MorEqn::equation()</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="Periodique_8h_source.html#l00056">Periodique::face_associee()</a>, <a class="el" href="Zone__VF_8h_source.html#l00458">Zone_VF::face_voisins()</a>, <a class="el" href="Cond__lim_8h_source.html#l00130">Cond_lim::frontiere_dis()</a>, <a class="el" href="Domaine_8h_source.html#l00613">Domaine::get_renum_som_perio()</a>, <a class="el" href="Nom_8h_source.html#l00088">Nom::getChar()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">gradient_p1_</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02842">gradient_som_CL()</a>, <a class="el" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">Equation_base::inconnue()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">isInStencil()</a>, <a class="el" href="Process_8cpp_source.html#l00095">Process::je_suis_maitre()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Zone__Cl__dis__base_8cpp_source.html#l00522">Zone_Cl_dis_base::les_conditions_limites()</a>, <a class="el" href="Zone_8h_source.html#l00402">Zone::les_elems()</a>, <a class="el" href="Domaine_8h_source.html#l00577">Domaine::les_sommets()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02217">DoubleVect::local_max_abs_vect()</a>, <a class="el" href="Double_8h_source.html#l00180">max()</a>, <a class="el" href="Process_8cpp_source.html#l00117">Process::me()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00103">Matrice_Morse::nb_colonnes()</a>, <a class="el" href="Zone__VF_8h_source.html#l00519">Zone_VF::nb_faces()</a>, <a class="el" href="Front__VF_8h_source.html#l00066">Front_VF::nb_faces_tot()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00156">Zone_dis_base::nb_front_Cl()</a>, <a class="el" href="Matrice__Morse_8h_source.html#l00099">Matrice_Morse::nb_lignes()</a>, <a class="el" href="Zone_8h_source.html#l00445">Zone::nb_som_elem()</a>, <a class="el" href="Domaine_8cpp_source.html#l00177">Domaine::nb_som_tot()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00083">Op_Diff_VEF_base::nu_</a>, <a class="el" href="Front__VF_8h_source.html#l00076">Front_VF::num_face()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00060">Op_Diff_VEF_base::phi_psi_diffuse()</a>, <a class="el" href="Zone__VF_8h_source.html#l00315">Zone_VF::porosite_elem()</a>, <a class="el" href="Zone__VF_8h_source.html#l00285">Zone_VF::porosite_face()</a>, <a class="el" href="Zone__VF_8h_source.html#l00512">Zone_VF::premiere_face_int()</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00268">Op_Diff_VEF_base::remplir_nu()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02229">remplir_nu_p1()</a>, <a class="el" href="vect__impl_8h_source.html#l00057">vect_impl::size()</a>, <a class="el" href="Equation__base_8h_source.html#l00432">Equation_base::solv_masse()</a>, <a class="el" href="Cast_8h_source.html#l00054">sub_type</a>, <a class="el" href="Cond__lim_8h_source.html#l00031">Deriv_Cond_lim_base::valeur()</a>, <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>, <a class="el" href="Champ__Inc_8cpp_source.html#l00245">Champ_Inc::valeurs()</a>, <a class="el" href="Zone__VF_8h_source.html#l00650">Zone_VF::xv()</a>, <a class="el" href="Zone__dis__base_8h_source.html#l00106">Zone_dis_base::zone()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">zone_VEFPreP1B()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>&amp; zone_VEF=<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a8d6cebdde81108b4c492d8af3d6d60ae">zone_VEFPreP1B</a>();
  <span class="keyword">const</span> <a class="code" href="classZone__Cl__VEF.html">Zone_Cl_VEF</a>&amp; zone_Cl_VEF = <a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>();
  <span class="keyword">const</span> <a class="code" href="classZone.html" title="classe Zone Une Zone est un maillage compose d&#39;un ensemble d&#39;elements geometriques de meme type...">Zone</a>&amp; zone = zone_VEF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>();
  <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom=zone.<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();

  <span class="keyword">const</span> <a class="code" href="classSolveur__Masse.html" title="classe Solveur_Masse Classe generique de la hierarchie des solveurs de masse, un objet Solveur_Masse ...">Solveur_Masse</a>&amp; solveur_masse=<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#adfedf474c07a92f6b2261ca2f1cee80e" title="Renvoie le solveur de masse associe a l&#39;equation.">solv_masse</a>();

  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_bords=zone_VEF.<a class="code" href="classZone__dis__base.html#af22167d614644f55591a29c77eb1c009">nb_front_Cl</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> firstFaceInt=zone_VEF.<a class="code" href="classZone__VF.html#a12869806fa4834aca8f2964e16509dfd" title="une face est interne ssi elle separe deux elements. renvoie le numero de la premiere face interne...">premiere_face_int</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_tot=dom.<a class="code" href="classDomaine.html#a394e61cf1993665886de0fbbd0c0178e" title="Renvoie le nombre total de sommets.">nb_som_tot</a>();

  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; unknown = <a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>().<a class="code" href="classEquation__base.html#a5a1fce9487b9a8dd17020914100c2c89">inconnue</a>().<a class="code" href="classChamp__Inc.html#a28ef3d411d12cb5684ac5e799efb7d24" title="Appel a l&#39;objet sous-jacent Renvoie le tableau des valeurs au temps courant.">valeurs</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xv=zone_VEF.<a class="code" href="classZone__VF.html#a918c0885a9b67317fcce3a0535306542">xv</a>();
  <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; xs=dom.<a class="code" href="classDomaine.html#a0846ac03a10b65c4df911fe35a19c02f" title="Renvoie le nombre total de sommets.">les_sommets</a>();

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> inco(unknown);
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; incoV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,inco);
  incoV=0.;
<span class="comment">// DoubleTab inco2(unknown);</span>
<span class="comment">// DoubleVect&amp; inco2V=ref_cast(DoubleVect,inco2);</span>
<span class="comment">// inco2V=0.;</span>

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> tmp(inco);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resu(unknown);
  <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resu);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> resuMat(unknown);
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; resuMatV=<a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classDoubleVect.html">DoubleVect</a>,resuMat);
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradientMat(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>,<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);


  <a class="code" href="classIntVect.html">IntVect</a> som_glob(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>+2);

<span class="comment">// Marqueur pour tenir compte de la porosite</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> marq=<a class="code" href="classOp__Diff__VEF__base.html#ae7df69707cc2304c930eb103390e99f0">phi_psi_diffuse</a>(<a class="code" href="classMorEqn.html#a615dd9abff96edcb625fa0424a489864" title="Renvoie la reference sur l&#39;equation pointe par MorEqn::mon_equation. (version const)">equation</a>());

<span class="comment">// Lignes pour tenir compte de la porosite</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; poroE=zone_VEF.<a class="code" href="classZone__VF.html#afd135a1b227731193b1a97b7ed525435">porosite_elem</a>();
  <a class="code" href="classDoubleVect.html">DoubleVect</a> poroF(zone_VEF.<a class="code" href="classZone__VF.html#ad9d74d1d9da9f50ab26768dbbca7711b">porosite_face</a>());
  <span class="keywordflow">if</span> (!marq) poroF=1.;

<span class="comment">// Lignes pour tenir compte de la diffusivite</span>
  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu;
  <a class="code" href="classOp__Diff__VEF__base.html#aaf04f2c605558b7b05aa8c60f84fb9e1">remplir_nu</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>);
  <a class="code" href="Porosites__champ_8cpp.html#a2340e7d73d0f9d34926d012fe1b1d884" title="renvoit le tableau res, res=org si flag=0, res= porosite*org sinon attention ne pas modifier res car ...">modif_par_porosite_si_flag</a>(<a class="code" href="classOp__Diff__VEF__base.html#ab1309af47a0c41f00181e031fbfda002">nu_</a>,nu,!marq,poroE);

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> nu_p1;
  dom.<a class="code" href="classDomaine.html#a32c7de9f9e8e78e3d5ea68715b2ceb2b" title="Cree un tableau ayant une &quot;ligne&quot; par sommet du maillage. Voir MD_Vector_tools::creer_tableau_distrib...">creer_tableau_sommets</a>(nu_p1);
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a997bacd7fe35872ff44036e9e9f40996" title="Calcule la diffusivite &quot;nu_p1&quot; aux sommets du maillage en fonction de la diffusivite &quot;nu_elem&quot; au...">remplir_nu_p1</a>(nu,nu_p1);

<span class="comment">// Diverses variables utiles</span>
  <span class="keywordtype">int</span> face=0;
  <span class="keywordtype">int</span> faceAss=0;
  <span class="keywordtype">int</span> comp=0;
  <span class="keywordtype">int</span> size0=zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>();
  <span class="keywordtype">int</span> i=0,j=0;
  <span class="keywordtype">int</span> nnz=0;
  <span class="keywordtype">int</span> compi=0,compj=0;
  <span class="keywordtype">int</span> som=0;
  <span class="keywordtype">int</span> n_bord=0;
  <span class="keywordtype">int</span> num1=0,num2=0,ind_face=0;
  <span class="keywordtype">int</span> ii=0;

  <span class="keywordtype">int</span> size1 = unknown.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();

  <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a> matrice;
  <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af8e127ec31241c8d2aab78ad951aa253" title="on dimensionne notre matrice.">dimensionner</a>(matrice);
  <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">alphaS</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#ae979dc98da8579c81ed4abf017475277">ajouter_contribution_som</a>(inco,poroF,nu_p1,matrice);
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">alphaE</a>) <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a10ecca846d2d639a93ea61ed25cc5458">ajouter_contribution_elem</a>(inco,poroF,nu,matrice);

  <span class="keywordtype">bool</span> test1=<span class="keyword">false</span>;
  <span class="keywordtype">double</span> <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>=0.;

  <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a> gradient1(<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>);

  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> type;
  <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()&gt;1)
    type=<span class="stringliteral">&quot;_PAR&quot;</span>;
  <span class="keywordflow">else</span>
    type=<span class="stringliteral">&quot;_SEQ&quot;</span>;

  <a class="code" href="classMotcles.html" title="Un tableau d&#39;objets de la classe Motcle.">Motcles</a> les_mots(8);
  {
    les_mots[0] = <span class="stringliteral">&quot;matrice&quot;</span>;
    les_mots[1] = <span class="stringliteral">&quot;result&quot;</span>;
    les_mots[2] = <span class="stringliteral">&quot;res&quot;</span>;
    les_mots[3] = <span class="stringliteral">&quot;resMat&quot;</span>;
    les_mots[4] = <span class="stringliteral">&quot;grad&quot;</span>;
    les_mots[5] = <span class="stringliteral">&quot;gradMat&quot;</span>;
    les_mots[6] = <span class="stringliteral">&quot;div&quot;</span>;
    les_mots[7] = <span class="stringliteral">&quot;ligne_mat&quot;</span>;
  }
  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> proc(<a class="code" href="classProcess.html#ab55ba07167ec807ed3a145cac0f5dca4" title="renvoie mon rang dans le groupe de communication courant. Voir Comm_Group::rank() et PE_Groups::curre...">Process::me</a>());
  proc+=<span class="stringliteral">&quot;.txt&quot;</span>;

  <span class="keywordflow">for</span> (i=0; i&lt;les_mots.size(); i++)
    {
      les_mots[i]+=type;
      les_mots[i]+=proc;
    }

  ofstream mat(les_mots[0].getChar());
  <span class="keyword">const</span> <a class="code" href="classMatrice__Morse.html" title="Classe Matrice_Morse Represente une matrice M (creuse), non necessairement carree stockee au format M...">Matrice_Morse</a>&amp; matConst=matrice;
  <span class="keywordflow">for</span> (i=0; i&lt;zone_VEF.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>(); i++)
    {
      <span class="keywordflow">for</span> (j=0; j&lt;matConst.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>(); j++)
        mat&lt;&lt;matConst(i,j)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      mat&lt;&lt;endl;
    }

  <span class="keywordtype">double</span> coeff_diag=0.;
  <span class="keywordtype">double</span> sum_coeff_extra_diag=0.;
  ofstream ligneMat(les_mots[7].getChar());
  <span class="keywordflow">for</span> (i=0; i&lt;matConst.<a class="code" href="classMatrice__Morse.html#a1f9bd6aedb226c86b7299689fa5b821a">nb_lignes</a>(); i++)
    {
      coeff_diag=matConst(i,i);
      ligneMat&lt;&lt;<span class="stringliteral">&quot;Ligne : &quot;</span>&lt;&lt;i&lt;&lt;endl;
      ligneMat&lt;&lt;<span class="stringliteral">&quot;Coeff diag : &quot;</span>&lt;&lt;coeff_diag&lt;&lt;endl;

      ligneMat&lt;&lt;<span class="stringliteral">&quot;Coeff extra diag : &quot;</span>;
      sum_coeff_extra_diag=0.;
      <span class="keywordflow">for</span> (j=0; j&lt;matConst.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>(); j++)
        <span class="keywordflow">if</span> (j!=i) sum_coeff_extra_diag+=matConst(i,j);
      ligneMat&lt;&lt;sum_coeff_extra_diag&lt;&lt;endl;

      ligneMat&lt;&lt;<span class="stringliteral">&quot;Coeff extra diag par colonne : &quot;</span>;
      sum_coeff_extra_diag=0.;
      <span class="keywordflow">for</span> (j=0; j&lt;matConst.<a class="code" href="classMatrice__Morse.html#a94caf9937bc5a110a7179cb3e9eaa9d9">nb_colonnes</a>(); j++)
        <span class="keywordflow">if</span> (j!=i) sum_coeff_extra_diag+=matConst(j,i);
      ligneMat&lt;&lt;sum_coeff_extra_diag&lt;&lt;endl;
    }


  <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> gradi(<span class="stringliteral">&quot;grad1&quot;</span>);
  gradi+=type;
  gradi+=proc;
  <span class="keywordtype">int</span> elem=0;
  <span class="keywordtype">int</span> elem0=0,elem1=0;
  <span class="keywordtype">int</span> som_loc0=1,som_loc1=1;
  <span class="keywordtype">int</span> som_loc=0;
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_som_elem=zone.<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; face_voisins=zone_VEF.<a class="code" href="classZone__VF.html#a49d4322f5585a8fa95748ca785b70702" title="renvoie l&#39;element voisin de numface dans la direction i. i=0 : dans le sens oppose de l&#39;axe orthogona...">face_voisins</a>();
  <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elem_som=zone.<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
  ofstream grad1(gradi.getChar());
  <span class="keywordflow">for</span> (face=0; face&lt;size0; face++)
    {
      grad1&lt;&lt;<span class="stringliteral">&quot;Face : &quot;</span>&lt;&lt;face&lt;&lt;endl;
      grad1&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        grad1&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      grad1&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;

      <span class="keywordflow">for</span> (ii=0; ii&lt;2; ii++)
        {
          elem=face_voisins(face,ii);
          <span class="keywordflow">if</span> (elem!=-1)
            <span class="keywordflow">for</span> (som_loc=0; som_loc&lt;nb_som_elem; som_loc++)
              {
                som=elem_som(elem,som_loc);
                som=dom.<a class="code" href="classDomaine.html#a37cc657f1907d53b0d5a573da862af80">get_renum_som_perio</a>(som);
                <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a035d8cdf71b99212df20fadc0f2c997e">isInStencil</a>(face,som,elem0,som_loc0,elem1,som_loc1);

                gradient1=0.;
                <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,som,elem0,som_loc0,
                             elem1,som_loc1,gradient1);

                grad1&lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                  grad1&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                grad1&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                  grad1&lt;&lt;gradient1(compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                grad1&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }
        }
    }

  ofstream result(les_mots[1].getChar());
  ofstream res(les_mots[2].getChar());
  ofstream resMat(les_mots[3].getChar());
  ofstream grad(les_mots[4].getChar());
  ofstream gradMat(les_mots[5].getChar());
  ofstream div(les_mots[6].getChar());

  <span class="keywordflow">for</span> (face=firstFaceInt; face&lt;size0; face++)
    {
      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=1.;
      inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();

<span class="comment">// Version explicite</span>
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);

<span class="comment">// Controle des gradients</span>
      grad&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
      grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
      <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
        {
          grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
          <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
            grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
          <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
            <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
              grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
        }

      gradientMat=0.;
      som_glob=-1;
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,som_glob,gradientMat);

      gradMat&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
      gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
      <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
        {
          gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
          <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
            gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
          <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
            gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
        }

      resu=0.;
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(resu);
      <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a>(resu);
      solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resu);
      div&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
      div&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        div&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
      <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
        {
          div&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
          <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
            div&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          div&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
          <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
            div&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
        }

      resu*=-1.;
      res&lt;&lt;<span class="stringliteral">&quot;Face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
      res&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        res&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
      <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
        {
          res&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
          <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
            res&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          res&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
          <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
            res&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
        }

<span class="comment">// Version matricielle</span>
      resuMat=0.;
      matrice.<a class="code" href="classMatrice__Morse.html#a7bbc0c7773ecb51c01d76adc02356dc0" title="Operation de multiplication-accumulation (saxpy) matrice matrice&lt;br&gt;(matrice X representee par un tab...">ajouter_multTab_</a>(inco,resuMat);
      solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resuMat);
      resuMat.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
      resMat&lt;&lt;<span class="stringliteral">&quot;Face interne :&quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
      resMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
      <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
        resMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
      resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
      <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
        {
          resMat&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
          <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
            resMat&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          resMat&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
          <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
            resMat&lt;&lt;resuMatV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
        }

<span class="comment">// Difference entre les resultat</span>
      resu-=resuMat;

<span class="comment">// Affichage des differences</span>
      max=resu.<a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">local_max_abs_vect</a>();
      <span class="keywordflow">if</span> (max&gt;1.e-14)
        {
          result&lt;&lt;<span class="stringliteral">&quot;Diff pour face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
          result&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
          <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
            result&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
          result&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
          <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
            {
              test1=<span class="keyword">false</span>;
              <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;1.e-14);

              <span class="keywordflow">if</span> (test1)
                {
                  result&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                    result&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  result&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                  <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                    result &lt;&lt;resuV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  result &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                }
            }
        }
      <span class="keywordflow">else</span>
        {
          result&lt;&lt;<span class="stringliteral">&quot;Diff pour face interne : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
          result&lt;&lt;<span class="stringliteral">&quot;Maximum : &quot;</span>&lt;&lt;max&lt;&lt;endl;
        }

      <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=0.;
      inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
    }


  <span class="keywordflow">for</span> (n_bord=0; n_bord&lt;nb_bords; n_bord++)
    {
      <span class="keyword">const</span> <a class="code" href="classCond__lim.html" title="classe Cond_lim Classe generique servant a representer n&#39;importe quelle classe derivee de la classe C...">Cond_lim</a>&amp; la_cl = zone_Cl_VEF.<a class="code" href="classZone__Cl__dis__base.html#af75e0ed7786863e4d333bfb29d67c323" title="Renvoie la i-ieme condition aux limites. (version const)">les_conditions_limites</a>(n_bord);
      <span class="keyword">const</span> <a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>&amp; le_bord = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classFront__VF.html" title="class Front_VF">Front_VF</a>,la_cl.<a class="code" href="classCond__lim.html#a5b2d24809cee07727006a891d4ce8d22" title="Appel a l&#39;objet sous-jacent Renvoie la frontiere discretisee associee a la condition aux limites...">frontiere_dis</a>());

      num1=0;
      num2=le_bord.<a class="code" href="classFront__VF.html#aed4006d91bf2ef3af2b9f7933d863a09" title="Nombre de faces reelles et virtuelles du bord.">nb_faces_tot</a>();

<span class="comment">// Modif pour tenir compte des conditions de Dirichlet</span>
<span class="comment">// -&gt; la matrice de masse doit tout annuler</span>
      <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet__homogene.html" title="Classe Dirichlet_homogene Cette classe est la classe de base de la hierarchie des conditions aux limi...">Dirichlet_homogene</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
<span class="comment">// Il ne sert a rien de faire un test dans ce cas</span>
        }

      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classDirichlet.html" title="classe Dirichlet Cette classe est la classe de base de la hierarchie des conditions aux limites de ty...">Dirichlet</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);

<span class="comment">// Version explicite</span>
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);

<span class="comment">// Controle des gradients</span>
            grad&lt;&lt;<span class="stringliteral">&quot;Face Dirichlet : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
              {
                grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                  grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }

            gradientMat=0.;
            som_glob=-1;
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,som_glob,gradientMat);

            gradMat&lt;&lt;<span class="stringliteral">&quot;Face Dirichlet : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
              {
                gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                  gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                  gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }

            <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
              <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                resuV[i*size1+j]=0.;
          }

      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="Cast_8h.html#a9632e68536db6c29c2b754cb55381fbe">sub_type</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>()))
        {
          <span class="keyword">const</span> <a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>&amp; la_cl_perio = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classPeriodique.html" title="classe Periodique Cette classe represente une condition aux limites periodique. On peut specifier une...">Periodique</a>,la_cl.<a class="code" href="classDeriv__Cond__lim__base.html#a482c910c704f6f51065a8b7d25acf48a">valeur</a>());

          assert(num2%2==0);
          <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
            {
              face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
              faceAss=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(la_cl_perio.<a class="code" href="classPeriodique.html#a207b86556f199a63ea059b841851ca6a">face_associee</a>(ind_face));

              <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=1.;
              <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[faceAss*size1+comp]=1.;
              inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();

<span class="comment">// Version explicite</span>
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);

<span class="comment">// Controle des gradients</span>
              grad &lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
              grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
              grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
                {
                  grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                    grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                  <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                    <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                      grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                }

              gradientMat=0.;
              som_glob=-1;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a37f70143adef3313705fb8583168fd93">gradient_som</a>(face,nnz,som_glob,gradientMat);

              gradMat&lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
              gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
              gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
                {
                  gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                    gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                }

              resu=0.;
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(resu);
              <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a>(resu);
              solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resu);
              div&lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
              div&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                div&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
              div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
                {
                  div&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                    div&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  div&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                  <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                    div&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                }

              resu*=-1.;
              res&lt;&lt;<span class="stringliteral">&quot;Face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
              res&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                res&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
              res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
                {
                  res&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                    res&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  res&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                  <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                    res&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                }

<span class="comment">// Version matricielle</span>
              resuMat=0.;
              matrice.<a class="code" href="classMatrice__Morse.html#a7bbc0c7773ecb51c01d76adc02356dc0" title="Operation de multiplication-accumulation (saxpy) matrice matrice&lt;br&gt;(matrice X representee par un tab...">ajouter_multTab_</a>(inco,resuMat);
              solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resuMat);
              resuMat.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
              resMat&lt;&lt;<span class="stringliteral">&quot;Face perio :&quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
              resMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
              <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                resMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
              resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
                {
                  resMat&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                    resMat&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  resMat&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                  <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                    resMat&lt;&lt;resuMatV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                }

<span class="comment">// Difference entre les resultat</span>
              resu-=resuMat;

<span class="comment">// Affichage des differences</span>
              max=resu.<a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">local_max_abs_vect</a>();
              <span class="keywordflow">if</span> (max&gt;1.e-14)
                {
                  result&lt;&lt;<span class="stringliteral">&quot;Diff pour face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
                  result&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                  <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                    result&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                  result&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                  <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
                    {
                      test1=<span class="keyword">false</span>;
                      <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                        test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;1.e-14);

                      <span class="keywordflow">if</span> (test1)
                        {
                          result&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                          <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                            result&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                          result&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                          <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                            result &lt;&lt;resuV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                          result &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                        }
                    }
                }
              <span class="keywordflow">else</span>
                {
                  result&lt;&lt;<span class="stringliteral">&quot;Diff pour face perio : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
                  result&lt;&lt;<span class="stringliteral">&quot;Maximum : &quot;</span>&lt;&lt;max&lt;&lt;endl;
                }

              <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=0.;
              <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[faceAss*size1+comp]=0.;
              inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
            }
        }<span class="comment">//fin Perio</span>
      <span class="keywordflow">else</span>
        <span class="keywordflow">for</span> (ind_face=num1; ind_face&lt;num2; ind_face++)
          {
            face=le_bord.<a class="code" href="classFront__VF.html#a3402a19d7e54ed797d2b18e9a47ead1e" title="Renvoie le numero de face de la ieme face du bord.">num_face</a>(ind_face);
            <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=1.;
            inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();

<span class="comment">// Version explicite</span>
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>=0.;
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a5e85dd4ed5a586f2787a149790ba0714">calculer_gradient_som</a>(inco);

<span class="comment">// Controle des gradients</span>
            grad &lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            grad&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              grad&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (som=0; som&lt;nb_som_tot; som++)
              {
                grad &lt;&lt;som&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                  grad&lt;&lt;xs(som,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                grad&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                <span class="keywordflow">for</span> (compi=0; compi&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">dim_ch_</a>; compi++)
                  <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                    grad&lt;&lt;<a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">gradient_p1_</a>(som,compi,compj)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                grad&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }

            gradientMat=0.;
            som_glob=-1;
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#a253bedb1323fa89e08a8d88e2be8798d">gradient_som_CL</a>(face,nnz,som_glob,gradientMat);

            gradMat&lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            gradMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              gradMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (i=0; i&lt;nnz; i++)
              {
                gradMat&lt;&lt;som_glob[i]&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                  gradMat&lt;&lt;xs(som_glob[i],ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                gradMat&lt;&lt;<span class="stringliteral">&quot;):(&quot;</span>;
                <span class="keywordflow">for</span> (compj=0; compj&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; compj++)
                  gradMat&lt;&lt;gradientMat(compj,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                gradMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }

            resu=0.;
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#aa940ce85caaf77638f592302b1fd8561">calculer_divergence_som</a>(resu);
            <a class="code" href="classOp__Diff__VEFP1NCP1B__Face.html#af61161babbf0b5a57042d39601c47e3e">corriger_Cl_test</a>(resu);
            solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resu);
            div&lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            div&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              div&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
              {
                div&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                  div&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                div&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                  div&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                div&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }

            resu*=-1.;
            res&lt;&lt;<span class="stringliteral">&quot;Face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            res&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              res&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
              {
                test1=<span class="keyword">false</span>;
                <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                  test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;max);

                <span class="keywordflow">if</span> (test1)
                  {
                    res&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                    <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                      res&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                    res&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                    <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                      res&lt;&lt;resu[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                    res&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                  }
              }

<span class="comment">// Version matricielle</span>
            resuMat=0.;
            matrice.<a class="code" href="classMatrice__Morse.html#a7bbc0c7773ecb51c01d76adc02356dc0" title="Operation de multiplication-accumulation (saxpy) matrice matrice&lt;br&gt;(matrice X representee par un tab...">ajouter_multTab_</a>(inco,resuMat);
            solveur_masse.<a class="code" href="classSolveur__Masse.html#af7afe8c2d4d5764f7428f2cd4ef43ddb" title="Appel a l&#39;objet sous-jacent. Resoud le systeme lineaire, dont la matrice est la matrice de masse...">appliquer</a>(resuMat);
            resuMat.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
            resMat&lt;&lt;<span class="stringliteral">&quot;Face CL :&quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
            resMat&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
            <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
              resMat&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
            resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
            <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
              {
                resMat&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                  resMat&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                resMat&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                  resMat&lt;&lt;resuMatV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                resMat&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
              }

<span class="comment">// Difference entre les resultat</span>
            resu-=resuMat;

<span class="comment">// Affichage des differences</span>
            max=resu.<a class="code" href="classDoubleVect.html#abdefeb5d940e66320adc0b9b11309737">local_max_abs_vect</a>();
            <span class="keywordflow">if</span> (max&gt;1.e-14)
              {
                result&lt;&lt;<span class="stringliteral">&quot;Diff pour face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
                result&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; i++)
                  result&lt;&lt;xv(face,i)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                result&lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                <span class="keywordflow">for</span> (i=0; i&lt;size0; i++)
                  {
                    test1=<span class="keyword">false</span>;
                    <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                      test1|=(<a class="code" href="Double_8h.html#aaecd4ca8a2fe69cc6568af2938b94d2e">dabs</a>(resuV[i*size1+j])&gt;1.e-14);

                    <span class="keywordflow">if</span> (test1)
                      {
                        result&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;(&quot;</span>;
                        <span class="keywordflow">for</span> (ii=0; ii&lt;<a class="code" href="classObjet__U.html#a3e23491c01f2f39245fb6f3b6d6d9b17">dimension</a>; ii++)
                          result&lt;&lt;xv(i,ii)&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                        result&lt;&lt;<span class="stringliteral">&quot;):=(&quot;</span>;
                        <span class="keywordflow">for</span> (j=0; j&lt;size1; j++)
                          result &lt;&lt;resuV[i*size1+j]&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>;
                        result &lt;&lt;<span class="stringliteral">&quot;)&quot;</span>&lt;&lt;endl;
                      }
                  }
              }
            <span class="keywordflow">else</span>
              {
                result&lt;&lt;<span class="stringliteral">&quot;Diff pour face CL : &quot;</span>&lt;&lt;face*size1+comp&lt;&lt;endl;
                result&lt;&lt;<span class="stringliteral">&quot;Maximum : &quot;</span>&lt;&lt;max&lt;&lt;endl;
              }

            <span class="keywordflow">if</span> (<a class="code" href="classProcess.html#acd052b99706c577f8a5b6656217cf4c2" title="renvoie 1 si on est sur le processeur maitre du groupe courant (c&#39;est a dire me() == 0)...">Process::je_suis_maitre</a>()) incoV[face*size1+comp]=0.;
            inco.<a class="code" href="classDoubleVect.html#abfebbc2f685ce7bc4b80c720d7da9bf3">echange_espace_virtuel</a>();
          }<span class="comment">//fin autres CL</span>
    }<span class="comment">//fin du for sur n_bord</span>
  <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">exit</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a639f6fb13c3e7f345f8d70f098eaf4c2"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::zone_Cl_VEFPreP1B" ref="a639f6fb13c3e7f345f8d70f098eaf4c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a> &amp; Op_Diff_VEFP1NCP1B_Face::zone_Cl_VEFPreP1B </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00175">175</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>References <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00080">Op_Diff_VEF_base::la_zcl_vef</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Ref__Zone__Cl__VEF_8h_source.html#l00028">Ref_Zone_Cl_VEF::valeur()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__Cl__VEFP1B.html">Zone_Cl_VEFP1B</a>,<a class="code" href="classOp__Diff__VEF__base.html#a721f395a27f12a95882437c614e16a7d">la_zcl_vef</a>.<a class="code" href="classRef__Zone__Cl__VEF.html#a0970d7253def65ad4f0c5ce1830fd243">valeur</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d6cebdde81108b4c492d8af3d6d60ae"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::zone_VEFPreP1B" ref="a8d6cebdde81108b4c492d8af3d6d60ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a> &amp; Op_Diff_VEFP1NCP1B_Face::zone_VEFPreP1B </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00170">170</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>References <a class="el" href="Op__Diff__VEF__base_8h_source.html#l00079">Op_Diff_VEF_base::la_zone_vef</a>, <a class="el" href="Cast_8h_source.html#l00059">ref_cast</a>, and <a class="el" href="Ref__Zone__VEF_8h_source.html#l00028">Ref_Zone_VEF::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01518">ajouter_contribution_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00826">calculer_divergence_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00862">calculer_divergence_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00323">calculer_dt_stab_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">calculer_flux_bords_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">calculer_flux_bords_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">calculer_gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00975">calculer_laplacien_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00731">corriger_div_pour_Cl()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02842">gradient_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03159">isFaceOfSymetry()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02944">isInStencil()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02323">liste_face()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02229">remplir_nu_p1()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VEF__PreP1b.html">Zone_VEF_PreP1b</a>,<a class="code" href="classOp__Diff__VEF__base.html#aadbdb144954bc7c5b56862e1f9f3c7f9">la_zone_vef</a>.<a class="code" href="classRef__Zone__VEF.html#aafd9a5ee1a76f290c9c6b5447b0c8d30">valeur</a>());
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3ca993ddf7251f0c1f79b9c659d5a96f"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::alphaA" ref="a3ca993ddf7251f0c1f79b9c659d5a96f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a3ca993ddf7251f0c1f79b9c659d5a96f">Op_Diff_VEFP1NCP1B_Face::alphaA</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00148">148</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="acbd7461fb999d27a3c1ba0320f13563a"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::alphaE" ref="acbd7461fb999d27a3c1ba0320f13563a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#acbd7461fb999d27a3c1ba0320f13563a">Op_Diff_VEFP1NCP1B_Face::alphaE</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00146">146</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">calculer_flux_bords_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ff8784f933eedd5f6a52db444f2d71b"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::alphaS" ref="a0ff8784f933eedd5f6a52db444f2d71b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a0ff8784f933eedd5f6a52db444f2d71b">Op_Diff_VEFP1NCP1B_Face::alphaS</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00147">147</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01346">ajouter_contribution_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00237">calculer_dt_stab()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">calculer_flux_bords_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03016">dimensionner()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>

</div>
</div>
<a class="anchor" id="a90fc51e82567cc139118e78417436ef2"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::coeff_" ref="a90fc51e82567cc139118e78417436ef2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a90fc51e82567cc139118e78417436ef2">Op_Diff_VEFP1NCP1B_Face::coeff_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00145">145</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01346">ajouter_contribution_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">calculer_gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02641">gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02842">gradient_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a463106e6f719474777b7cc6c5e813354"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::convexite_" ref="a463106e6f719474777b7cc6c5e813354" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a463106e6f719474777b7cc6c5e813354">Op_Diff_VEFP1NCP1B_Face::convexite_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00144">144</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01346">ajouter_contribution_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00323">calculer_dt_stab_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">calculer_flux_bords_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">calculer_flux_bords_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="a34224d2dfd0ecb6877ce4dc87abff1f0"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::decentrage_" ref="a34224d2dfd0ecb6877ce4dc87abff1f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a34224d2dfd0ecb6877ce4dc87abff1f0">Op_Diff_VEFP1NCP1B_Face::decentrage_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00150">150</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>.</p>

</div>
</div>
<a class="anchor" id="aecdf3d22b30add37625e545939004844"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::dim_ch_" ref="aecdf3d22b30add37625e545939004844" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aecdf3d22b30add37625e545939004844">Op_Diff_VEFP1NCP1B_Face::dim_ch_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00149">149</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00826">calculer_divergence_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00862">calculer_divergence_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">calculer_flux_bords_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">calculer_flux_bords_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">calculer_gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01633">coeff_matrice_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01770">coeff_matrice_som_CL()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02048">coeff_matrice_som_perio()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01907">coeff_matrice_som_symetrie()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03912">corriger_Cl_test()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00731">corriger_div_pour_Cl()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>

</div>
</div>
<a class="anchor" id="af276a7ed4462dd7921988559f8289460"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::gradient_p0_" ref="af276a7ed4462dd7921988559f8289460" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#af276a7ed4462dd7921988559f8289460">Op_Diff_VEFP1NCP1B_Face::gradient_p0_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00137">137</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00826">calculer_divergence_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01129">calculer_flux_bords_elem()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00433">calculer_gradient_elem()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>.</p>

</div>
</div>
<a class="anchor" id="a076341d23635d4ad7b0bfc19a03a7722"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::gradient_p1_" ref="a076341d23635d4ad7b0bfc19a03a7722" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a076341d23635d4ad7b0bfc19a03a7722">Op_Diff_VEFP1NCP1B_Face::gradient_p1_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00138">138</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00862">calculer_divergence_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01227">calculer_flux_bords_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00486">calculer_gradient_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l03201">test()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5225e89df933786053e400ee9b04db0"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::gradient_pa_" ref="ad5225e89df933786053e400ee9b04db0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoubleTab.html">DoubleTab</a> <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#ad5225e89df933786053e400ee9b04db0">Op_Diff_VEFP1NCP1B_Face::gradient_pa_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00139">139</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00724">calculer_gradient_aretes()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01100">initialiser()</a>.</p>

</div>
</div>
<a class="anchor" id="a45a7b1c4e61735e310ffe9238a64150a"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::info_obj" ref="a45a7b1c4e61735e310ffe9238a64150a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a> <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a45a7b1c4e61735e310ffe9238a64150a">Op_Diff_VEFP1NCP1B_Face::info_obj</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOp__Diff__VEF__Face.html#a0a28098c130d210696f761391f2099ce">Op_Diff_VEF_Face</a>.</p>

<p>Reimplemented in <a class="el" href="classOp__Diff__VEFP1NCP1B__Face__Var.html#a8238f353628d5ee9ca14086ac540f3c3">Op_Diff_VEFP1NCP1B_Face_Var</a>.</p>

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00055">55</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="a41feb4e425bf215a43112ffa45f0e0f7"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::is_laplacian_built_" ref="a41feb4e425bf215a43112ffa45f0e0f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a41feb4e425bf215a43112ffa45f0e0f7">Op_Diff_VEFP1NCP1B_Face::is_laplacian_built_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00142">142</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

</div>
</div>
<a class="anchor" id="a168b650a02b7a56f11b3205e7ea0e019"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::is_laplacian_filled_" ref="a168b650a02b7a56f11b3205e7ea0e019" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#a168b650a02b7a56f11b3205e7ea0e019">Op_Diff_VEFP1NCP1B_Face::is_laplacian_filled_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00141">141</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00975">calculer_laplacien_som()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>.</p>

</div>
</div>
<a class="anchor" id="af990901466d6341a02f7fd028353e028"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::laplacien_p1_" ref="af990901466d6341a02f7fd028353e028" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrice__Morse.html">Matrice_Morse</a> <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#af990901466d6341a02f7fd028353e028">Op_Diff_VEFP1NCP1B_Face::laplacien_p1_</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00140">140</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00402">calculer_dt_stab_som()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00975">calculer_laplacien_som()</a>.</p>

</div>
</div>
<a class="anchor" id="aa413a1aa88ba72b238a4bc1067f5a869"></a><!-- doxytag: member="Op_Diff_VEFP1NCP1B_Face::test_" ref="aa413a1aa88ba72b238a4bc1067f5a869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOp__Diff__VEFP1NCP1B__Face.html#aa413a1aa88ba72b238a4bc1067f5a869">Op_Diff_VEFP1NCP1B_Face::test_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html#l00134">134</a> of file <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01002">ajouter()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l02183">ajouter_contribution()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00069">Op_Diff_VEFP1NCP1B_Face()</a>, and <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l00090">readOn()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/P1NCP1B/Operateurs/<a class="el" href="Op__Diff__VEFP1NCP1B__Face_8h_source.html">Op_Diff_VEFP1NCP1B_Face.h</a></li>
<li>src/P1NCP1B/Operateurs/<a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html">Op_Diff_VEFP1NCP1B_Face.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:37:22 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
