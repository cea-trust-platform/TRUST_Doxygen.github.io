<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Geometrie/Interpolation_IBM/Interpolation_IBM_mean_gradient_proto.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/Geometrie/Interpolation_IBM/Interpolation_IBM_mean_gradient_proto.cpp</div>  </div>
</div>
<div class="contents">
<a href="Interpolation__IBM__mean__gradient__proto_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Interpolation_IBM_mean_gradient_proto.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/Geometrie/Interpolation_IBM</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Interpolation__IBM__mean__gradient__proto_8h.html">Interpolation_IBM_mean_gradient_proto.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="DoubleTab_8h.html">DoubleTab.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="DoubleTrav_8h.html">DoubleTrav.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="IntTab_8h.html">IntTab.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Process_8h.html">Process.h</a>&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a><a class="code" href="classInterpolation__IBM__mean__gradient__proto.html#aca6905c27c23c6f52bf8b3020d673043">00030</a> <span class="keywordtype">void</span> <a class="code" href="classInterpolation__IBM__mean__gradient__proto.html#aca6905c27c23c6f52bf8b3020d673043">Interpolation_IBM_mean_gradient_proto::computeSommetsVoisins</a>(<a class="code" href="classZone__dis__base.html" title="classe Zone_dis_base Cette classe est la base de la hierarchie des zones discretisees. Un objet Zone est associe a la zone discretise. A chaque methode numerique de Trio U correspond une classe derivant de Zone_dis_base implementant les outils necessaires a la methode.">Zone_dis_base</a>&amp; <a class="code" href="classSource__PDF__EF.html#a48b40508482720c75a7ec650fc541d71">la_zone_EF</a>,
<a name="l00031"></a>00031                                                                   <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; solid_points,
<a name="l00032"></a>00032                                                                   <span class="keyword">const</span> <a class="code" href="classChamp__Don.html" title="classe Champ_Don Classe generique de la hierarchie des champs donnes, un objet Champ_Don peut referen...">Champ_Don</a>&amp; corresp_elems)
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034   <span class="keywordtype">int</span> nb_som = la_zone_EF.<a class="code" href="classZone__dis__base.html#acc9921d6a29cb719fd832fd573e47825">nb_som</a>();
<a name="l00035"></a>00035   <span class="keywordtype">int</span> nb_som_tot = la_zone_EF.<a class="code" href="classZone__dis__base.html#a8f793341b7a41d67561ba563ae0f69a0">nb_som_tot</a>();
<a name="l00036"></a>00036   <span class="keywordtype">int</span> nb_elem = la_zone_EF.<a class="code" href="classZone__dis__base.html#a790cb2f6bc2928518799e748313d0eb3">nb_elem</a>();
<a name="l00037"></a>00037   <span class="keywordtype">int</span> nb_elem_tot = la_zone_EF.<a class="code" href="classZone__dis__base.html#a4d6aa445f152aa6dc54d66ea7a071147">nb_elem_tot</a>();
<a name="l00038"></a>00038   <span class="keywordtype">int</span> nb_som_elem = la_zone_EF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ae0b34a93b9ae8146df2d1884157afe9f" title="Renvoie le nombre de sommets des elements geometriques constituants la zone. Tous les elements de la ...">nb_som_elem</a>();
<a name="l00039"></a>00039   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; elems_solid_ref = <a class="code" href="classInterpolation__IBM__mean__gradient__proto.html#a0cac69be816b06c760f93d96c542a543">solid_elems_</a>.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>().<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>();
<a name="l00040"></a>00040   <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; elems = la_zone_EF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00041"></a>00041   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coordsDom = la_zone_EF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>().<a class="code" href="classDomaine.html#aecd32c3eecc15cce7d1a0e468dadbf96" title="Renvoie le tableau des coordonnees des noeuds (sommets). (acces en lecture)">coord_sommets</a>();
<a name="l00042"></a>00042   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; solidPointsCoords = solid_points.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>().<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>();
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">// Cerr &lt;&lt; &quot;nb_som_elem = &quot; &lt;&lt; nb_som_elem &lt;&lt; finl;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; is_dirichlet = <a class="code" href="classInterpolation__IBM__mean__gradient__proto.html#a50fd687dc3011ee4165e5df166ca1b20">is_dirichlet_</a>.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>().<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>();
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">// On cree un indicateur nodal reperant si un noeud appartient a un ou des elements</span>
<a name="l00049"></a>00049 <span class="comment">// etant totalement fluide (sans noeuds CL Dirichelt immergee)</span>
<a name="l00050"></a>00050   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> is_elem_fluide(nb_elem_tot);
<a name="l00051"></a>00051   <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> is_node_voisin_elem_fluide(is_dirichlet);
<a name="l00052"></a>00052   is_node_voisin_elem_fluide = 0.;
<a name="l00053"></a>00053   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_elem_tf = 0; num_elem_tf &lt; nb_elem_tot; num_elem_tf++)
<a name="l00054"></a>00054     {
<a name="l00055"></a>00055       is_elem_fluide(num_elem_tf) = 1.;
<a name="l00056"></a>00056 <span class="comment">// Est-ce vrai ?</span>
<a name="l00057"></a>00057       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_tf = 0; j_tf &lt; nb_som_elem; j_tf++)
<a name="l00058"></a>00058         {
<a name="l00059"></a>00059           <span class="keywordtype">int</span> num_som_tf = elems(num_elem_tf,j_tf);
<a name="l00060"></a>00060           <span class="keywordflow">if</span> ((num_som_tf &lt; nb_som) &amp;&amp; (is_dirichlet(num_som_tf) &gt; 0.0)) is_elem_fluide(num_elem_tf) = 0.;
<a name="l00061"></a>00061         }
<a name="l00062"></a>00062       <span class="keywordflow">if</span> (is_elem_fluide(num_elem_tf) == 1.)
<a name="l00063"></a>00063         {
<a name="l00064"></a>00064           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j_tf = 0; j_tf &lt; nb_som_elem; j_tf++)
<a name="l00065"></a>00065             {
<a name="l00066"></a>00066               <span class="keywordtype">int</span> num_som_tf = elems(num_elem_tf,j_tf);
<a name="l00067"></a>00067               is_node_voisin_elem_fluide(num_som_tf) = 1.;
<a name="l00068"></a>00068             }
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="comment">// La numerotation des elements peut avoir changee entre l&#39;etape pre_pro et</span>
<a name="l00073"></a>00073 <span class="comment">// l&#39;etape calcul (cas du pre_pro Salome)</span>
<a name="l00074"></a>00074 <span class="comment">// On utilise un champ d&#39;etiquette pour solid_elems_ (par exemple le no elem Salome)</span>
<a name="l00075"></a>00075 <span class="comment">// et un champ d&#39;element reprenant ces etiquettes</span>
<a name="l00076"></a>00076   <span class="keywordflow">if</span> ((&amp;corresp_elems)-&gt;non_nul())
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078       <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; corresp_elemsref = corresp_elems.<a class="code" href="classDeriv__Champ__Don__base.html#ae16e7e2a7a706352781c5ecc7764703d">valeur</a>().<a class="code" href="classChamp__Don__base.html#ac0ac51817e03e27c28d2b96bb15db9a0" title="Surcharge Champ_base::valeurs() Renvoie le tableau des valeurs.">valeurs</a>();
<a name="l00079"></a>00079       <span class="keywordtype">int</span> nb_tag_max = -1;
<a name="l00080"></a>00080       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; nb_elem_tot ; i++)
<a name="l00081"></a>00081         {
<a name="l00082"></a>00082           <span class="keywordtype">int</span> int_cor_elem = lrint(corresp_elemsref(i));
<a name="l00083"></a>00083           <span class="keywordflow">if</span> (int_cor_elem &gt; nb_tag_max) nb_tag_max = int_cor_elem;
<a name="l00084"></a>00084         }
<a name="l00085"></a>00085       <span class="keywordtype">int</span> dimtag = nb_tag_max+1;
<a name="l00086"></a>00086       <a class="code" href="classDoubleTrav.html" title="Tableau de travail a n entrees pour n&lt;= 4 C&#39;est un DoubleTab avec allocation dans un pool de memoire g...">DoubleTrav</a> elems_solid_trust(dimtag);
<a name="l00087"></a>00087       elems_solid_trust = -0.1*<a class="code" href="Double_8h.html#ae0ee0cebfad5968da0ad6cc7a49e16b6">DMAXFLOAT</a>;
<a name="l00088"></a>00088       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; nb_elem_tot ; i++)
<a name="l00089"></a>00089         {
<a name="l00090"></a>00090           <span class="keywordtype">int</span> indextag = lrint(corresp_elemsref(i)) ;
<a name="l00091"></a>00091           <span class="keywordflow">if</span> (indextag &lt; dimtag &amp;&amp; indextag &gt;= 0)
<a name="l00092"></a>00092             {
<a name="l00093"></a>00093               elems_solid_trust(indextag) = i*1.0;
<a name="l00094"></a>00094             }
<a name="l00095"></a>00095           <span class="keywordflow">else</span>
<a name="l00096"></a>00096             {
<a name="l00097"></a>00097               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;erreur in computeSommetsVoisins : elem corresp_elemsref(elem) = &quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;corresp_elemsref(i)&lt;&lt;<span class="stringliteral">&quot; ; indextag = &quot;</span>&lt;&lt;indextag&lt;&lt;<span class="stringliteral">&quot; &lt; 0 ou &gt;= &quot;</span>&lt;&lt;dimtag&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00098"></a>00098               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00099"></a>00099             }
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0 ; i &lt; nb_som_tot ; i++)
<a name="l00102"></a>00102         {
<a name="l00103"></a>00103           <span class="keywordflow">if</span> (elems_solid_ref(i) &gt;= 0.0)
<a name="l00104"></a>00104             {
<a name="l00105"></a>00105               <span class="keywordtype">int</span> indexr = lrint(elems_solid_ref(i));
<a name="l00106"></a>00106               <span class="keywordflow">if</span> (indexr &lt; dimtag &amp;&amp; indexr &gt;= 0)
<a name="l00107"></a>00107                 {
<a name="l00108"></a>00108                   <span class="keywordflow">if</span> (elems_solid_trust(indexr) &gt;= 0.) elems_solid_ref(i) = elems_solid_trust(indexr);
<a name="l00109"></a>00109                 }
<a name="l00110"></a>00110             }
<a name="l00111"></a>00111         }
<a name="l00112"></a>00112     }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <a class="code" href="classInterpolation__IBM__mean__gradient__proto.html#aefac1df1788984f39daf173fa940933f">sommets_voisins_</a> = <a class="code" href="classIntLists.html" title="Un tableau de listes de type IntList.">IntLists</a>(nb_som);
<a name="l00115"></a>00115   <span class="keywordtype">int</span> nb_nodes_in_list = 0;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> num_elem = 0; num_elem &lt; nb_elem_tot; num_elem++)
<a name="l00118"></a>00118     {
<a name="l00119"></a>00119       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nb_som_elem; j++)
<a name="l00120"></a>00120         {
<a name="l00121"></a>00121           <span class="keywordtype">int</span> num_som = elems(num_elem,j);
<a name="l00122"></a>00122           <span class="keywordtype">double</span> x1 = coordsDom(num_som,0);
<a name="l00123"></a>00123           <span class="keywordtype">double</span> x2 = coordsDom(num_som,1);
<a name="l00124"></a>00124           <span class="keywordtype">double</span> x3 = coordsDom(num_som,2);
<a name="l00125"></a>00125           <span class="keywordtype">double</span> xp1 = solidPointsCoords(num_som,0);
<a name="l00126"></a>00126           <span class="keywordtype">double</span> xp2 = solidPointsCoords(num_som,1);
<a name="l00127"></a>00127           <span class="keywordtype">double</span> xp3 = solidPointsCoords(num_som,2);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129           <span class="keywordflow">if</span> ((num_som &lt; nb_som) &amp;&amp; (is_dirichlet(num_som) &gt; 0.0))
<a name="l00130"></a>00130             {
<a name="l00131"></a>00131               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nb_som_elem; k++)
<a name="l00132"></a>00132                 {
<a name="l00133"></a>00133                   <span class="keywordflow">if</span> (k != j)
<a name="l00134"></a>00134                     {
<a name="l00135"></a>00135                       <span class="keywordtype">int</span> num_som_2 = elems(num_elem,k);
<a name="l00136"></a>00136                       <span class="keywordtype">double</span> xf1 = coordsDom(num_som_2,0);
<a name="l00137"></a>00137                       <span class="keywordtype">double</span> xf2 = coordsDom(num_som_2,1);
<a name="l00138"></a>00138                       <span class="keywordtype">double</span> xf3 = coordsDom(num_som_2,2);
<a name="l00139"></a>00139                       <span class="keywordtype">double</span> xpf1 = solidPointsCoords(num_som_2,0);
<a name="l00140"></a>00140                       <span class="keywordtype">double</span> xpf2 = solidPointsCoords(num_som_2,1);
<a name="l00141"></a>00141                       <span class="keywordtype">double</span> xpf3 = solidPointsCoords(num_som_2,2);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143                       <span class="keywordtype">double</span> d = (x1-xp1)*(xf1-xpf1)+(x2-xp2)*(xf2-xpf2)+(x3-xp3)*(xf3-xpf3);
<a name="l00144"></a>00144                       <span class="keywordtype">double</span> d1 = (xf1-xpf1)*(xf1-xpf1)+(xf2-xpf2)*(xf2-xpf2)+(xf3-xpf3)*(xf3-xpf3);
<a name="l00145"></a>00145                       <span class="keywordtype">double</span> d2 = (x1-xp1)*(x1-xp1)+(x2-xp2)*(x2-xp2)+(x3-xp3)*(x3-xp3);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">// On demande que :</span>
<a name="l00148"></a>00148 <span class="comment">// *) le point voisin soit de type fluide (pas Dirichlet)</span>
<a name="l00149"></a>00149 <span class="comment">// *) le projete du point fluide voisin soit du meme cote de la frontiere</span>
<a name="l00150"></a>00150 <span class="comment">// immergee que le point Dirichlet considere</span>
<a name="l00151"></a>00151 <span class="comment">// *) le projete du point fluide soit dans un element traverse par la</span>
<a name="l00152"></a>00152 <span class="comment">// frontiere (on considere la vitesse de la frontiere immergee en ce point)</span>
<a name="l00153"></a>00153 <span class="comment">// *) le projete du point fluide voisin soit a une distance carre d1 de la</span>
<a name="l00154"></a>00154 <span class="comment">// frontiere immergee plus grande que celle d2 du point Dirichlet</span>
<a name="l00155"></a>00155 <span class="comment">// considere (on interpole; on n&#39;extrapole pas; critere de</span>
<a name="l00156"></a>00156 <span class="comment">// distance : d1 = 2.0^2 fois d2)</span>
<a name="l00157"></a>00157 <span class="comment">// *) le point fluide voisin appartienne a au moins un element totalement fluide</span>
<a name="l00158"></a>00158                       <span class="keywordflow">if</span> (is_dirichlet(num_som_2) &lt; 0.0 &amp;&amp; d &gt; 0.0 &amp;&amp; (4.0*d2) &lt; d1 &amp;&amp; is_node_voisin_elem_fluide(num_som_2) == 1.0)
<a name="l00159"></a>00159                         {
<a name="l00160"></a>00160 <span class="comment">// Element contenant le projete du point fluide</span>
<a name="l00161"></a>00161                           <span class="keywordtype">int</span> elems_xpf = lrint(elems_solid_ref(num_som_2));
<a name="l00162"></a>00162                           <span class="keywordtype">bool</span> flag_xpf = <span class="keyword">true</span>;
<a name="l00163"></a>00163 <span class="comment">// bool flag_prt_nodes = false;</span>
<a name="l00164"></a>00164                           <span class="keywordtype">int</span> elem_found = la_zone_EF.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#aec585e7983082c3df305d75fd13a6b9e">chercher_elements</a>(xpf1,xpf2,xpf3);
<a name="l00165"></a>00165                           <span class="keywordflow">if</span> (elems_xpf &gt;= 0)
<a name="l00166"></a>00166                             {
<a name="l00167"></a>00167 <span class="comment">// test de verification prepro Salome/Trust :</span>
<a name="l00168"></a>00168                               <span class="keywordflow">if</span> ((elems_xpf != elem_found) &amp;&amp; (elem_found != -1))
<a name="l00169"></a>00169                                 {
<a name="l00170"></a>00170                                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; __FILE__ &lt;&lt; (int)__LINE__ &lt;&lt; <span class="stringliteral">&quot;Interpolation_IBM_mean_gradient_proto::computeSommetsVoisins : WARNING : elem solid prepro &quot;</span> &lt;&lt; elems_xpf &lt;&lt; <span class="stringliteral">&quot; != elem solid Trust &quot;</span> &lt;&lt; elem_found &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00171"></a>00171                                   flag_xpf = <span class="keyword">true</span>;
<a name="l00172"></a>00172 <span class="comment">// flag_prt_nodes = true;</span>
<a name="l00173"></a>00173                                 }
<a name="l00174"></a>00174                             }
<a name="l00175"></a>00175                           <span class="keywordflow">else</span>
<a name="l00176"></a>00176                             {
<a name="l00177"></a>00177                               <span class="keywordflow">if</span> (elems_xpf == -1.e+50)
<a name="l00178"></a>00178                                 {
<a name="l00179"></a>00179                                   flag_xpf = <span class="keyword">false</span>;
<a name="l00180"></a>00180                                 }
<a name="l00181"></a>00181                               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (elem_found != -1)
<a name="l00182"></a>00182                                 {
<a name="l00183"></a>00183                                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;node_fluide = &quot;</span>&lt;&lt;num_som_2&lt;&lt;<span class="stringliteral">&quot; we use chercher_elements(xpf,ypf,zpf) = &quot;</span>&lt;&lt;elem_found&lt;&lt;<span class="stringliteral">&quot; to replace values from SALOME = &quot;</span>&lt;&lt;elems_xpf&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00184"></a>00184                                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;coords_point(node_fluide) : xf yf zf = &quot;</span>&lt;&lt;xf1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xf2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xf3&lt;&lt;finl;
<a name="l00185"></a>00185                                   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;solid_points(node_fluide) : xpf ypf zpf = &quot;</span>&lt;&lt;xpf1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xpf2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xpf3&lt;&lt;finl;
<a name="l00186"></a>00186                                   elems_xpf = elem_found ;
<a name="l00187"></a>00187                                 }
<a name="l00188"></a>00188                             }
<a name="l00189"></a>00189                           <span class="keywordflow">if</span> (!flag_xpf)
<a name="l00190"></a>00190                             {
<a name="l00191"></a>00191 <span class="comment">// Traitement des erreurs</span>
<a name="l00192"></a>00192                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; __FILE__ &lt;&lt; (int)__LINE__ &lt;&lt; <span class="stringliteral">&quot;Interpolation_IBM_mean_gradient_proto::computeSommetsVoisins : ERROR : joint width too low?&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00193"></a>00193                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Nb elem; Nb elem tot = &quot;</span>&lt;&lt;nb_elem&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;nb_elem_tot&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00194"></a>00194                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Nb som;  Nb som tot  = &quot;</span>&lt;&lt;nb_som&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;nb_som_tot&lt;&lt;finl;
<a name="l00195"></a>00195                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;element; node_Dirichlet = &quot;</span>&lt;&lt;num_elem&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;num_som&lt;&lt;finl;
<a name="l00196"></a>00196                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;coords_point(node_Dirichlet) : x y z    = &quot;</span>&lt;&lt;x1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;x2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;x3&lt;&lt;finl;
<a name="l00197"></a>00197                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;solid_points(node_Dirichlet) : xp yp zp = &quot;</span>&lt;&lt;xp1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xp2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xp3&lt;&lt;finl;
<a name="l00198"></a>00198                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;node_fluide elems_solid_ref(node_fluide) elems_xpf = &quot;</span>&lt;&lt;num_som_2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;elems_solid_ref(num_som_2)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;elems_xpf&lt;&lt;finl;
<a name="l00199"></a>00199                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;coords_point(node_fluide) : xf yf zf    = &quot;</span>&lt;&lt;xf1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xf2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xf3&lt;&lt;finl;
<a name="l00200"></a>00200                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;solid_points(node_fluide) : xpf ypf zpf = &quot;</span>&lt;&lt;xpf1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xpf2&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;xpf3&lt;&lt;finl;
<a name="l00201"></a>00201                               <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;chercher_elements(xpf,ypf,zpf) = &quot;</span>&lt;&lt;elem_found&lt;&lt;finl;
<a name="l00202"></a>00202                               <span class="comment">/*if (flag_prt_nodes)</span>
<a name="l00203"></a>00203 <span class="comment">                                {</span>
<a name="l00204"></a>00204 <span class="comment">                                  double x1kf = 0.0;</span>
<a name="l00205"></a>00205 <span class="comment">                                  double x2kf = 0.0;</span>
<a name="l00206"></a>00206 <span class="comment">                                  double x3kf = 0.0;</span>
<a name="l00207"></a>00207 <span class="comment">                                  double x1kf2 = 0.0;</span>
<a name="l00208"></a>00208 <span class="comment">                                  double x2kf2 = 0.0;</span>
<a name="l00209"></a>00209 <span class="comment">                                  double x3kf2 = 0.0;</span>
<a name="l00210"></a>00210 <span class="comment">                                  for (int kf = 0; kf &lt; nb_som_elem; kf++)</span>
<a name="l00211"></a>00211 <span class="comment">                                    {</span>
<a name="l00212"></a>00212 <span class="comment">                                      int num_som_kf = elems(elems_xpf,kf);</span>
<a name="l00213"></a>00213 <span class="comment">                                      int num_som_kf2 = elems(elem_found,kf);</span>
<a name="l00214"></a>00214 <span class="comment">                                      x1kf += coordsDom(num_som_kf,0)/nb_som_elem;</span>
<a name="l00215"></a>00215 <span class="comment">                                      x2kf += coordsDom(num_som_kf,1)/nb_som_elem;</span>
<a name="l00216"></a>00216 <span class="comment">                                      x3kf += coordsDom(num_som_kf,2)/nb_som_elem;</span>
<a name="l00217"></a>00217 <span class="comment">                                      x1kf2 += coordsDom(num_som_kf2,0)/nb_som_elem;</span>
<a name="l00218"></a>00218 <span class="comment">                                      x2kf2 += coordsDom(num_som_kf2,1)/nb_som_elem;</span>
<a name="l00219"></a>00219 <span class="comment">                                      x3kf2 += coordsDom(num_som_kf2,2)/nb_som_elem;</span>
<a name="l00220"></a>00220 <span class="comment">                                      Cerr&lt;&lt;&quot;x elems_solid_ref   = &quot;&lt;&lt;coordsDom(num_som_kf,0)&lt;&lt;&quot; &quot;&lt;&lt;coordsDom(num_som_kf,1)&lt;&lt;&quot; &quot;&lt;&lt;coordsDom(num_som_kf,2)&lt;&lt;finl;</span>
<a name="l00221"></a>00221 <span class="comment">                                      Cerr&lt;&lt;&quot;x chercher_elements = &quot;&lt;&lt;coordsDom(num_som_kf2,0)&lt;&lt;&quot; &quot;&lt;&lt;coordsDom(num_som_kf2,1)&lt;&lt;&quot; &quot;&lt;&lt;coordsDom(num_som_kf2,2)&lt;&lt;finl;</span>
<a name="l00222"></a>00222 <span class="comment">                                    }</span>
<a name="l00223"></a>00223 <span class="comment">                                  Cerr&lt;&lt;&quot;bary elems_solid_ref   = &quot;&lt;&lt;x1kf&lt;&lt;&quot; &quot;&lt;&lt;x2kf&lt;&lt;&quot; &quot;&lt;&lt;x3kf&lt;&lt;finl;</span>
<a name="l00224"></a>00224 <span class="comment">                                  Cerr&lt;&lt;&quot;bary chercher_elements = &quot;&lt;&lt;x1kf2&lt;&lt;&quot; &quot;&lt;&lt;x2kf2&lt;&lt;&quot; &quot;&lt;&lt;x3kf2&lt;&lt;finl;</span>
<a name="l00225"></a>00225 <span class="comment">                                }*/</span>
<a name="l00226"></a>00226                               <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00227"></a>00227                             }
<a name="l00228"></a>00228 <span class="comment">// On demande que le projete du point fluide soit dans un element</span>
<a name="l00229"></a>00229 <span class="comment">// traverse par la frontiere ou borde d&#39;elements traverses par la frontiere</span>
<a name="l00230"></a>00230                           <span class="keywordflow">if</span> (elems_xpf &gt;= 0)
<a name="l00231"></a>00231                             {
<a name="l00232"></a>00232                               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kxpf = 0; kxpf &lt; nb_som_elem; kxpf++)
<a name="l00233"></a>00233                                 {
<a name="l00234"></a>00234                                   <span class="keywordtype">int</span> num_som_2xpf = elems(elems_xpf,kxpf);
<a name="l00235"></a>00235                                   <span class="keywordflow">if</span> (is_dirichlet(num_som_2xpf) &lt; 0.0) flag_xpf = <span class="keyword">false</span>;
<a name="l00236"></a>00236                                 }
<a name="l00237"></a>00237                               <span class="keywordflow">if</span> (flag_xpf)
<a name="l00238"></a>00238                                 {
<a name="l00239"></a>00239                                   <a class="code" href="classInterpolation__IBM__mean__gradient__proto.html#aefac1df1788984f39daf173fa940933f">sommets_voisins_</a>[num_som].add_if_not(num_som_2);
<a name="l00240"></a>00240                                   nb_nodes_in_list += 1;
<a name="l00241"></a>00241                                 }
<a name="l00242"></a>00242                             }
<a name="l00243"></a>00243                         }
<a name="l00244"></a>00244                     }
<a name="l00245"></a>00245                 }
<a name="l00246"></a>00246             }
<a name="l00247"></a>00247         }
<a name="l00248"></a>00248     }
<a name="l00249"></a>00249   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; __FILE__ &lt;&lt; (int)__LINE__ &lt;&lt; <span class="stringliteral">&quot;Interpolation_IBM_mean_gradient_proto::computeSommetsVoisins : nb nodes for interpolation = &quot;</span> &lt;&lt;nb_nodes_in_list&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:19 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
