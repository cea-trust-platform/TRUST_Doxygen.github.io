<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/MD_Vector_std.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Math/MD_Vector_std.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="MD__Vector__std_8h_source.html">MD_Vector_std.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="DoubleVect_8h_source.html">DoubleVect.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntVect_8h_source.html">IntVect.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Schema__Comm__Vecteurs_8h_source.html">Schema_Comm_Vecteurs.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Echange__EV__Options_8h_source.html">Echange_EV_Options.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="communications_8h_source.html">communications.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Param_8h_source.html">Param.h</a>&gt;</code><br/>
</div>
<p><a href="MD__Vector__std_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a274c0a8351b6c6028b67209f0e34024f">initialize_comm_</a> (const <a class="el" href="classMD__Vector__std.html">MD_Vector_std</a> &amp;md, const <a class="el" href="classEchange__EV__Options.html">Echange_EV_Options</a> &amp;opt, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;<a class="el" href="MD__Vector__tools_8cpp.html#aff39c4429f5c1b24eb7ac0848f154ffc">comm</a>, int line_size, int is_double)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a10b62793ecb01cb8437cffbc92d2dd89">read_from_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#af1a3457cd2fc6fc193441c0e6dd3be74">write_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a18734241182f029a4ac78fe0e7c5215c">add_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a0288ab9d63ca627c55980a67dcf9a8da">max_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#acc05df4426870bc5165ab6e635c5312c">mincol1_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a5a29fa9c3f9067e3d09fd936dac0d2f0">read_from_vect_blocs</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;nb_items_par_voisin, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#acbe04bcc0dbf2780408e9348dd5a9833">write_to_vect_blocs</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;nb_items_par_voisin, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a6b3040ad0a784f5bca7eddafffa60fca">add_to_vect_blocs</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;nb_items_par_voisin, <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#aafd41fc64277c4557a45f15dfdea335f">read_from_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a9f809601c51b1f7030e73731b9fd4684">write_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#ab54618ac8d5e595356fd7ad038f6140e">add_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#aeb6e79d8e1e2abab309c3c58241bd164">max_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a4c00e18db2e886d5456940fea1957cff">mincol1_to_vect_items</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#ab6fa83dd6ea808c3f9beda91a5c9a28e">read_from_vect_blocs</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;nb_items_par_voisin, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#ad696660c13588959c658f009754a9265">write_to_vect_blocs</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;nb_items_par_voisin, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#a3351597c3ac95cf85801ae3917f33f52">add_to_vect_blocs</a> (const int line_size, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;voisins, const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;list, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;nb_items_par_voisin, <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;vect, <a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;buffers)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MD__Vector__std_8cpp.html#aec9fc09b4c731c425fedebfbda0c7589">MD_Vector_stdbases</a> [1] = { &amp;( <a class="el" href="classMD__Vector__base2.html">MD_Vector_base2</a> ::info_obj)}</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6b3040ad0a784f5bca7eddafffa60fca"></a><!-- doxytag: member="MD_Vector_std.cpp::add_to_vect_blocs" ref="a6b3040ad0a784f5bca7eddafffa60fca" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, const ArrOfInt &amp;nb_items_par_voisin, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_to_vect_blocs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>nb_items_par_voisin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00652">652</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) += *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3351597c3ac95cf85801ae3917f33f52"></a><!-- doxytag: member="MD_Vector_std.cpp::add_to_vect_blocs" ref="a3351597c3ac95cf85801ae3917f33f52" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, const ArrOfInt &amp;nb_items_par_voisin, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_to_vect_blocs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>nb_items_par_voisin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l01116">1116</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) += *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a18734241182f029a4ac78fe0e7c5215c"></a><!-- doxytag: member="MD_Vector_std.cpp::add_to_vect_items" ref="a18734241182f029a4ac78fe0e7c5215c" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00413">413</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00736">MD_Vector_std::process_recv_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) += *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab54618ac8d5e595356fd7ad038f6140e"></a><!-- doxytag: member="MD_Vector_std.cpp::add_to_vect_items" ref="ab54618ac8d5e595356fd7ad038f6140e" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00877">877</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) += *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a274c0a8351b6c6028b67209f0e34024f"></a><!-- doxytag: member="MD_Vector_std.cpp::initialize_comm_" ref="a274c0a8351b6c6028b67209f0e34024f" args="(const MD_Vector_std &amp;md, const Echange_EV_Options &amp;opt, Schema_Comm_Vecteurs &amp;comm, int line_size, int is_double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_comm_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMD__Vector__std.html">MD_Vector_std</a> &amp;&#160;</td>
          <td class="paramname"><em>md</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEchange__EV__Options.html">Echange_EV_Options</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_double</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00265">265</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00159">Schema_Comm_Vecteurs::add_recv_area_double()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00154">Schema_Comm_Vecteurs::add_recv_area_int()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00149">Schema_Comm_Vecteurs::add_send_area_double()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00144">Schema_Comm_Vecteurs::add_send_area_int()</a>, <a class="el" href="MD__Vector__std_8h_source.html#l00079">MD_Vector_std::blocs_items_count_</a>, <a class="el" href="MD__Vector__std_8h_source.html#l00076">MD_Vector_std::blocs_to_recv_</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00106">Static_Int_Lists::get_list_size()</a>, <a class="el" href="Echange__EV__Options_8h_source.html#l00044">Echange_EV_Options::get_op()</a>, <a class="el" href="MD__Vector__std_8h_source.html#l00071">MD_Vector_std::items_to_recv_</a>, <a class="el" href="MD__Vector__std_8h_source.html#l00065">MD_Vector_std::items_to_send_</a>, <a class="el" href="MD__Vector__std_8h_source.html#l00060">MD_Vector_std::pe_voisins_</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, and <a class="el" href="Echange__EV__Options_8h_source.html#l00038">Echange_EV_Options::SYNC</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00302">MD_Vector_std::initialize_comm()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> reverse = (opt.<a class="code" href="classEchange__EV__Options.html#aa3d975c4dc791256ebd217c6aa3f4b15">get_op</a>() != <a class="code" href="classEchange__EV__Options.html#ab91405f7667327d1f277b627ca1adc09a96cf69dc7e23b38d6f83854a4d881e9b">Echange_EV_Options::SYNC</a>);

  <span class="keyword">const</span> <span class="keywordtype">int</span> have_items_to_recv = (md.<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> have_blocs_to_recv = (md.<a class="code" href="classMD__Vector__std.html#ae266bd552dcb9f817c791a1c7342a6b0">blocs_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt; 0);
  <span class="keyword">const</span> <span class="keywordtype">int</span> nprocs = md.<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nprocs; i++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> pe = md.<a class="code" href="classMD__Vector__std.html#a68854e710075fdc8c2f2ce28fbbb9ecc">pe_voisins_</a>[i];
      <span class="keywordtype">int</span> sz1 = md.<a class="code" href="classMD__Vector__std.html#a3ee9294b8d36492e8bdabbc9a97db451">items_to_send_</a>.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i);
      <span class="keywordtype">int</span> sz2 = 0;
      <span class="keywordflow">if</span> (have_items_to_recv)
        sz2 = md.<a class="code" href="classMD__Vector__std.html#a8d6c4c5d6da6fe56e8330253137d412f">items_to_recv_</a>.<a class="code" href="classStatic__Int__Lists.html#adbf6903737c3c30bf87e05b29f5a5b56" title="renvoie le nombre d&#39;elements de la liste i">get_list_size</a>(i);
      <span class="keywordflow">if</span> (have_blocs_to_recv)
        sz2 += md.<a class="code" href="classMD__Vector__std.html#a4aa5e80e0b975026cc201fbdee72956c">blocs_items_count_</a>[i];
      <span class="keywordflow">if</span> (reverse)
        {
<span class="comment">// Schema a l&#39;envers: lecture dans les items to recv,</span>
<span class="comment">// ecriture dans les items to send</span>
          <span class="keywordtype">int</span> tmp = sz1;
          sz1 = sz2;
          sz2 = tmp;
        }
      <span class="keywordflow">if</span> (is_double)
        {
          comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a64e4789eec21a8a401107adb1aaa65eb">add_send_area_double</a>(pe, sz1 * line_size);
          comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a1e886aafb0edbc524e3426786d268ff1">add_recv_area_double</a>(pe, sz2 * line_size);
        }
      <span class="keywordflow">else</span>
        {
          comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a80428288ac46f964239cf75adff9e426">add_send_area_int</a>(pe, sz1 * line_size);
          comm.<a class="code" href="classSchema__Comm__Vecteurs.html#a7e0bf8bf0137f69808fb319802b29782">add_recv_area_int</a>(pe, sz2 * line_size);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0288ab9d63ca627c55980a67dcf9a8da"></a><!-- doxytag: member="MD_Vector_std.cpp::max_to_vect_items" ref="a0288ab9d63ca627c55980a67dcf9a8da" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void max_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00457">457</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00736">MD_Vector_std::process_recv_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              <span class="keywordtype">double</span> dest = *vectptr;
              <span class="keywordtype">double</span> src  = *(bufptr++);
              *(vectptr++) = (dest &gt; src) ? dest : src;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeb6e79d8e1e2abab309c3c58241bd164"></a><!-- doxytag: member="MD_Vector_std.cpp::max_to_vect_items" ref="aeb6e79d8e1e2abab309c3c58241bd164" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void max_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00921">921</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              <span class="keywordtype">int</span> dest = *vectptr;
              <span class="keywordtype">int</span> src  = *(bufptr++);
              *(vectptr++) = (dest &gt; src) ? dest : src;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acc05df4426870bc5165ab6e635c5312c"></a><!-- doxytag: member="MD_Vector_std.cpp::mincol1_to_vect_items" ref="acc05df4426870bc5165ab6e635c5312c" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mincol1_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00503">503</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00736">MD_Vector_std::process_recv_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
<span class="comment">// Copy whole line if first line is greater than destination</span>
          assert(bufptr + line_size * bloc_size - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; bloc_size; j++)
            {
              <span class="keywordtype">double</span> dest = *vectptr;
              <span class="keywordtype">double</span> src  = *bufptr;
              <span class="keywordflow">if</span> (src &lt; dest)
                {
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = line_size; k; k--)
                    *(vectptr++) = *(bufptr++);
                }
              <span class="keywordflow">else</span>
                {
                  vectptr += line_size;
                  bufptr += line_size;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4c00e18db2e886d5456940fea1957cff"></a><!-- doxytag: member="MD_Vector_std.cpp::mincol1_to_vect_items" ref="a4c00e18db2e886d5456940fea1957cff" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mincol1_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00967">967</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
<span class="comment">// Copy whole line if first line is greater than destination</span>
          assert(bufptr + line_size * bloc_size - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; bloc_size; j++)
            {
              <span class="keywordtype">int</span> dest = *vectptr;
              <span class="keywordtype">int</span> src  = *bufptr;
              <span class="keywordflow">if</span> (src &lt; dest)
                {
                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = line_size; k; k--)
                    *(vectptr++) = *(bufptr++);
                }
              <span class="keywordflow">else</span>
                {
                  vectptr += line_size;
                  bufptr += line_size;
                }
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab6fa83dd6ea808c3f9beda91a5c9a28e"></a><!-- doxytag: member="MD_Vector_std.cpp::read_from_vect_blocs" ref="ab6fa83dd6ea808c3f9beda91a5c9a28e" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, const ArrOfInt &amp;nb_items_par_voisin, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_vect_blocs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>nb_items_par_voisin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l01022">1022</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(bufptr++) = *(vectptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5a29fa9c3f9067e3d09fd936dac0d2f0"></a><!-- doxytag: member="MD_Vector_std.cpp::read_from_vect_blocs" ref="a5a29fa9c3f9067e3d09fd936dac0d2f0" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, const ArrOfInt &amp;nb_items_par_voisin, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_vect_blocs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>nb_items_par_voisin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00558">558</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00699">MD_Vector_std::prepare_send_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(bufptr++) = *(vectptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a10b62793ecb01cb8437cffbc92d2dd89"></a><!-- doxytag: member="MD_Vector_std.cpp::read_from_vect_items" ref="a10b62793ecb01cb8437cffbc92d2dd89" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00325">325</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00699">MD_Vector_std::prepare_send_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(bufptr++) = *(vectptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aafd41fc64277c4557a45f15dfdea335f"></a><!-- doxytag: member="MD_Vector_std.cpp::read_from_vect_items" ref="aafd41fc64277c4557a45f15dfdea335f" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00789">789</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(bufptr++) = *(vectptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad696660c13588959c658f009754a9265"></a><!-- doxytag: member="MD_Vector_std.cpp::write_to_vect_blocs" ref="ad696660c13588959c658f009754a9265" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, const ArrOfInt &amp;nb_items_par_voisin, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_to_vect_blocs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>nb_items_par_voisin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l01069">1069</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) = *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acbe04bcc0dbf2780408e9348dd5a9833"></a><!-- doxytag: member="MD_Vector_std.cpp::write_to_vect_blocs" ref="acbe04bcc0dbf2780408e9348dd5a9833" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, const ArrOfInt &amp;nb_items_par_voisin, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_to_vect_blocs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>nb_items_par_voisin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00605">605</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00736">MD_Vector_std::process_recv_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = nb_items_par_voisin[i_voisin] * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
<span class="comment">// For blocs, the array contains begin_bloc, end_bloc, begin_bloc, end_bloc...</span>
          <span class="keyword">const</span> <span class="keywordtype">int</span> dernier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = dernier_item_bloc - premier_item_bloc;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) = *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af1a3457cd2fc6fc193441c0e6dd3be74"></a><!-- doxytag: member="MD_Vector_std.cpp::write_to_vect_items" ref="af1a3457cd2fc6fc193441c0e6dd3be74" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfDouble &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00369">369</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00180">Schema_Comm_Vecteurs::get_next_area_double()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>

<p>Referenced by <a class="el" href="MD__Vector__std_8cpp_source.html#l00736">MD_Vector_std::process_recv_data()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">double</span> *data = vect.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#a22d534079143232b4a9db96c93288782">get_next_area_double</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">double</span> * bufptr = buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">double</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) = *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f809601c51b1f7030e73731b9fd4684"></a><!-- doxytag: member="MD_Vector_std.cpp::write_to_vect_items" ref="a9f809601c51b1f7030e73731b9fd4684" args="(const int line_size, const ArrOfInt &amp;voisins, const Static_Int_Lists &amp;list, ArrOfInt &amp;vect, Schema_Comm_Vecteurs &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_to_vect_items </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>voisins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStatic__Int__Lists.html">Static_Int_Lists</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSchema__Comm__Vecteurs.html">Schema_Comm_Vecteurs</a> &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Index in list.get_data() </p>
</p>

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00833">833</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00058">Static_Int_Lists::get_data()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00054">Static_Int_Lists::get_index()</a>, <a class="el" href="Static__Int__Lists_8h_source.html#l00113">Static_Int_Lists::get_nb_lists()</a>, <a class="el" href="Schema__Comm__Vecteurs_8h_source.html#l00169">Schema_Comm_Vecteurs::get_next_area_int()</a>, and <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>.</p>
<div class="fragment"><pre class="fragment">{
  assert(line_size &gt; 0);
  <span class="keywordtype">int</span> *data = vect.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *items_to_process = list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> idx = 0; <span class="comment">//!&lt; Index in list.get_data()</span>
<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; index = list.<a class="code" href="classStatic__Int__Lists.html#a51352f7203aa95a858fdf7d198630352">get_index</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_voisins = list.<a class="code" href="classStatic__Int__Lists.html#a5872636466919b2cb8efe715c315d7ca" title="renvoie le nombre de listes stockees">get_nb_lists</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_voisin = 0; i_voisin &lt; nb_voisins; i_voisin++)
    {
<span class="comment">// Indice dans list.get_data() de la fin de la liste d&#39;items/blocs pour ce voisin:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> idx_end_of_list = index[i_voisin+1];
<span class="comment">// Nombre d&#39;elements de tableau a envoyer/recevoir de ce voisin</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> nb_elems = (idx_end_of_list - idx) * line_size;
      <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; buffer = buffers.<a class="code" href="classSchema__Comm__Vecteurs.html#ae31bd8f65b3b9ff75f5e8f12f94f5ebf" title="renvoie un tableau contenant les &quot;size&quot; valeurs suivantes recues du processeur pe lors de la commun...">get_next_area_int</a>(voisins[i_voisin], nb_elems);
      <span class="keywordtype">int</span> * bufptr = buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
      assert(idx_end_of_list &lt;= list.<a class="code" href="classStatic__Int__Lists.html#ac72c923acdf74ba0d8fed055c494fc5b">get_data</a>().<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      <span class="keywordflow">while</span> (idx &lt; idx_end_of_list)
        {
<span class="comment">// Indice de l&#39;item geometrique a copier (ou du premier item du bloc)</span>
          <span class="keywordtype">int</span> premier_item_bloc = items_to_process[idx++];
          <span class="keyword">const</span> <span class="keywordtype">int</span> bloc_size = 1;
<span class="comment">// Adresse des elements a copier dans le vecteur</span>
          assert(premier_item_bloc &gt;= 0 &amp;&amp; bloc_size &gt; 0 &amp;&amp; (premier_item_bloc+bloc_size) * line_size &lt;= vect.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordtype">int</span> *vectptr = data + premier_item_bloc * line_size;
          <span class="keyword">const</span> <span class="keywordtype">int</span> n = line_size * bloc_size;
          assert(bufptr + n - buffer.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() &lt;= buffer.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; j++)
            {
              *(vectptr++) = *(bufptr++);
            }
        }
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="aec9fc09b4c731c425fedebfbda0c7589"></a><!-- doxytag: member="MD_Vector_std.cpp::MD_Vector_stdbases" ref="aec9fc09b4c731c425fedebfbda0c7589" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="MD__Vector__std_8cpp.html#aec9fc09b4c731c425fedebfbda0c7589">MD_Vector_stdbases</a>[1] = { &amp;( <a class="el" href="classMD__Vector__base2.html">MD_Vector_base2</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MD__Vector__std_8cpp_source.html#l00033">33</a> of file <a class="el" href="MD__Vector__std_8cpp_source.html">MD_Vector_std.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:52 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
