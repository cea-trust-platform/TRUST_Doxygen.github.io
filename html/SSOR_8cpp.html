<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/SolvSys/SSOR.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Math/SolvSys/SSOR.cpp File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="SSOR_8h_source.html">SSOR.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Motcle_8h_source.html">Motcle.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Matrice__Morse__Sym_8h_source.html">Matrice_Morse_Sym.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Matrice__Bloc__Sym_8h_source.html">Matrice_Bloc_Sym.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector__tools_8h_source.html">MD_Vector_tools.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector__base_8h_source.html">MD_Vector_base.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Param_8h_source.html">Param.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="ConstDoubleTab__parts_8h_source.html">ConstDoubleTab_parts.h</a>&gt;</code><br/>
</div>
<p><a href="SSOR_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a83a12abf0d3d0650563cba68e988b4fd">traite_diagonale</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a48c1a6c6f0d5c6cf939af4ddab0a7ba1">descente</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#aa3e5b9c2942469b29c8e8f874897bbe1">remontee</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a906876e35c5c5c892130214cc4f9e66c">descente</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a63ed19f4f2d49705c4a2c909bcd796be">remontee</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a678783cb16d22aa5fdf95ee27a476764">descente_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#abe7caa2af06f2228eeb87613b49fa72e">descente_bloc_extradiag_assert</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#adfde91562afac839dcf9442dcfd3d507">remontee_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a5600e796c5a19cf31272da290b9933d6">remontee_bloc_extradiag_assert</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a7e9cf5b8854791ed17d82f27a325c16e">descente_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a65eba611ca3cc3a3bfaa8d5afc59d99d">descente_bloc_extradiag_assert</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur2, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a3f7bb4887ce88e726a9512342521f07c">remontee_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#ada55b3da28d7d5625ba464159920f977">remontee_bloc_extradiag_assert</a> (const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur2, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#aed227e1ac9fa7cd2e15bcc6187422067">descente_diag_ok_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a3d6a3eb26f76575031f1283cd7a0daa6">remontee_diag_ok_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#af50d87729d0431f156ef36e568081cee">descente_diag_ok_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a7f70981e2add623f46c0078c9b96bfb0">remontee_diag_ok_assert</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#ac6165a9a7d7601cae69f7b343d02499d">descente_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#aa011041d08feeec86cfb569445fd565d">remontee_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a92f28012f2a840b61326fc5a649b8735">descente_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a902ef62d765177f316b5b8460d0f1a8a">remontee_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a341f4b46910ca2435d75af01fbe161bc">descente_assert_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a38be26171881a415291350c94e94c644">remontee_assert_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#ac6db7a57565b08f88196e93da2bcd53e">descente_assert_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#ac9677ce4fb57e5aa0e3bc8452650b815">remontee_assert_precond_diag</a> (const double omega, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab1, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;tab2, const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;<a class="el" href="Champ__P1iP1B__implementation_8cpp.html#aa8c8f49390c3cf7c702d71a71bc977e3">coeff</a>, <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vecteur, const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;items_a_traiter)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classType__info.html">Type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SSOR_8cpp.html#a15de6481f99a47c9ed659ff5adf54e64">SSORbases</a> [1] = { &amp;( <a class="el" href="classPrecond__base.html">Precond_base</a> ::info_obj)}</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a48c1a6c6f0d5c6cf939af4ddab0a7ba1"></a><!-- doxytag: member="SSOR.cpp::descente" ref="a48c1a6c6f0d5c6cf939af4ddab0a7ba1" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00179">179</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      {
<span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
        <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
        <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
        <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
        tab2_ptr++;
        coeff_ptr++;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
<span class="comment">// Pas d&#39;items virtuels autorises !</span>
            <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
            sol_fortran[i2] -= coeff_i_i2 * v_i;
          }
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a906876e35c5c5c892130214cc4f9e66c"></a><!-- doxytag: member="SSOR.cpp::descente" ref="a906876e35c5c5c892130214cc4f9e66c" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00282">282</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
      <span class="keywordflow">if</span> (item_a_traiter)
        {
<span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
          <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
          <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
          tab2_ptr++;
          coeff_ptr++;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
              <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
              sol_fortran[i2] -= coeff_i_i2 * v_i;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
          sol_fortran[i] = 0.;
          coeff_ptr += nvois;
          tab2_ptr += nvois;
        }
    }
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
      sol_fortran[i] = 0.;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7e9cf5b8854791ed17d82f27a325c16e"></a><!-- doxytag: member="SSOR.cpp::descente_assert" ref="a7e9cf5b8854791ed17d82f27a325c16e" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00586">586</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      assert((flags_ptr - items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()) == (i-1));
      <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
      <span class="keywordflow">if</span> (item_a_traiter)
        {
<span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
          assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
          <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
          tab2_ptr++;
          coeff_ptr++;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
              assert(i2 &gt; i &amp;&amp; i2 &lt;= vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>());
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
              sol_fortran[i2] -= coeff_i_i2 * v_i;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
          sol_fortran[i] = 0.;
          coeff_ptr += nvois;
          tab2_ptr += nvois;
        }
    }
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
      sol_fortran[i] = 0.;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a678783cb16d22aa5fdf95ee27a476764"></a><!-- doxytag: member="SSOR.cpp::descente_assert" ref="a678783cb16d22aa5fdf95ee27a476764" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00411">411</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      {
<span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
        assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
        <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
        <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
        tab2_ptr++;
        coeff_ptr++;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
<span class="comment">// Pas d&#39;items virtuels autorises !</span>
            assert(i2 &gt; i &amp;&amp; i2 &lt;= nb_lignes_a_traiter);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
            sol_fortran[i2] -= coeff_i_i2 * v_i;
          }
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a341f4b46910ca2435d75af01fbe161bc"></a><!-- doxytag: member="SSOR.cpp::descente_assert_precond_diag" ref="a341f4b46910ca2435d75af01fbe161bc" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_assert_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01239">1239</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      {
<span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
        <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
<span class="comment">// Pas d&#39;items virtuels autorises !</span>
            assert(i2 &gt; i &amp;&amp; i2 &lt;= nb_lignes_a_traiter);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
            sol_fortran[i2] -= coeff_i_i2 * v_i;
          }
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6db7a57565b08f88196e93da2bcd53e"></a><!-- doxytag: member="SSOR.cpp::descente_assert_precond_diag" ref="ac6db7a57565b08f88196e93da2bcd53e" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_assert_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01333">1333</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      assert((flags_ptr - items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()) == (i-1));
      <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
      <span class="keywordflow">if</span> (item_a_traiter)
        {
<span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
          <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
              assert(i2 &gt; i &amp;&amp; i2 &lt;= vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>());
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
              sol_fortran[i2] -= coeff_i_i2 * v_i;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
          sol_fortran[i] = 0.;
          coeff_ptr += nvois;
          tab2_ptr += nvois;
        }
    }
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
      sol_fortran[i] = 0.;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a65eba611ca3cc3a3bfaa8d5afc59d99d"></a><!-- doxytag: member="SSOR.cpp::descente_bloc_extradiag_assert" ref="a65eba611ca3cc3a3bfaa8d5afc59d99d" args="(const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, const DoubleVect &amp;vecteur, DoubleVect &amp;vecteur2, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_bloc_extradiag_assert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00659">659</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">double</span>       *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
    {
      <span class="keywordflow">if</span> (*(flags_ptr++))
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = *vecteur_ptr;
          <span class="keywordtype">int</span> index = tab1[i_ligne];
          <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
          assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
          <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
          <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
          <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
              assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
              <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
<span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
              vecteur2_fortran_ptr[i_colonne] -= c * v_i;
            }
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="abe7caa2af06f2228eeb87613b49fa72e"></a><!-- doxytag: member="SSOR.cpp::descente_bloc_extradiag_assert" ref="abe7caa2af06f2228eeb87613b49fa72e" args="(const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, const DoubleVect &amp;vecteur, DoubleVect &amp;vecteur2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_bloc_extradiag_assert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00461">461</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01530">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">double</span>       *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
    {
      {
        <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = *vecteur_ptr;
        <span class="keywordtype">int</span> index = tab1[i_ligne];
        <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
        assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
        <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
        <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
        <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
            assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
            <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
<span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
            vecteur2_fortran_ptr[i_colonne] -= c * v_i;
          }
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af50d87729d0431f156ef36e568081cee"></a><!-- doxytag: member="SSOR.cpp::descente_diag_ok_assert" ref="af50d87729d0431f156ef36e568081cee" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_diag_ok_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00896">896</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      assert((flags_ptr - items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>()) == (i-1));
      <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
      <span class="keywordflow">if</span> (item_a_traiter)
        {
<span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
          assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
          <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
          tab2_ptr++;
          coeff_ptr++;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
              assert(i2 &gt; i &amp;&amp; i2 &lt;= vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>());
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
              sol_fortran[i2] -= coeff_i_i2 * v_i;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
          sol_fortran[i] = 0.;
          coeff_ptr += nvois;
          tab2_ptr += nvois;
        }
    }
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
      sol_fortran[i] = 0.;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aed227e1ac9fa7cd2e15bcc6187422067"></a><!-- doxytag: member="SSOR.cpp::descente_diag_ok_assert" ref="aed227e1ac9fa7cd2e15bcc6187422067" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_diag_ok_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00793">793</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01530">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; (tab1_de_i - 1) &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      {
<span class="comment">// Le premier coeff doit etre le coef diagonal et doit etre strictement positif</span>
        assert(nvois &gt;= 1 &amp;&amp; (*tab2_ptr) == i &amp;&amp; (*coeff_ptr) &gt; 0.);
        <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / (*coeff_ptr);
        <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega_coeff_i_i;
        tab2_ptr++;
        coeff_ptr++;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
<span class="comment">// Pas d&#39;items virtuels autorises !</span>
            assert(i2 &gt; i &amp;&amp; i2 &lt;= nb_lignes_a_traiter);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
            sol_fortran[i2] -= coeff_i_i2 * v_i;
          }
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6165a9a7d7601cae69f7b343d02499d"></a><!-- doxytag: member="SSOR.cpp::descente_precond_diag" ref="ac6165a9a7d7601cae69f7b343d02499d" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01025">1025</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      {
<span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
        <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
<span class="comment">// Pas d&#39;items virtuels autorises !</span>
            <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
            sol_fortran[i2] -= coeff_i_i2 * v_i;
          }
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a92f28012f2a840b61326fc5a649b8735"></a><!-- doxytag: member="SSOR.cpp::descente_precond_diag" ref="a92f28012f2a840b61326fc5a649b8735" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void descente_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; sinon 2 lignes ci-dessous fausses.</p>
<p>&lt; = tab1[i]</p>
<p>&lt; indice de colonne pour le prochain coefficient </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01119">1119</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
<span class="comment">// le pointeur est constant, pas le tableau pointe.</span>
  <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  assert(nb_lignes_a_traiter &lt;= tab1.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() + 1);
  assert(*tab1_ptr == 1); <span class="comment">//!&lt; sinon 2 lignes ci-dessous fausses.</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr++;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nb_lignes_a_traiter; i++, tab1_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = tab1_de_i - last_tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester, sinon on pollue les autres lignes du vecteur sol</span>
<span class="comment">// avec des valeurs dependant des items communs et virtuels</span>
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      <span class="keyword">const</span> <span class="keywordtype">int</span> item_a_traiter = *(flags_ptr++);
      <span class="keywordflow">if</span> (item_a_traiter)
        {
<span class="comment">// Pas de coefficient diagonal stocke (ni dans tab2 ni dans coeff), la diagonale vaut 1:</span>
          <span class="keyword">const</span> <span class="keywordtype">double</span> v_i = sol_fortran[i] *= omega;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr; <span class="comment">//!&lt; indice de colonne pour le prochain coefficient</span>
<span class="comment"></span>              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// la matrice n&#39;a que des coeffs diagonaux superieurs et on a deja traite</span>
<span class="comment">// la diagonale, donc i2 &gt; i.</span>
              <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
<span class="comment">// B.M.: ... en revanche, le test sur les items communs est superflu ici car</span>
<span class="comment">// la valeur sera annulee (voir **Annulation items communs**),</span>
<span class="comment">// gain de perfs si on ne fait pas le test</span>
              sol_fortran[i2] -= coeff_i_i2 * v_i;
            }
        }
      <span class="keywordflow">else</span>
        {
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// c&#39;est la derniere fois qu&#39;on ecrit dans sol_fortran[i] car la</span>
<span class="comment">// matrice est diagonale superieure. Pour eviter le test sur items_a_traiter_</span>
<span class="comment">// dans la remontee, on annule la solution pour les items communs et virtuels</span>
<span class="comment">// (sol_fortran[i] ne sera plus modifie ensuite dans la descente)</span>
          sol_fortran[i] = 0.;
          coeff_ptr += nvois;
          tab2_ptr += nvois;
        }
    }
<span class="comment">// **Annulation items communs**</span>
<span class="comment">// Pour la remontee il faut annuler les valeurs dans les cases virtuelles</span>
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> fin = vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter+1; i &lt;= fin; i++)
      sol_fortran[i] = 0.;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a63ed19f4f2d49705c4a2c909bcd796be"></a><!-- doxytag: member="SSOR.cpp::remontee" ref="a63ed19f4f2d49705c4a2c909bcd796be" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00353">353</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (*(flags_ptr--))
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// ici coeff_ptr est le coeff diagonal</span>
          <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
          *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
          coeff_ptr--;
          tab2_ptr--;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa3e5b9c2942469b29c8e8f874897bbe1"></a><!-- doxytag: member="SSOR.cpp::remontee" ref="aa3e5b9c2942469b29c8e8f874897bbe1" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00227">227</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (1)
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// ici coeff_ptr est le coeff diagonal</span>
          <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
          *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
          coeff_ptr--;
          tab2_ptr--;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="adfde91562afac839dcf9442dcfd3d507"></a><!-- doxytag: member="SSOR.cpp::remontee_assert" ref="adfde91562afac839dcf9442dcfd3d507" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00494">494</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (1)
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// ici coeff_ptr est le coeff diagonal</span>
          assert((*tab2_ptr) == i);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
          *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
          coeff_ptr--;
          tab2_ptr--;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3f7bb4887ce88e726a9512342521f07c"></a><!-- doxytag: member="SSOR.cpp::remontee_assert" ref="a3f7bb4887ce88e726a9512342521f07c" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00695">695</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (*(flags_ptr--))
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// ici coeff_ptr est le coeff diagonal</span>
          assert((*tab2_ptr) == i);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
          *soli_ptr = (*soli_ptr) * psi * omega - x * omega_coeff_i_i;
          coeff_ptr--;
          tab2_ptr--;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac9677ce4fb57e5aa0e3bc8452650b815"></a><!-- doxytag: member="SSOR.cpp::remontee_assert_precond_diag" ref="ac9677ce4fb57e5aa0e3bc8452650b815" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_assert_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01400">1400</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (*(flags_ptr--))
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
          *soli_ptr = ((*soli_ptr) * psi - x) * omega;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a38be26171881a415291350c94e94c644"></a><!-- doxytag: member="SSOR.cpp::remontee_assert_precond_diag" ref="a38be26171881a415291350c94e94c644" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_assert_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01283">1283</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (1)
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
          *soli_ptr = ((*soli_ptr) * psi - x) * omega;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5600e796c5a19cf31272da290b9933d6"></a><!-- doxytag: member="SSOR.cpp::remontee_bloc_extradiag_assert" ref="a5600e796c5a19cf31272da290b9933d6" args="(const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const DoubleVect &amp;vecteur2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_bloc_extradiag_assert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00552">552</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01530">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
    {
      {
        <span class="keywordtype">double</span> x = *vecteur_ptr;
        <span class="keywordtype">int</span> index = tab1[i_ligne];
        <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
        assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
        <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
        <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
        <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
          {
            <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
            assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
            <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
            <span class="keyword">const</span> <span class="keywordtype">double</span> x2 = vecteur2_fortran_ptr[i_colonne];
<span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
            x -= c * x2;
          }
        *vecteur_ptr = x;
      }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ada55b3da28d7d5625ba464159920f977"></a><!-- doxytag: member="SSOR.cpp::remontee_bloc_extradiag_assert" ref="ada55b3da28d7d5625ba464159920f977" args="(const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const DoubleVect &amp;vecteur2, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_bloc_extradiag_assert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00756">756</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">double</span> *vecteur_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *vecteur2_fortran_ptr = vecteur2.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_fortran_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  assert(coeff.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ligne = 0; i_ligne &lt; nb_lignes; i_ligne++, vecteur_ptr++)
    {
      <span class="keywordflow">if</span> (*(flags_ptr++))
        {
          <span class="keywordtype">double</span> x = *vecteur_ptr;
          <span class="keywordtype">int</span> index = tab1[i_ligne];
          <span class="keyword">const</span> <span class="keywordtype">int</span> index_fin = tab1[i_ligne+1];
<span class="comment">// Il peut n&#39;y avoir aucun coefficient sur la ligne =&gt; index_fin == index</span>
          assert(index &gt; 0 &amp;&amp; index_fin &gt;= index &amp;&amp; index_fin &lt;= tab2.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()+1);
          <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2_fortran_ptr + index;
          <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff_fortran_ptr + index;
          <span class="keywordflow">for</span> (; index &lt; index_fin; index++, tab2_ptr++, coeff_ptr++)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i_colonne = *tab2_ptr;
              assert(i_colonne &gt;= 1 &amp;&amp; i_colonne &lt;= vecteur2.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
              <span class="keyword">const</span> <span class="keywordtype">double</span> c = *coeff_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> x2 = vecteur2_fortran_ptr[i_colonne];
<span class="comment">// pas de test item commun sur les colonnes, voir **Annulation items communs**</span>
              x -= c * x2;
            }
          *vecteur_ptr = x;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f70981e2add623f46c0078c9b96bfb0"></a><!-- doxytag: member="SSOR.cpp::remontee_diag_ok_assert" ref="a7f70981e2add623f46c0078c9b96bfb0" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_diag_ok_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00967">967</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (*(flags_ptr--))
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// ici coeff_ptr est le coeff diagonal</span>
          assert((*tab2_ptr) == i);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<span class="comment">// La diagonale a deja ete multipliee par psi * coeff_i_i</span>
          *soli_ptr = ((*soli_ptr) - x) * omega_coeff_i_i;
          coeff_ptr--;
          tab2_ptr--;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3d6a3eb26f76575031f1283cd7a0daa6"></a><!-- doxytag: member="SSOR.cpp::remontee_diag_ok_assert" ref="a3d6a3eb26f76575031f1283cd7a0daa6" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_diag_ok_assert </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00841">841</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01530">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      assert(nvois &gt;= 0 &amp;&amp; tab1_de_i &gt; 0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (1)
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// ici coeff_ptr est le coeff diagonal</span>
          assert((*tab2_ptr) == i);
          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = *coeff_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> omega_coeff_i_i = omega / coeff_i_i;
<span class="comment">// La diagonale a deja ete multipliee par psi * coeff_i_i</span>
          *soli_ptr = ((*soli_ptr) - x) * omega_coeff_i_i;
          coeff_ptr--;
          tab2_ptr--;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa011041d08feeec86cfb569445fd565d"></a><!-- doxytag: member="SSOR.cpp::remontee_precond_diag" ref="aa011041d08feeec86cfb569445fd565d" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01069">1069</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01459">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (1)
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
          *soli_ptr = ((*soli_ptr) * psi - x) * omega;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a902ef62d765177f316b5b8460d0f1a8a"></a><!-- doxytag: member="SSOR.cpp::remontee_precond_diag" ref="a902ef62d765177f316b5b8460d0f1a8a" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur, const ArrOfInt &amp;items_a_traiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remontee_precond_diag </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>items_a_traiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; = tab1[i] </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l01186">1186</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> *flags_ptr = items_a_traiter.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  assert(nb_lignes_a_traiter &lt;= items_a_traiter.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>());
  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;

<span class="comment">// pointeur &quot;fortran&quot; vers le tableau solution (indexable avec index fortran)</span>
  <span class="keyword">const</span> <span class="keywordtype">double</span> * <span class="keyword">const</span> sol_fortran = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter;
  <span class="keywordtype">int</span> last_tab1_de_i = *tab1_ptr;
  tab1_ptr--;
<span class="comment">// On ne va pas a la fin de tab2 car on n&#39;est pas sur que nb_lignes_a_traiter = tab1.size_array() :</span>
<span class="comment">// -2 car last_tab1_de_i est l&#39;indice du premier coefficient de la ligne suivante en fortran</span>
<span class="comment">// (dont -1 pour fortran-&gt;c et -1 pour passer au dernier coeff de la ligne precedente)</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab2_ptr = tab2.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_ptr = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + last_tab1_de_i - 2;
  <span class="keywordtype">double</span> * soli_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() + nb_lignes_a_traiter - 1;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr--, soli_ptr--)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> tab1_de_i = *tab1_ptr; <span class="comment">//!&lt; = tab1[i]</span>
<span class="comment"></span>      <span class="keyword">const</span> <span class="keywordtype">int</span> nvois = last_tab1_de_i - tab1_de_i;
      <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span> (0);
      last_tab1_de_i = tab1_de_i;
<span class="comment">// Ce test doit rester car il ne faut pas modifier sol[i] pour les items communs</span>
<span class="comment">// et virtuels (ils sont nuls et doivent le rester pour ne pas polluer les autres lignes):</span>
      <span class="keywordflow">if</span> (*(flags_ptr--))
        {
<span class="comment">// Operation &quot;diagonale&quot;:</span>
          <span class="keywordtype">double</span> x = 0.;
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = nvois-1; j; j--, tab2_ptr--, coeff_ptr--)
            {
              <span class="keyword">const</span> <span class="keywordtype">int</span> i2 = *tab2_ptr;
              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i2 = *coeff_ptr;
<span class="comment">// Operation nulle pour les items communs et virtuels</span>
<span class="comment">// (on a annule le second membre lors de la descente)</span>
              x += coeff_i_i2 * sol_fortran[i2];
            }
<span class="comment">// Preconditionnement diagonal, pas de coefficient diagonal stocke:</span>
          *soli_ptr = ((*soli_ptr) * psi - x) * omega;
        }
      <span class="keywordflow">else</span>
        {
          assert((*soli_ptr) == 0.);
          coeff_ptr -= nvois;
          tab2_ptr -= nvois;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a83a12abf0d3d0650563cba68e988b4fd"></a><!-- doxytag: member="SSOR.cpp::traite_diagonale" ref="a83a12abf0d3d0650563cba68e988b4fd" args="(const double omega, const ArrOfInt &amp;tab1, const ArrOfInt &amp;tab2, const ArrOfDouble &amp;coeff, DoubleVect &amp;vecteur)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void traite_diagonale </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfInt.html">ArrOfInt</a> &amp;&#160;</td>
          <td class="paramname"><em>tab2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrOfDouble.html">ArrOfDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vecteur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; indexable par index fortran </p>
</p>

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00161">161</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

<p>References <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="DoubleVect_8h_source.html#l00135">DoubleVect::size_reelle()</a>, <a class="el" href="DoubleVect_8h_source.html#l00147">DoubleVect::size_reelle_ok()</a>, and <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>.</p>

<p>Referenced by <a class="el" href="SSOR_8cpp_source.html#l01530">SSOR::ssor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_lignes_a_traiter = vecteur.<a class="code" href="classDoubleVect.html#aafef4b3a96cdc428d62c5cedc9af6112">size_reelle_ok</a>() ? vecteur.<a class="code" href="classDoubleVect.html#a4a6987db458541cdcd10495955f25263" title="Taille de l&#39;espace &quot;reel&quot; du vecteur. (si md_vector_ est nul, cette valeur est identique a size_arr...">size_reelle</a>() : vecteur.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();

  <span class="keyword">const</span> <span class="keywordtype">double</span> psi = (2. - omega) / omega;
  <span class="keyword">const</span> <span class="keywordtype">double</span> *coeff_fortran = coeff.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>() - 1; <span class="comment">//!&lt; indexable par index fortran</span>
<span class="comment"></span>  <span class="keyword">const</span> <span class="keywordtype">int</span> *tab1_ptr = tab1.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordtype">double</span> *vect_ptr = vecteur.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = nb_lignes_a_traiter; i; i--, tab1_ptr++, vect_ptr++)
    {
      <span class="keyword">const</span> <span class="keywordtype">int</span> j = *tab1_ptr;
<span class="comment">// Coefficient diagonale de la ligne i:</span>
      <span class="keyword">const</span> <span class="keywordtype">double</span> coeff_i_i = coeff_fortran[j];
      (*vect_ptr) *= psi * coeff_i_i;
    }
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a15de6481f99a47c9ed659ff5adf54e64"></a><!-- doxytag: member="SSOR.cpp::SSORbases" ref="a15de6481f99a47c9ed659ff5adf54e64" args="[1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classType__info.html">Type_info</a>* <a class="el" href="SSOR_8cpp.html#a15de6481f99a47c9ed659ff5adf54e64">SSORbases</a>[1] = { &amp;( <a class="el" href="classPrecond__base.html">Precond_base</a> ::info_obj)}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SSOR_8cpp_source.html#l00036">36</a> of file <a class="el" href="SSOR_8cpp_source.html">SSOR.cpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:53 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
