<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/Math/DoubleVect.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">src/Kernel/Math/DoubleVect.h File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="ArrOfDouble_8h_source.html">ArrOfDouble.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="MD__Vector_8h_source.html">MD_Vector.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Vect_8h_source.html">Vect.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="IntVect_8h_source.html">IntVect.h</a>&gt;</code><br/>
</div>
<p><a href="DoubleVect_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoubleVect.html">DoubleVect</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a0b8b87386007101681576045bdf31c33">operator==</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;x, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">renvoie 1 si meme strucuture parallele et egalite au sens ArrOfDouble&lt;br&gt;(y compris espaces virtuels)<br/>
BM: faut-il etre aussi strict, comparer uniquement size() elements ?  <a href="#a0b8b87386007101681576045bdf31c33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#aa32e6a91569e34a88c9a2233e2c5ae9a">operator!=</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;x, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a132437a1ab5b126b0de5f4d616dd771c">local_imax_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#aa4bbbb968a6b2606c6c528249283304c">local_max_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a5a2e78375fa44b86801064bc642ebe0b">local_imin_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a6572d895c9b57a034d65d752f307c2be">local_min_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a1e2b6d58614bdc45bb6c54c5e3287ed8">mp_max_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a72e19ba68d4882194517978396f77fc0">mp_min_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a9a8060a4026204e1dacc2f95cc10f9e4">mp_somme_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a637e2dd2b5ed34c74721dd9c4f8bbf40">local_max_abs_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a53ce32b2e48a0d97c93916666c93bbe3">local_min_abs_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ae5449e885515e2c70a37894fcff91745">mp_max_abs_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a43c0f69cb4609fdea0fe9e4c35e4925d">mp_min_abs_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a2b2050de9e106e61abff20c7d582bae5">operator_add</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ac385f0ae1bb529665dcf09eaad2d078f">operator_add</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const double x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a3f9457c6edd6d6946251ccab03ba358c">operator_sub</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a12df8cf71e9387bcbbfae989349c2b34">operator_sub</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const double x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a10565642b9ebf320d150f70cb222cc17">operator_multiply</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a56ffed735faba408ceac889d86fcc9c8">operator_multiply</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const double x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#af2557f3c6aafa6b2953c27a533c98b74">operator_negate</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#adc8293ea496f2e2aabbaa2c28e92ec8c">operator_egal</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, double x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a4341a66c222e0dde395713a05e4a9c62">operator_egal</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a9fb932ffd4c01cb57ca6935c31a7b89c">local_prodscal</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.<br/>
(tous les items si pas de structure parallele, sinon voir <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>  <a href="#a9fb932ffd4c01cb57ca6935c31a7b89c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a5cf8fe0db2156b6499eec2a4b0d52b3f">mp_prodscal</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a6bef75df40b6fa1068f4206aed4a7cfe">mp_norme_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ab745de99f0f45fba28e5784a287cda44">mp_carre_norme_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ab273872cd90578d4513fffa27888735d">mp_moyenne_vect</a> (const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ac26a99ec20ecdc679cfa11ef7a7d7b40">ajoute_alpha_v</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;v, double alpha, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_REAL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a0620ee5cba3997d8ee47f8db2019a32b">ajoute_carre</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;v, double alpha, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a12d70201be38e8c4357a4df892dc21df">ajoute_produit_scalaire</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;v, double alpha, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vy, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#aad3042f6dfe021b4808b5167c1ab563a">racine_carree</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;v, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a844f83e5b5299a74a936db6385c8efe7">carre</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;v, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a3003383542201279e78ebcc2474c1e04">operator_inverse</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ad644deff922d4a657a67ecf797f01839">operator_abs</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#ae49210269147af1f1b5260d97b52af0b">tab_multiply_any_shape</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#adf24341d6901f984f55d2f6389629f72">tab_divide_any_shape</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#abd6228a44f138993e02c5689e3f4fad9">operator_divide</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;vx, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DoubleVect_8h.html#a1542d5db03f44ec6cfb02c412d00bade">operator_divide</a> (<a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;resu, const double x, <a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a> opt=VECT_ALL_ITEMS)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac26a99ec20ecdc679cfa11ef7a7d7b40"></a><!-- doxytag: member="DoubleVect.h::ajoute_alpha_v" ref="ac26a99ec20ecdc679cfa11ef7a7d7b40" args="(DoubleVect &amp;v, double alpha, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ajoute_alpha_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01531">1531</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l02309">DoubleVect::ajoute()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02315">DoubleVect::ajoute_sans_ech_esp_virt()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.addr();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu += alpha * x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0620ee5cba3997d8ee47f8db2019a32b"></a><!-- doxytag: member="DoubleVect.h::ajoute_carre" ref="a0620ee5cba3997d8ee47f8db2019a32b" args="(DoubleVect &amp;v, double alpha, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ajoute_carre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01594">1594</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.addr();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu += alpha * x * x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a12d70201be38e8c4357a4df892dc21df"></a><!-- doxytag: member="DoubleVect.h::ajoute_produit_scalaire" ref="a12d70201be38e8c4357a4df892dc21df" args="(DoubleVect &amp;v, double alpha, const DoubleVect &amp;vx, const DoubleVect &amp;vy, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ajoute_produit_scalaire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null</p>
<p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01657">1657</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
  assert(vy.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vy.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vy.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.addr();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *y_base = vy.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* y_ptr = y_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> y = *(y_ptr++);
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu += alpha * x * y;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a844f83e5b5299a74a936db6385c8efe7"></a><!-- doxytag: member="DoubleVect.h::carre" ref="a844f83e5b5299a74a936db6385c8efe7" args="(DoubleVect &amp;v, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void carre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01782">1782</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= p_resu;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aec1f3fbee9c49f94ac517feea6a8d6ed"></a><!-- doxytag: member="DoubleVect.h::local_carre_norme_vect" ref="aec1f3fbee9c49f94ac517feea6a8d6ed" args="(const DoubleVect &amp;vx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double local_carre_norme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00481">481</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l00537">mp_carre_norme_vect()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> sum = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  sum;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          sum += x * x;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  sum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a132437a1ab5b126b0de5f4d616dd771c"></a><!-- doxytag: member="DoubleVect.h::local_imax_vect" ref="a132437a1ab5b126b0de5f4d616dd771c" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_imax_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00716">716</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> max_val = (-HUGE_VALL);
  <span class="keywordtype">int</span> i_max = -1;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  i_max;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordflow">if</span> (x &gt; max_val) { i_max = x_ptr - x_base; max_val = x; }
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  i_max;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5a2e78375fa44b86801064bc642ebe0b"></a><!-- doxytag: member="DoubleVect.h::local_imin_vect" ref="a5a2e78375fa44b86801064bc642ebe0b" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int local_imin_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00603">603</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> min_val = HUGE_VALL;
  <span class="keywordtype">int</span> i_min = -1;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  i_min;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordflow">if</span> (x &lt; min_val) { i_min = x_ptr - x_base; min_val = x; }
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  i_min;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a637e2dd2b5ed34c74721dd9c4f8bbf40"></a><!-- doxytag: member="DoubleVect.h::local_max_abs_vect" ref="a637e2dd2b5ed34c74721dd9c4f8bbf40" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double local_max_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00829">829</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00837">Zone_CoviMAC::fgrad()</a>, <a class="el" href="Echange__contact__CoviMAC_8cpp_source.html#l00174">Echange_contact_CoviMAC::fgrad()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02277">mp_max_abs_vect()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l01021">Op_Conv_EF_VEF_P1NC_Stab::test_difference_Kij()</a>, <a class="el" href="Op__Conv__EF__VEF__P1NC__Stab_8cpp_source.html#l01169">Op_Conv_EF_VEF_P1NC_Stab::test_difference_resu()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01068">Schema_Temps_base::update_critere_statio()</a>, and <a class="el" href="Debog_8cpp_source.html#l00705">Debog_Pb::verifier_partie_std()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> max_val = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  max_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span> xx = fabs(x);
          max_val = (xx &gt; max_val) ? xx : max_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  max_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa4bbbb968a6b2606c6c528249283304c"></a><!-- doxytag: member="DoubleVect.h::local_max_vect" ref="aa4bbbb968a6b2606c6c528249283304c" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double local_max_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00773">773</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Op__Diff__VEF__Face__Q1_8cpp_source.html#l00069">Op_Diff_VEF_Face_Q1::calculer_dt_stab()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00107">Op_Diff_VEF_base::calculer_dt_stab()</a>, <a class="el" href="Op__Diff__PolyMAC__base_8cpp_source.html#l00063">Op_Diff_PolyMAC_base::calculer_dt_stab()</a>, <a class="el" href="Op__Diff__P1NC__barprim_8cpp_source.html#l00099">Op_Diff_P1NC_barprim::calculer_dt_stab()</a>, <a class="el" href="Op__Diff__EF__base_8cpp_source.html#l00097">Op_Diff_EF_base::calculer_dt_stab()</a>, <a class="el" href="Loi__Etat__Multi__GP__QC_8cpp_source.html#l00095">Loi_Etat_Multi_GP_QC::calculer_masse_molaire()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00201">Op_Diff_VEF_base::calculer_pour_post()</a>, <a class="el" href="Decouper_8cpp_source.html#l00224">Decouper::ecrire()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="Distanceparoi_8cpp_source.html#l00043">Distanceparoi::interpreter_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02265">mp_max_vect()</a>, <a class="el" href="Loi__Etat__Multi__GP__QC_8cpp_source.html#l00170">Loi_Etat_Multi_GP_QC::rabot()</a>, and <a class="el" href="Postraiter__domaine_8cpp_source.html#l00068">traite_bord()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> max_val = (-HUGE_VALL);
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  max_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          max_val = (x &gt; max_val) ? x : max_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  max_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a53ce32b2e48a0d97c93916666c93bbe3"></a><!-- doxytag: member="DoubleVect.h::local_min_abs_vect" ref="a53ce32b2e48a0d97c93916666c93bbe3" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double local_min_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00886">886</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, and <a class="el" href="DoubleVect_8cpp_source.html#l02283">mp_min_abs_vect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> min_val = HUGE_VALL;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  min_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span> xx = fabs(x);
          min_val = (xx &lt; min_val) ? xx : min_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  min_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6572d895c9b57a034d65d752f307c2be"></a><!-- doxytag: member="DoubleVect.h::local_min_vect" ref="a6572d895c9b57a034d65d752f307c2be" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double local_min_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00660">660</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Loi__Etat__Multi__GP__QC_8cpp_source.html#l00095">Loi_Etat_Multi_GP_QC::calculer_masse_molaire()</a>, <a class="el" href="Decouper_8cpp_source.html#l00224">Decouper::ecrire()</a>, <a class="el" href="DomaineCutter_8cpp_source.html#l01268">DomaineCutter::ecrire_zones()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02271">mp_min_vect()</a>, <a class="el" href="Loi__Etat__Multi__GP__QC_8cpp_source.html#l00170">Loi_Etat_Multi_GP_QC::rabot()</a>, and <a class="el" href="Loi__Etat__Multi__GP__WC_8cpp_source.html#l00090">Loi_Etat_Multi_GP_WC::update_Yn_values()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> min_val = HUGE_VALL;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  min_val;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          min_val = (x &lt; min_val) ? x : min_val;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  min_val;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9fb932ffd4c01cb57ca6935c31a7b89c"></a><!-- doxytag: member="DoubleVect.h::local_prodscal" ref="a9fb932ffd4c01cb57ca6935c31a7b89c" args="(const DoubleVect &amp;, const DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double local_prodscal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.<br/>
(tous les items si pas de structure parallele, sinon voir <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a> </p>

<p><p>&lt; this test is necessary if md is null</p>
<p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00419">419</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l02342">mp_prodscal()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> sum = 0;
<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = vx;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.get_md_vector() == md);
  assert(vy.line_size() == line_size);
  assert(vy.size_totale() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vy.get_md_vector() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; VECT_SEQUENTIAL_ITEMS&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      <span class="keywordflow">return</span>  sum;
    }
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.addr();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *y_base = vy.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* y_ptr = y_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keyword">const</span> <span class="keywordtype">double</span> y = *(y_ptr++);
          sum += x * y;
          x_ptr++;
        }
    }
  <span class="keywordflow">return</span>  sum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab745de99f0f45fba28e5784a287cda44"></a><!-- doxytag: member="DoubleVect.h::mp_carre_norme_vect" ref="ab745de99f0f45fba28e5784a287cda44" args="(const DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_carre_norme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00537">537</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00481">local_carre_norme_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>

<p>Referenced by <a class="el" href="RRK2_8cpp_source.html#l00145">RRK2::faire_un_pas_de_temps_eqn_base()</a>, <a class="el" href="Equation__base_8cpp_source.html#l01832">Equation_base::Gradient_conjugue_diff_impl()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02353">mp_norme_vect()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(<a class="code" href="DoubleVect_8cpp.html#aec1f3fbee9c49f94ac517feea6a8d6ed">local_carre_norme_vect</a>(vx));
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae5449e885515e2c70a37894fcff91745"></a><!-- doxytag: member="DoubleVect.h::mp_max_abs_vect" ref="ae5449e885515e2c70a37894fcff91745" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_max_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02277">2277</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00829">local_max_abs_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>.</p>

<p>Referenced by <a class="el" href="Convection__Diffusion__Espece__Multi__QC_8cpp_source.html#l00149">Convection_Diffusion_Espece_Multi_QC::assembler()</a>, <a class="el" href="Convection__Diffusion__Fluide__Dilatable__Proto_8cpp_source.html#l00203">Convection_Diffusion_Fluide_Dilatable_Proto::assembler_impl()</a>, <a class="el" href="Assembleur__P__EF_8cpp_source.html#l00137">Assembleur_P_EF::assembler_mat()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00578">Zone_EF::calculer_Bij()</a>, <a class="el" href="Sch__CN__iteratif_8cpp_source.html#l00390">Sch_CN_iteratif::convergence()</a>, <a class="el" href="Champ__Generique__Interpolation_8cpp_source.html#l00226">Champ_Generique_Interpolation::get_champ_with_calculer_champ_post()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01974">Navier_Stokes_std::impr()</a>, <a class="el" href="Navier__Stokes__Fluide__Dilatable__Proto_8cpp_source.html#l00050">Navier_Stokes_Fluide_Dilatable_Proto::impr_impl()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01486">Navier_Stokes_std::initTimeStep()</a>, <a class="el" href="Solveur__U__P_8cpp_source.html#l00061">Solveur_U_P::iterer_NS()</a>, <a class="el" href="Simpler_8cpp_source.html#l00157">Simpler::iterer_NS()</a>, <a class="el" href="Piso_8cpp_source.html#l00446">Piso::iterer_NS_PolyMAC()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01416">Navier_Stokes_std::mettre_a_jour()</a>, <a class="el" href="Piso_8cpp_source.html#l00113">test_imposer_cond_lim()</a>, <a class="el" href="Operateur__base_8cpp_source.html#l00666">Operateur_base::tester_contribuer_a_avec()</a>, <a class="el" href="Schema__Temps__base_8cpp_source.html#l01068">Schema_Temps_base::update_critere_statio()</a>, and <a class="el" href="Debog_8cpp_source.html#l00705">Debog_Pb::verifier_partie_std()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#aad339141fa6027fa3b627825a2407c12">local_max_abs_vect</a>(x, opt);
  s = <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1e2b6d58614bdc45bb6c54c5e3287ed8"></a><!-- doxytag: member="DoubleVect.h::mp_max_vect" ref="a1e2b6d58614bdc45bb6c54c5e3287ed8" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_max_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02265">2265</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00773">local_max_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00156">Process::mp_max()</a>.</p>

<p>Referenced by <a class="el" href="Terme__Source__Th__TdivU__VEF__Face_8cpp_source.html#l00156">Terme_Source_Th_TdivU_VEF_Face::ajouter()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00186">Solveur_Masse_base::ajouter_masse()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00263">Solveur_Masse_base::ajouter_masse_dt_local()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00578">Zone_EF::calculer_Bij()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00132">Zone_EF::calculer_volumes_sommets()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00360">Solveur_Masse_base::get_masse_divide_by_local_dt()</a>, <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00332">Solveur_Masse_base::get_masse_dt_local()</a>, <a class="el" href="Loi__Etat__Multi__GP__QC_8cpp_source.html#l00170">Loi_Etat_Multi_GP_QC::rabot()</a>, <a class="el" href="Operateur__base_8cpp_source.html#l00666">Operateur_base::tester_contribuer_a_avec()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">verifier()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#a6471e7e85cb0b00b67bd7ca9bb362371">local_max_vect</a>(x, opt);
  s =  <a class="code" href="classProcess.html#a1e9d9f9899b71927cfafae14c7bd048d" title="Calcule le max de x sur tous les processeurs du groupe courant. Remarques : Cette methode doit etre a...">Process::mp_max</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a43c0f69cb4609fdea0fe9e4c35e4925d"></a><!-- doxytag: member="DoubleVect.h::mp_min_abs_vect" ref="a43c0f69cb4609fdea0fe9e4c35e4925d" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_min_abs_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02283">2283</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00886">local_min_abs_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00167">Process::mp_min()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#abbb6099a23e2ab39b2308423112f6a67">local_min_abs_vect</a>(x, opt);
  s = <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_min</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a72e19ba68d4882194517978396f77fc0"></a><!-- doxytag: member="DoubleVect.h::mp_min_vect" ref="a72e19ba68d4882194517978396f77fc0" args="(const DoubleVect &amp;, Mp_vect_options opt=VECT_REAL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_min_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_REAL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02271">2271</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00660">local_min_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00167">Process::mp_min()</a>.</p>

<p>Referenced by <a class="el" href="Zone__EF_8cpp_source.html#l00578">Zone_EF::calculer_Bij()</a>, <a class="el" href="Op__Dift__VEF__Face_8cpp_source.html#l00176">Op_Dift_VEF_Face::calculer_pour_post()</a>, <a class="el" href="Op__Diff__VEF__base_8cpp_source.html#l00201">Op_Diff_VEF_base::calculer_pour_post()</a>, <a class="el" href="Op__Conv__VEF__base_8cpp_source.html#l00138">Op_Conv_VEF_base::calculer_pour_post()</a>, <a class="el" href="Zone__EF_8cpp_source.html#l00132">Zone_EF::calculer_volumes_sommets()</a>, <a class="el" href="Op__EF__base_8cpp_source.html#l00050">Op_EF_base::dimensionner()</a>, <a class="el" href="Assembleur__P__PolyMAC_8cpp_source.html#l00323">Assembleur_P_PolyMAC::modifier_solution()</a>, <a class="el" href="Loi__Etat__Multi__GP__QC_8cpp_source.html#l00170">Loi_Etat_Multi_GP_QC::rabot()</a>, and <a class="el" href="Fluide__base_8cpp_source.html#l00191">Fluide_base::verifier_coherence_champs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#a17be200c713a7031ede99b28391daa52">local_min_vect</a>(x, opt);
  s =  <a class="code" href="classProcess.html#a05de57db7288d95f9e67046af585d5ff" title="Calcule le min de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_min</a>(s);
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab273872cd90578d4513fffa27888735d"></a><!-- doxytag: member="DoubleVect.h::mp_moyenne_vect" ref="ab273872cd90578d4513fffa27888735d" args="(const DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_moyenne_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02327">2327</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00597">mp_somme_vect()</a>, <a class="el" href="classMD__Vector__base.html#a47d5867ac692b62645169eae6e2cafa0">MD_Vector_base::nb_items_seq_tot()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="Process_8cpp_source.html#l00109">Process::nproc()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, and <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>.</p>

<p>Referenced by <a class="el" href="Champ__P1__isoP1Bulle_8cpp_source.html#l00115">Champ_P1_isoP1Bulle::affecter_()</a>, <a class="el" href="Terme__Boussinesq__base_8h_source.html#l00114">Terme_Boussinesq_base::check()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00359">corriger()</a>, and <a class="el" href="Navier__Stokes__Fluide__Dilatable__Proto_8cpp_source.html#l00050">Navier_Stokes_Fluide_Dilatable_Proto::impr_impl()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> s = <a class="code" href="DoubleVect_8cpp.html#a07dd5e25d47ad3892ae0fa4e997ed011">mp_somme_vect</a>(x);
  <span class="keywordtype">double</span> n;
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = x.get_md_vector();
  <span class="keywordflow">if</span> (md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    n = md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a47d5867ac692b62645169eae6e2cafa0">nb_items_seq_tot</a>() * x.line_size();
  <span class="keywordflow">else</span>
    {
<span class="comment">// Coding error: mp_moyenne_vect is used on a not distributed DoubleVect !</span>
      assert(<a class="code" href="classProcess.html#a6bf692ce58d9578aa62ac3c07b8caaa1" title="renvoie le nombre de processeurs dans le groupe courant Voir Comm_Group::nproc() et PE_Groups::curren...">Process::nproc</a>()==1);
      n = x.size_totale();
    }
  <span class="keywordflow">return</span> s / n;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6bef75df40b6fa1068f4206aed4a7cfe"></a><!-- doxytag: member="DoubleVect.h::mp_norme_vect" ref="a6bef75df40b6fa1068f4206aed4a7cfe" args="(const DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_norme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02353">2353</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00537">mp_carre_norme_vect()</a>.</p>

<p>Referenced by <a class="el" href="Terme__Source__Qdm__lambdaup__VEF__Face_8cpp_source.html#l00163">Terme_Source_Qdm_lambdaup_VEF_Face::ajouter()</a>, <a class="el" href="Matrice__Bloc__Sym_8cpp_source.html#l00149">Matrice_Bloc_Sym::BlocSymToMatMorseSym()</a>, <a class="el" href="Champ__P1NC__implementation_8cpp_source.html#l00895">Champ_P1NC_implementation::filtrer_H1()</a>, <a class="el" href="Solv__Gmres_8cpp_source.html#l00208">gmres_local()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01382">Matrice_Morse::inverse()</a>, <a class="el" href="Simple_8cpp_source.html#l00179">Simple::iterer_eqn()</a>, <a class="el" href="Simple_8cpp_source.html#l00357">Simple::iterer_eqs()</a>, <a class="el" href="Piso_8cpp_source.html#l00134">Piso::iterer_NS()</a>, <a class="el" href="PrecondSolv_8cpp_source.html#l00056">PrecondSolv::preconditionner_()</a>, <a class="el" href="PrecondA_8cpp_source.html#l00135">PrecondA::preconditionner_()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01049">Navier_Stokes_std::projeter()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>, <a class="el" href="Solv__Petsc_8cpp_source.html#l01553">Solv_Petsc::resoudre_systeme()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00148">Solv_GCP_NS::resoudre_systeme()</a>, <a class="el" href="Champ__P1iP1B__implementation_8cpp_source.html#l00333">second_membre()</a>, <a class="el" href="Solv__Optimal_8cpp_source.html#l00050">test_un_solveur()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l02173">Navier_Stokes_std::uzawa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">verifier()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> x = <a class="code" href="DoubleVect_8cpp.html#aab5110c88e5f7519eb6b7e603130b702">mp_carre_norme_vect</a>(vx);
  x = sqrt(x);
  <span class="keywordflow">return</span> x;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5cf8fe0db2156b6499eec2a4b0d52b3f"></a><!-- doxytag: member="DoubleVect.h::mp_prodscal" ref="a5cf8fe0db2156b6499eec2a4b0d52b3f" args="(const DoubleVect &amp;, const DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_prodscal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02342">2342</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00419">local_prodscal()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>

<p>Referenced by <a class="el" href="Champ__P1NC_8cpp_source.html#l01128">Champ_P1NC::calculer_integrale_volumique()</a>, <a class="el" href="Assembleur__P__VEFPreP1B_8cpp_source.html#l00063">estim_cond()</a>, <a class="el" href="RRK2_8cpp_source.html#l00145">RRK2::faire_un_pas_de_temps_eqn_base()</a>, <a class="el" href="Solv__Gmres_8cpp_source.html#l00208">gmres_local()</a>, <a class="el" href="Equation__base_8cpp_source.html#l01832">Equation_base::Gradient_conjugue_diff_impl()</a>, <a class="el" href="Matrice__Morse_8cpp_source.html#l01184">Matrice_Morse::inverse()</a>, <a class="el" href="PrecondA_8cpp_source.html#l00135">PrecondA::preconditionner_()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>, <a class="el" href="Solv__GCP__NS_8cpp_source.html#l00148">Solv_GCP_NS::resoudre_systeme()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l02173">Navier_Stokes_std::uzawa()</a>, and <a class="el" href="AssembleurPP1BUtil_8cpp_source.html#l00146">verifier()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(<a class="code" href="DoubleVect_8cpp.html#acbe5711639fbfe2e85d5f87bf81f851a" title="Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur. (tous les items si pas d...">local_prodscal</a>(x, y));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9a8060a4026204e1dacc2f95cc10f9e4"></a><!-- doxytag: member="DoubleVect.h::mp_somme_vect" ref="a9a8060a4026204e1dacc2f95cc10f9e4" args="(const DoubleVect &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mp_somme_vect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00597">597</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8cpp_source.html#l00541">local_somme_vect()</a>, and <a class="el" href="Process_8cpp_source.html#l00178">Process::mp_sum()</a>.</p>

<p>Referenced by <a class="el" href="Perte__Charge__Singuliere_8cpp_source.html#l00382">Perte_Charge_Singuliere::calculate_Q()</a>, <a class="el" href="Zone_8cpp_source.html#l01463">Zone::calculer_mon_centre_de_gravite()</a>, <a class="el" href="Op__Conv__EF__Stab__PolyMAC__Face_8cpp_source.html#l00062">Op_Conv_EF_Stab_PolyMAC_Face::completer()</a>, <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01974">Navier_Stokes_std::impr()</a>, <a class="el" href="Source__PDF__EF_8cpp_source.html#l01039">Source_PDF_EF::impr()</a>, <a class="el" href="Navier__Stokes__Fluide__Dilatable__Proto_8cpp_source.html#l00050">Navier_Stokes_Fluide_Dilatable_Proto::impr_impl()</a>, <a class="el" href="Domaine_8cpp_source.html#l00529">Domaine::imprimer()</a>, <a class="el" href="Zone__CoviMAC_8cpp_source.html#l00662">Zone_CoviMAC::init_equiv()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l01059">Zone_PolyMAC::init_m2()</a>, <a class="el" href="Perte__Charge__Singuliere_8cpp_source.html#l00127">Perte_Charge_Singuliere::lire_surfaces()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02327">mp_moyenne_vect()</a>, <a class="el" href="Zone__PolyMAC_8cpp_source.html#l00573">Zone_PolyMAC::orthocentrer()</a>, <a class="el" href="DP__Impose__PolyMAC__Face_8cpp_source.html#l00065">DP_Impose_PolyMAC_Face::remplir_num_faces()</a>, and <a class="el" href="DP__Impose__CoviMAC__Face_8cpp_source.html#l00065">DP_Impose_CoviMAC_Face::remplir_num_faces()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> x = <a class="code" href="DoubleVect_8cpp.html#aaaede7053cdab4cd6f12f0fa2c065e37">local_somme_vect</a>(vx);
  <span class="keywordtype">double</span> y = <a class="code" href="classProcess.html#a7d23bc1ef94b3f0623fbc79d034c27fd" title="Calcule la somme de x sur tous les processeurs du groupe courant. Voir aussi mp_max()">Process::mp_sum</a>(x);
  <span class="keywordflow">return</span> y;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa32e6a91569e34a88c9a2233e2c5ae9a"></a><!-- doxytag: member="DoubleVect.h::operator!=" ref="aa32e6a91569e34a88c9a2233e2c5ae9a" args="(const DoubleVect &amp;x, const DoubleVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00364">364</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> !(x == y);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0b8b87386007101681576045bdf31c33"></a><!-- doxytag: member="DoubleVect.h::operator==" ref="a0b8b87386007101681576045bdf31c33" args="(const DoubleVect &amp;x, const DoubleVect &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>renvoie 1 si meme strucuture parallele et egalite au sens ArrOfDouble&lt;br&gt;(y compris espaces virtuels)<br/>
BM: faut-il etre aussi strict, comparer uniquement size() elements ? </p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00355">355</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!(x.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == y.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>()))
    <span class="keywordflow">return</span> 0;
  <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; ax = x;
  <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; ay = y;
  <span class="keywordflow">return</span> ax == ay;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad644deff922d4a657a67ecf797f01839"></a><!-- doxytag: member="DoubleVect.h::operator_abs" ref="ad644deff922d4a657a67ecf797f01839" args="(DoubleVect &amp;resu, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00943">943</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l02297">DoubleVect::abs()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu = fabs(p_resu);
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b2050de9e106e61abff20c7d582bae5"></a><!-- doxytag: member="DoubleVect.h::operator_add" ref="a2b2050de9e106e61abff20c7d582bae5" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l00999">999</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Navier__Stokes__Fluide__Dilatable__Proto_8cpp_source.html#l00445">Navier_Stokes_Fluide_Dilatable_Proto::correct_and_compute_u_np1()</a>, <a class="el" href="Simpler_8cpp_source.html#l00157">Simpler::iterer_NS()</a>, <a class="el" href="IntVect_8cpp_source.html#l01609">IntVect::operator+=()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02241">DoubleVect::operator+=()</a>, and <a class="el" href="Navier__Stokes__std_8cpp_source.html#l01185">Navier_Stokes_std::preparer_calcul()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu += x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac385f0ae1bb529665dcf09eaad2d078f"></a><!-- doxytag: member="DoubleVect.h::operator_add" ref="ac385f0ae1bb529665dcf09eaad2d078f" args="(DoubleVect &amp;resu, const double x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01062">1062</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu += x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abd6228a44f138993e02c5689e3f4fad9"></a><!-- doxytag: member="DoubleVect.h::operator_divide" ref="abd6228a44f138993e02c5689e3f4fad9" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01838">1838</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="DoubleVect_8cpp_source.html#l02289">DoubleVect::operator/=()</a>, and <a class="el" href="DoubleVect_8cpp_source.html#l02127">tab_divide_any_shape()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          <span class="keywordflow">if</span> (x==0) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::operator_divide()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
          p_resu /= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1542d5db03f44ec6cfb02c412d00bade"></a><!-- doxytag: member="DoubleVect.h::operator_divide" ref="a1542d5db03f44ec6cfb02c412d00bade" args="(DoubleVect &amp;resu, const double x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02151">2151</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          <span class="keywordflow">if</span>(x==0.) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error: divide by 0 in operator_divide.&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
          p_resu /= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adc8293ea496f2e2aabbaa2c28e92ec8c"></a><!-- doxytag: member="DoubleVect.h::operator_egal" ref="adc8293ea496f2e2aabbaa2c28e92ec8c" args="(DoubleVect &amp;resu, double x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_egal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01412">1412</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="T__It__VDF__Elem_8h_source.html#l00754">T_It_VDF_Elem&lt; _TYPE_ &gt;::calculer()</a>, <a class="el" href="T__It__PolyMAC__Elem_8h_source.html#l01041">T_It_PolyMAC_Elem&lt; _TYPE_ &gt;::calculer()</a>, <a class="el" href="Zone__VEF__PreP1b_8cpp_source.html#l00061">Zone_VEF_PreP1b::discretiser()</a>, <a class="el" href="Champ__Q1NC_8cpp_source.html#l00161">Champ_Q1NC::gradient()</a>, <a class="el" href="Champ__Q1__EF_8cpp_source.html#l00127">Champ_Q1_EF::gradient()</a>, <a class="el" href="Navier__Stokes__Fluide__Dilatable__Proto_8cpp_source.html#l00050">Navier_Stokes_Fluide_Dilatable_Proto::impr_impl()</a>, <a class="el" href="Matrice__Morse__Sym_8cpp_source.html#l00266">Matrice_Morse_Sym::multvect_et_prodscal()</a>, <a class="el" href="SSOR_8cpp_source.html#l00116">SSOR::preconditionner_()</a>, and <a class="el" href="PrecondSolv_8cpp_source.html#l00056">PrecondSolv::preconditionner_()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu = x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4341a66c222e0dde395713a05e4a9c62"></a><!-- doxytag: member="DoubleVect.h::operator_egal" ref="a4341a66c222e0dde395713a05e4a9c62" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_egal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01468">1468</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu = x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3003383542201279e78ebcc2474c1e04"></a><!-- doxytag: member="DoubleVect.h::operator_inverse" ref="a3003383542201279e78ebcc2474c1e04" args="(DoubleVect &amp;resu, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01902">1902</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          <span class="keywordflow">if</span> (p_resu==0) { <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::operateur_inverse()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>; <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();};
          p_resu = 1. / p_resu;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a10565642b9ebf320d150f70cb222cc17"></a><!-- doxytag: member="DoubleVect.h::operator_multiply" ref="a10565642b9ebf320d150f70cb222cc17" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01237">1237</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="IntVect_8cpp_source.html#l01617">IntVect::operator*=()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02249">DoubleVect::operator*=()</a>, <a class="el" href="PrecondSolv_8cpp_source.html#l00056">PrecondSolv::preconditionner_()</a>, <a class="el" href="PrecondA_8cpp_source.html#l00135">PrecondA::preconditionner_()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02127">tab_divide_any_shape()</a>, and <a class="el" href="DoubleVect_8cpp_source.html#l02107">tab_multiply_any_shape()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a56ffed735faba408ceac889d86fcc9c8"></a><!-- doxytag: member="DoubleVect.h::operator_multiply" ref="a56ffed735faba408ceac889d86fcc9c8" args="(DoubleVect &amp;resu, const double x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01300">1300</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu *= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af2557f3c6aafa6b2953c27a533c98b74"></a><!-- doxytag: member="DoubleVect.h::operator_negate" ref="af2557f3c6aafa6b2953c27a533c98b74" args="(DoubleVect &amp;resu, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_negate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01356">1356</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="Operateur__Grad__base_8cpp_source.html#l00096">Operateur_Grad_base::multvect()</a>, <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>, and <a class="el" href="Navier__Stokes__Fluide__Dilatable__Proto_8cpp_source.html#l00397">Navier_Stokes_Fluide_Dilatable_Proto::solve_pressure_increment()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu = -p_resu;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3f9457c6edd6d6946251ccab03ba358c"></a><!-- doxytag: member="DoubleVect.h::operator_sub" ref="a3f9457c6edd6d6946251ccab03ba358c" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; this test is necessary if md is null </p>
</p>

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01118">1118</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>

<p>Referenced by <a class="el" href="IntVect_8cpp_source.html#l01613">IntVect::operator-=()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l02245">DoubleVect::operator-=()</a>, and <a class="el" href="Solv__GCP_8cpp_source.html#l00404">Solv_GCP::resoudre_()</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
  assert(vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == line_size);
  assert(vx.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>() == vect_size_tot); <span class="comment">//!&lt; this test is necessary if md is null</span>
<span class="comment"></span>  assert(vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>() == md);
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keyword">const</span> <span class="keywordtype">double</span> *x_base = vx.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keyword">const</span> <span class="keywordtype">double</span>* x_ptr = x_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keyword">const</span> <span class="keywordtype">double</span> x = *x_ptr;
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu -= x;
          x_ptr++;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a12df8cf71e9387bcbbfae989349c2b34"></a><!-- doxytag: member="DoubleVect.h::operator_sub" ref="a12df8cf71e9387bcbbfae989349c2b34" args="(DoubleVect &amp;resu, const double x, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01181">1181</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu -= x;
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aad3042f6dfe021b4808b5167c1ab563a"></a><!-- doxytag: member="DoubleVect.h::racine_carree" ref="aad3042f6dfe021b4808b5167c1ab563a" args="(DoubleVect &amp;v, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void racine_carree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l01726">1726</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="ArrOfDouble_8h_source.html#l00379">ArrOfDouble::addr()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00371">ArrOfInt::addr()</a>, <a class="el" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">MD_Vector_base::get_items_to_compute()</a>, <a class="el" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">MD_Vector_base::get_items_to_sum()</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l00379">invalidate_data()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="ArrOfInt_8h_source.html#l00342">ArrOfInt::size_array()</a>, <a class="el" href="DoubleVect_8h_source.html#l00159">DoubleVect::size_totale()</a>, <a class="el" href="MD__Vector_8h_source.html#l00067">MD_Vector::valeur()</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_ALL_ITEMS</a>, <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_REAL_ITEMS</a>, and <a class="el" href="MD__Vector_8h_source.html#l00033">VECT_SEQUENTIAL_ITEMS</a>.</p>
<div class="fragment"><pre class="fragment">{

<span class="comment">// Master vect donne la structure de reference, les autres vecteurs</span>
<span class="comment">// doivent avoir la meme structure.</span>
  <span class="keyword">const</span> <a class="code" href="classDoubleVect.html">DoubleVect</a>&amp; master_vect = resu;
  <span class="keywordtype">int</span> line_size = master_vect.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>();
  <span class="keyword">const</span> <a class="code" href="classMD__Vector.html" title=": Cette classe est un DERIV mais l&#39;objet pointe est partage entre plusieurs instances de cette classe...">MD_Vector</a>&amp; md = master_vect.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>();
  <span class="keyword">const</span> <span class="keywordtype">int</span> vect_size_tot = master_vect.<a class="code" href="classDoubleVect.html#ad2d21b364e1c6559771970596a25c006" title="Identique a size_array()">size_totale</a>();
<span class="comment">// Determine blocs of data to process, depending on &quot; opt&quot;</span>
  <span class="keywordtype">int</span> nblocs_left = 1;
  <span class="keywordtype">int</span> one_bloc[2];
  <span class="keyword">const</span> <span class="keywordtype">int</span> *bloc_ptr;
  <span class="keywordflow">if</span> ( opt != <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caad18680091a9f62247573cb3caa6450b9">VECT_ALL_ITEMS</a> &amp;&amp; md.<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
      assert( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a> ||  opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caab47906d8d2e6c20f8ba32e4acb6edbe0">VECT_REAL_ITEMS</a>);
      <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; items_blocs = ( opt == <a class="code" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11caa062d2da55e5c71ec3a38b1ebaeae57bd">VECT_SEQUENTIAL_ITEMS</a>) ? md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a7f6b6d0b7babfec0cce590cdea5bca53">get_items_to_sum</a>() : md.<a class="code" href="classMD__Vector.html#a41324dfaa7a973091d0a8276908d10e2">valeur</a>().<a class="code" href="classMD__Vector__base.html#a99334ac2566d9457c8d4890ba20883ea">get_items_to_compute</a>();
      assert(items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() % 2 == 0);
      nblocs_left = items_blocs.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() &gt;&gt; 1;
      bloc_ptr = items_blocs.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>();
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vect_size_tot &gt; 0)
    {
<span class="comment">// attention, si vect_size_tot est nul, line_size a le droit d&#39;etre nul</span>
<span class="comment">// Compute all data, in the vector (including virtual data), build a big bloc:</span>
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// raccourci pour les tableaux vides (evite le cas particulier line_size == 0)</span>
      return ;
    }
  <span class="keywordtype">double</span> *resu_base = resu.addr();
  <span class="keywordflow">for</span> (; nblocs_left; nblocs_left--)
    {
<span class="comment">// Get index of next bloc start:</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> begin_bloc = (*(bloc_ptr++)) * line_size;
      <span class="keyword">const</span> <span class="keywordtype">int</span> end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc &gt;= 0 &amp;&amp; end_bloc &lt;= vect_size_tot &amp;&amp; end_bloc &gt;= begin_bloc);
      <span class="keywordtype">double</span>* resu_ptr = resu_base + begin_bloc;
      <span class="keywordtype">int</span> count = end_bloc - begin_bloc;
      <span class="keywordflow">for</span> (; count; count--)
        {
          <span class="keywordtype">double</span>&amp; p_resu = *(resu_ptr++);
          p_resu = sqrt(p_resu);
        }
    }
<span class="comment">// In debug mode, put invalid values where data has not been computed</span>
<span class="preprocessor">#ifndef NDEBUG</span>
<span class="preprocessor"></span>  <a class="code" href="DoubleVect_8cpp.html#ad4995bc506ff841ba67ce56a43886902">invalidate_data</a>(resu,  opt);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  return ;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adf24341d6901f984f55d2f6389629f72"></a><!-- doxytag: member="DoubleVect.h::tab_divide_any_shape" ref="adf24341d6901f984f55d2f6389629f72" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tab_divide_any_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02127">2127</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="EntreeSortie_8h_source.html#l00032">Cerr</a>, <a class="el" href="Process_8cpp_source.html#l00223">Process::exit()</a>, <a class="el" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>, <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01838">operator_divide()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01237">operator_multiply()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="DoubleVect_8cpp_source.html#l02029">tab_divide_any_shape_()</a>.</p>

<p>Referenced by <a class="el" href="Solveur__Masse__base_8cpp_source.html#l00149">Solveur_Masse_base::appliquer()</a>, <a class="el" href="Milieu__base_8cpp_source.html#l00365">Milieu_base::calculer_alpha()</a>, <a class="el" href="Champ__Q1NC_8cpp_source.html#l00161">Champ_Q1NC::gradient()</a>, and <a class="el" href="Modifier__pour__fluide__dilatable_8cpp_source.html#l00028">multiplier_ou_diviser()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (vx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 1 &amp;&amp; !vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
<span class="comment">// Produit par une constante</span>
      <span class="keywordflow">if</span> (vx[0]==0)
        {
          <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;Divide by 0 in DoubleVect::tab_divide_any_shape()&quot;</span> &lt;&lt; <a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
          <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
        }
      <span class="keywordtype">double</span> x = 1. / vx[0];
      <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(resu, x, opt);
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>())
    {
<span class="comment">// Produit membre a membre</span>
      <a class="code" href="DoubleVect_8cpp.html#a57c531f3142293f375a0cc2f61d7b949">operator_divide</a>(resu, vx, opt);
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Cas general</span>
      <a class="code" href="DoubleVect_8cpp.html#a88505992fa9b63ac41d37e84e1d5efdb">tab_divide_any_shape_</a>(resu, vx, opt);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae49210269147af1f1b5260d97b52af0b"></a><!-- doxytag: member="DoubleVect.h::tab_multiply_any_shape" ref="ae49210269147af1f1b5260d97b52af0b" args="(DoubleVect &amp;resu, const DoubleVect &amp;vx, Mp_vect_options opt=VECT_ALL_ITEMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tab_multiply_any_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>resu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoubleVect.html">DoubleVect</a> &amp;&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MD__Vector_8h.html#a3616a15fe105ad6150819554ee8b11ca">Mp_vect_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code>VECT_ALL_ITEMS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="DoubleVect_8cpp_source.html#l02107">2107</a> of file <a class="el" href="DoubleVect_8cpp_source.html">DoubleVect.cpp</a>.</p>

<p>References <a class="el" href="DoubleVect_8h_source.html#l00101">DoubleVect::get_md_vector()</a>, <a class="el" href="DoubleVect_8h_source.html#l00164">DoubleVect::line_size()</a>, <a class="el" href="MD__Vector_8h_source.html#l00063">MD_Vector::non_nul()</a>, <a class="el" href="DoubleVect_8cpp_source.html#l01237">operator_multiply()</a>, <a class="el" href="ArrOfDouble_8h_source.html#l00350">ArrOfDouble::size_array()</a>, and <a class="el" href="DoubleVect_8cpp_source.html#l01959">tab_multiply_any_shape_()</a>.</p>

<p>Referenced by <a class="el" href="Masse__PolyMAC__Face_8cpp_source.html#l00208">Masse_PolyMAC_Face::appliquer_coef()</a>, <a class="el" href="Masse__PolyMAC__Elem_8cpp_source.html#l00190">Masse_PolyMAC_Elem::appliquer_coef()</a>, <a class="el" href="Masse__Multiphase_8cpp_source.html#l00327">Masse_Multiphase::calculer_alpha_rho()</a>, <a class="el" href="Equation__base_8cpp_source.html#l02426">Equation_base::calculer_champ_conserve()</a>, <a class="el" href="Op__Diff__VEFP1NCP1B__Face_8cpp_source.html#l01093">Op_Diff_VEFP1NCP1B_Face::corriger_pour_diffusivite()</a>, <a class="el" href="Porosites__champ_8cpp_source.html#l00035">modif_par_porosite_si_flag()</a>, <a class="el" href="Modifier__pour__fluide__dilatable_8cpp_source.html#l00028">multiplier_ou_diviser()</a>, <a class="el" href="Fluide__Dilatable__base_8cpp_source.html#l00261">Fluide_Dilatable_base::update_rho_cp()</a>, and <a class="el" href="Milieu__base_8cpp_source.html#l00412">Milieu_base::update_rho_cp()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (vx.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>() == 1 &amp;&amp; !vx.<a class="code" href="classDoubleVect.html#a0d16d30580c90526e4895388fb44be5d">get_md_vector</a>().<a class="code" href="classMD__Vector.html#a4165c00904b7096274e38fdc7ca340f4">non_nul</a>())
    {
<span class="comment">// Produit par une constante</span>
      <span class="keywordtype">double</span> x = vx[0];
      <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(resu, x, opt);
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vx.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>() == resu.<a class="code" href="classDoubleVect.html#ab02d01cd1bdab66fbd66f9a47cc29e10">line_size</a>())
    {
<span class="comment">// Produit membre a membre</span>
      <a class="code" href="DoubleVect_8cpp.html#a2b776b5741992c8b6069737fe41b1298">operator_multiply</a>(resu, vx, opt);
    }
  <span class="keywordflow">else</span>
    {
<span class="comment">// Cas general</span>
      <a class="code" href="DoubleVect_8cpp.html#afbe9258caf70f44a5efec3fb1d5d6001">tab_multiply_any_shape_</a>(resu, vx, opt);
    }
}
</pre></div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:52 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
