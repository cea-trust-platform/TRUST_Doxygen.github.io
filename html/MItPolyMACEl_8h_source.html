<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/PolyMAC/Operateurs/Conv_iterateur/MItPolyMACEl.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/PolyMAC/Operateurs/Conv_iterateur/MItPolyMACEl.h</div>  </div>
</div>
<div class="contents">
<a href="MItPolyMACEl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        MItPolyMACEl.h</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/PolyMAC/Operateurs/Conv_iterateur</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     /main/43</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef MItPolyMAC_El_H</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#define MItPolyMAC_El_H</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Equation__base_8h.html">Equation_base.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Milieu__base_8h.html">Milieu_base.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Uniforme_8h.html">Champ_Uniforme.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Debog_8h.html">Debog.h</a>&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="Probleme__base_8h.html">Probleme_base.h</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="Schema__Temps__base_8h.html">Schema_Temps_base.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="Operateur__base_8h.html">Operateur_base.h</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="Operateur__Diff__base_8h.html">Operateur_Diff_base.h</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="Op__Conv__PolyMAC__iterateur__base_8h.html">Op_Conv_PolyMAC_iterateur_base.h</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="EcrFicPartage_8h.html">EcrFicPartage.h</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="communications_8h.html">communications.h</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="DoubleTrav_8h.html">DoubleTrav.h</a>&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment">// </span>
<a name="l00043"></a>00043 <span class="comment">// CLASS Iterateur_PolyMAC_Elem</span>
<a name="l00044"></a>00044 <span class="comment">// </span>
<a name="l00045"></a>00045 <span class="comment">//</span>
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="MItPolyMACEl_8h.html#a0e577741775544668e2fb23e7809d45e">00047</a> <span class="preprocessor">#define declare_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l00048"></a>00048 <span class="preprocessor">  class It_PolyMAC_Elem(_TYPE_) : public Iterateur_PolyMAC_base                        \</span>
<a name="l00049"></a>00049 <span class="preprocessor">  {                                                                        \</span>
<a name="l00050"></a>00050 <span class="preprocessor">    Declare_instanciable(It_PolyMAC_Elem(_TYPE_));                                \</span>
<a name="l00051"></a>00051 <span class="preprocessor">  public:                                                                \</span>
<a name="l00052"></a>00052 <span class="preprocessor">    inline It_PolyMAC_Elem(_TYPE_)(const It_PolyMAC_Elem(_TYPE_)&amp; );                \</span>
<a name="l00053"></a>00053 <span class="preprocessor">    inline Evaluateur_PolyMAC&amp; evaluateur();                                \</span>
<a name="l00054"></a>00054 <span class="preprocessor">    inline const Evaluateur_PolyMAC&amp; evaluateur() const;                        \</span>
<a name="l00055"></a>00055 <span class="preprocessor">    DoubleTab&amp; calculer(const DoubleTab&amp; , DoubleTab&amp; ) const;                \</span>
<a name="l00056"></a>00056 <span class="preprocessor">    DoubleTab&amp; ajouter(const DoubleTab&amp;, DoubleTab&amp; ) const;                \</span>
<a name="l00057"></a>00057 <span class="preprocessor">    void calculer_flux_bord(const DoubleTab&amp;) const; \</span>
<a name="l00058"></a>00058 <span class="preprocessor">    void contribuer_au_second_membre(DoubleTab&amp; ) const;                \</span>
<a name="l00059"></a>00059 <span class="preprocessor">    void ajouter_contribution(const DoubleTab&amp;, Matrice_Morse&amp; ) const;        \</span>
<a name="l00060"></a>00060 <span class="preprocessor">    inline void completer_();                                                \</span>
<a name="l00061"></a>00061 <span class="preprocessor">    int impr(Sortie&amp; os) const;                                                \</span>
<a name="l00062"></a>00062 <span class="preprocessor">    void modifier_flux() const;                                                \</span>
<a name="l00063"></a>00063 <span class="preprocessor">  protected:                                                                \</span>
<a name="l00064"></a>00064 <span class="preprocessor">    _TYPE_ flux_evaluateur;                                                \</span>
<a name="l00065"></a>00065 <span class="preprocessor">    DoubleTab&amp; ajouter_bords(const DoubleTab&amp; , DoubleTab&amp; ) const;        \</span>
<a name="l00066"></a>00066 <span class="preprocessor">    DoubleTab&amp; ajouter_bords(const DoubleTab&amp; , DoubleTab&amp; , int ) const; \</span>
<a name="l00067"></a>00067 <span class="preprocessor">    DoubleTab&amp; ajouter_interne(const DoubleTab&amp; , DoubleTab&amp; ) const;        \</span>
<a name="l00068"></a>00068 <span class="preprocessor">    DoubleTab&amp; ajouter_interne(const DoubleTab&amp; , DoubleTab&amp; , int ) const; \</span>
<a name="l00069"></a>00069 <span class="preprocessor">    void contribuer_au_second_membre_bords(DoubleTab&amp; ) const;                \</span>
<a name="l00070"></a>00070 <span class="preprocessor">    void contribuer_au_second_membre_bords(DoubleTab&amp; , int ) const;        \</span>
<a name="l00071"></a>00071 <span class="preprocessor">    void contribuer_au_second_membre_interne(DoubleTab&amp; ) const;        \</span>
<a name="l00072"></a>00072 <span class="preprocessor">    void contribuer_au_second_membre_interne(DoubleTab&amp;, int ) const;        \</span>
<a name="l00073"></a>00073 <span class="preprocessor">    void ajouter_contribution_bords(const DoubleTab&amp;, Matrice_Morse&amp; ) const; \</span>
<a name="l00074"></a>00074 <span class="preprocessor">    void ajouter_contribution_bords(const DoubleTab&amp;, Matrice_Morse&amp;, int ) const; \</span>
<a name="l00075"></a>00075 <span class="preprocessor">    void ajouter_contribution_interne(const DoubleTab&amp;, Matrice_Morse&amp; ) const;        \</span>
<a name="l00076"></a>00076 <span class="preprocessor">    void ajouter_contribution_interne(const DoubleTab&amp;, Matrice_Morse&amp;, int ) const; \</span>
<a name="l00077"></a>00077 <span class="preprocessor">    const Milieu_base&amp; milieu() const;                                        \</span>
<a name="l00078"></a>00078 <span class="preprocessor">    IntTab elem;                                                        \</span>
<a name="l00079"></a>00079 <span class="preprocessor">  };                                                                        \</span>
<a name="l00080"></a>00080 <span class="preprocessor">  inline It_PolyMAC_Elem(_TYPE_)::It_PolyMAC_Elem(_TYPE_)(const It_PolyMAC_Elem(_TYPE_)&amp; iter) \</span>
<a name="l00081"></a>00081 <span class="preprocessor">    :Iterateur_PolyMAC_base(iter),                                                \</span>
<a name="l00082"></a>00082 <span class="preprocessor">     flux_evaluateur(iter.flux_evaluateur)                                \</span>
<a name="l00083"></a>00083 <span class="preprocessor">  {                                                                        \</span>
<a name="l00084"></a>00084 <span class="preprocessor">    elem.ref(iter.elem);                                                \</span>
<a name="l00085"></a>00085 <span class="preprocessor">  }                                                                        \</span>
<a name="l00086"></a>00086 <span class="preprocessor">  inline Evaluateur_PolyMAC&amp; It_PolyMAC_Elem(_TYPE_)::evaluateur()                \</span>
<a name="l00087"></a>00087 <span class="preprocessor">  {                                                                        \</span>
<a name="l00088"></a>00088 <span class="preprocessor">    Evaluateur_PolyMAC&amp; eval = (Evaluateur_PolyMAC&amp;) flux_evaluateur;                \</span>
<a name="l00089"></a>00089 <span class="preprocessor">    return eval;                                                        \</span>
<a name="l00090"></a>00090 <span class="preprocessor">  }                                                                        \</span>
<a name="l00091"></a>00091 <span class="preprocessor">  inline const Evaluateur_PolyMAC&amp; It_PolyMAC_Elem(_TYPE_)::evaluateur() const        \</span>
<a name="l00092"></a>00092 <span class="preprocessor">  {                                                                        \</span>
<a name="l00093"></a>00093 <span class="preprocessor">    Evaluateur_PolyMAC&amp; eval = (Evaluateur_PolyMAC&amp;) flux_evaluateur;                \</span>
<a name="l00094"></a>00094 <span class="preprocessor">    return eval;                                                        \</span>
<a name="l00095"></a>00095 <span class="preprocessor">  }</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a><a class="code" href="MItPolyMACEl_8h.html#af60f39598dbff4408007938cb0db9257">00097</a> <span class="preprocessor">#define implemente1_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l00098"></a>00098 <span class="preprocessor">  Implemente_instanciable(It_PolyMAC_Elem(_TYPE_),&quot;Iterateur_PolyMAC_Elem&quot;,Iterateur_PolyMAC_base);        \</span>
<a name="l00099"></a>00099 <span class="preprocessor">  Sortie&amp; It_PolyMAC_Elem(_TYPE_)::printOn(Sortie&amp; s ) const {                \</span>
<a name="l00100"></a>00100 <span class="preprocessor">    return s &lt;&lt; que_suis_je() ;                                                \</span>
<a name="l00101"></a>00101 <span class="preprocessor">  }                                                                        \</span>
<a name="l00102"></a>00102 <span class="preprocessor">  Entree&amp; It_PolyMAC_Elem(_TYPE_)::readOn(Entree&amp; s ) {                        \</span>
<a name="l00103"></a>00103 <span class="preprocessor">    return s ;                                                                \</span>
<a name="l00104"></a>00104 <span class="preprocessor">  }                                                                        \</span>
<a name="l00105"></a>00105 <span class="preprocessor">  inline void It_PolyMAC_Elem(_TYPE_)::completer_(){                        \</span>
<a name="l00106"></a>00106 <span class="preprocessor">    elem.ref(la_zone-&gt;face_voisins());                                        \</span>
<a name="l00107"></a>00107 <span class="preprocessor">  }                                                                        \</span>
<a name="l00108"></a>00108 <span class="preprocessor">  const Milieu_base&amp; It_PolyMAC_Elem(_TYPE_)::milieu() const{                \</span>
<a name="l00109"></a>00109 <span class="preprocessor">    return (la_zcl-&gt;equation()).milieu();                                \</span>
<a name="l00110"></a>00110 <span class="preprocessor">  }                                                                        \</span>
<a name="l00111"></a>00111 <span class="preprocessor">  DoubleTab&amp; It_PolyMAC_Elem(_TYPE_)::ajouter(const DoubleTab&amp; donne,        \</span>
<a name="l00112"></a>00112 <span class="preprocessor">                                          DoubleTab&amp; resu) const        \</span>
<a name="l00113"></a>00113 <span class="preprocessor">  {                                                                        \</span>
<a name="l00114"></a>00114 <span class="preprocessor">    ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();                        \</span>
<a name="l00115"></a>00115 <span class="preprocessor">    assert(donne.nb_dim() &lt; 3);                                                \</span>
<a name="l00116"></a>00116 <span class="preprocessor">    assert(la_zcl.non_nul());                                                \</span>
<a name="l00117"></a>00117 <span class="preprocessor">    assert(la_zone.non_nul());                                                \</span>
<a name="l00118"></a>00118 <span class="preprocessor">    int ncomp=1;                                                        \</span>
<a name="l00119"></a>00119 <span class="preprocessor">    if (donne.nb_dim() == 2)                                                \</span>
<a name="l00120"></a>00120 <span class="preprocessor">      ncomp=donne.dimension(1);                                                \</span>
<a name="l00121"></a>00121 <span class="preprocessor">    DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \</span>
<a name="l00122"></a>00122 <span class="preprocessor">    flux_bords.resize(la_zone-&gt;nb_faces_bord(),ncomp);                        \</span>
<a name="l00123"></a>00123 <span class="preprocessor">    flux_bords=0;                                                        \</span>
<a name="l00124"></a>00124 <span class="preprocessor">    </span><span class="comment">/* modif b.m.: on va faire += sur des items virtuels, initialiser les cases */</span> \
<a name="l00125"></a>00125     <span class="comment">/* sinon risque que les cases soient invalides ou non initialisees */</span> \
<a name="l00126"></a>00126     {                                                                        \
<a name="l00127"></a>00127       int n = resu.size_array() - resu.size();                        \
<a name="l00128"></a>00128       double *data = resu.addr() + resu.size();                                \
<a name="l00129"></a>00129       for (; n; n--, data++)                                                \
<a name="l00130"></a>00130         *data = 0.;                                                        \
<a name="l00131"></a>00131     }                                                                        \
<a name="l00132"></a>00132     if( ncomp == 1) <span class="comment">/* cas scalaire */</span>                                        \
<a name="l00133"></a>00133       {                                                                        \
<a name="l00134"></a>00134         ajouter_bords(donne, resu) ;                                        \
<a name="l00135"></a>00135         ajouter_interne(donne, resu) ;                                        \
<a name="l00136"></a>00136       }                                                                        \
<a name="l00137"></a>00137     else <span class="comment">/* cas vectoriel */</span>                                                \
<a name="l00138"></a>00138       {                                                                        \
<a name="l00139"></a>00139         ajouter_bords(donne, resu, ncomp) ;                                \
<a name="l00140"></a>00140         ajouter_interne(donne, resu, ncomp) ;                                \
<a name="l00141"></a>00141       }                                                                        \
<a name="l00142"></a>00142     modifier_flux() ;                                                        \
<a name="l00143"></a>00143     return resu;                                                        \
<a name="l00144"></a>00144   }                                                                        \
<a name="l00145"></a>00145   DoubleTab&amp; It_PolyMAC_Elem(_TYPE_)::ajouter_bords(const DoubleTab&amp; donnee, \
<a name="l00146"></a>00146                                                 DoubleTab&amp; resu) const        \
<a name="l00147"></a>00147   {                                                                        \
<a name="l00148"></a>00148      int elem1, elem2;                                                        \
<a name="l00149"></a>00149     int ndeb, nfin;                                                        \
<a name="l00150"></a>00150     int face;                                                                \
<a name="l00151"></a>00151     int num_cl=0;                                                        \
<a name="l00152"></a>00152     double flux;                                                        \
<a name="l00153"></a>00153     int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \
<a name="l00154"></a>00154     DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \
<a name="l00155"></a>00155     for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \
<a name="l00156"></a>00156       <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>                \
<a name="l00157"></a>00157       const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \
<a name="l00158"></a>00158       const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \
<a name="l00159"></a>00159       ndeb = frontiere_dis.num_premiere_face();                                \
<a name="l00160"></a>00160       nfin = ndeb + frontiere_dis.nb_faces();                                \
<a name="l00161"></a>00161       <span class="comment">/* Test en bidim axi */</span>                                                \
<a name="l00162"></a>00162       if (bidim_axi &amp;&amp; !sub_type(Symetrie,la_cl.valeur()))                \
<a name="l00163"></a>00163         {                                                                \
<a name="l00164"></a>00164           if (nfin&gt;ndeb &amp;&amp; est_egal(la_zone.valeur().face_surfaces()[ndeb],0)) \
<a name="l00165"></a>00165             {                                                                \
<a name="l00166"></a>00166               Cerr &lt;&lt; &quot;Error in the definition of the boundary conditions.&quot; &lt;&lt; finl; \
<a name="l00167"></a>00167               Cerr &lt;&lt; &quot;The axis of revolution for this 2D calculation is along Y.&quot; &lt;&lt; finl; \
<a name="l00168"></a>00168               Cerr &lt;&lt; &quot;So you must specify symmetry for the boundary &quot; &lt;&lt; frontiere_dis.le_nom() &lt;&lt; finl; \
<a name="l00169"></a>00169               exit();                                                        \
<a name="l00170"></a>00170             }                                                                \
<a name="l00171"></a>00171         }                                                                \
<a name="l00172"></a>00172       switch(type_cl(la_cl)){                                                \
<a name="l00173"></a>00173       case symetrie :                                                        \
<a name="l00174"></a>00174         if (flux_evaluateur.calculer_flux_faces_symetrie()){            \
<a name="l00175"></a>00175           const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \
<a name="l00176"></a>00176           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00177"></a>00177             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00178"></a>00178             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00179"></a>00179               {                                                                \
<a name="l00180"></a>00180                 resu[elem1]+=flux;                                        \
<a name="l00181"></a>00181                 flux_bords(face,0)+=flux;                                \
<a name="l00182"></a>00182               }                                                                \
<a name="l00183"></a>00183             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00184"></a>00184               {                                                                \
<a name="l00185"></a>00185                 resu[elem2]-=flux;                                        \
<a name="l00186"></a>00186                 flux_bords(face,0)-=flux;                                \
<a name="l00187"></a>00187               }                                                                \
<a name="l00188"></a>00188           }                                                                \
<a name="l00189"></a>00189         }                                                                \
<a name="l00190"></a>00190         break;                                                                \
<a name="l00191"></a>00191       case sortie_libre :                                                \
<a name="l00192"></a>00192         if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \
<a name="l00193"></a>00193           const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \
<a name="l00194"></a>00194           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00195"></a>00195             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00196"></a>00196             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00197"></a>00197               {                                                                \
<a name="l00198"></a>00198                 resu[elem1]+=flux;                                        \
<a name="l00199"></a>00199                 flux_bords(face,0)+=flux;                                \
<a name="l00200"></a>00200               }                                                                \
<a name="l00201"></a>00201             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00202"></a>00202               {                                                                \
<a name="l00203"></a>00203                 resu[elem2]-=flux;                                        \
<a name="l00204"></a>00204                 flux_bords(face,0)-=flux;                                \
<a name="l00205"></a>00205               }                                                                \
<a name="l00206"></a>00206           }                                                                \
<a name="l00207"></a>00207         }                                                                \
<a name="l00208"></a>00208         break;                                                                \
<a name="l00209"></a>00209       case entree_fluide :                                                \
<a name="l00210"></a>00210         if (flux_evaluateur.calculer_flux_faces_entree_fluide()){       \
<a name="l00211"></a>00211           const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \
<a name="l00212"></a>00212           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00213"></a>00213             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00214"></a>00214             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00215"></a>00215               {                                                                \
<a name="l00216"></a>00216                 resu[elem1]+=flux;                                        \
<a name="l00217"></a>00217                 flux_bords(face,0)+=flux;                                \
<a name="l00218"></a>00218               }                                                                \
<a name="l00219"></a>00219             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00220"></a>00220               {                                                                \
<a name="l00221"></a>00221                 resu[elem2]-=flux;                                        \
<a name="l00222"></a>00222                 flux_bords(face,0)-=flux;                                \
<a name="l00223"></a>00223               }                                                                \
<a name="l00224"></a>00224           }                                                                \
<a name="l00225"></a>00225         }                                                                \
<a name="l00226"></a>00226         break;                                                                \
<a name="l00227"></a>00227       case paroi_fixe :                                                        \
<a name="l00228"></a>00228         if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \
<a name="l00229"></a>00229           const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \
<a name="l00230"></a>00230           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00231"></a>00231             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00232"></a>00232             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00233"></a>00233               {                                                                \
<a name="l00234"></a>00234                 resu[elem1]+=flux;                                        \
<a name="l00235"></a>00235                 flux_bords(face,0)+=flux;                                \
<a name="l00236"></a>00236               }                                                                \
<a name="l00237"></a>00237             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00238"></a>00238               {                                                                \
<a name="l00239"></a>00239                 resu[elem2]-=flux;                                        \
<a name="l00240"></a>00240                 flux_bords(face,0)-=flux;                                \
<a name="l00241"></a>00241               }                                                                \
<a name="l00242"></a>00242           }                                                                \
<a name="l00243"></a>00243         }                                                                \
<a name="l00244"></a>00244         break;                                                                \
<a name="l00245"></a>00245       case paroi_defilante :                                                \
<a name="l00246"></a>00246         if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \
<a name="l00247"></a>00247           const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \
<a name="l00248"></a>00248           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00249"></a>00249             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00250"></a>00250             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00251"></a>00251               {                                                                \
<a name="l00252"></a>00252                 resu[elem1]+=flux;                                        \
<a name="l00253"></a>00253                 flux_bords(face,0)+=flux;                                \
<a name="l00254"></a>00254               }                                                                \
<a name="l00255"></a>00255             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00256"></a>00256               {                                                                \
<a name="l00257"></a>00257                 resu[elem2]-=flux;                                        \
<a name="l00258"></a>00258                 flux_bords(face,0)-=flux;                                \
<a name="l00259"></a>00259               }                                                                \
<a name="l00260"></a>00260           }                                                                \
<a name="l00261"></a>00261         }                                                                \
<a name="l00262"></a>00262         break;                                                                \
<a name="l00263"></a>00263       case paroi_adiabatique :                                                \
<a name="l00264"></a>00264         if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \
<a name="l00265"></a>00265           const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \
<a name="l00266"></a>00266           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00267"></a>00267             <span class="comment">/* on initialise elem1 elem2 et on fait planter */</span>                \
<a name="l00268"></a>00268             elem1=-1;elem2=-1;assert(0);exit();                                \
<a name="l00269"></a>00269             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00270"></a>00270             resu[elem1]+=flux;                                                \
<a name="l00271"></a>00271             flux_bords(face,0)+=flux;                                        \
<a name="l00272"></a>00272             resu[elem2]-=flux;                                                \
<a name="l00273"></a>00273             flux_bords(face,0)-=flux;                                        \
<a name="l00274"></a>00274           }                                                                \
<a name="l00275"></a>00275         }                                                                \
<a name="l00276"></a>00276         break;                                                                \
<a name="l00277"></a>00277       case paroi :                                                        \
<a name="l00278"></a>00278         if (flux_evaluateur.calculer_flux_faces_paroi()){                \
<a name="l00279"></a>00279           const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \
<a name="l00280"></a>00280           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00281"></a>00281             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00282"></a>00282             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00283"></a>00283               {                                                                \
<a name="l00284"></a>00284                 resu[elem1]+=flux;                                        \
<a name="l00285"></a>00285                 flux_bords(face,0)+=flux;                                \
<a name="l00286"></a>00286               }                                                                \
<a name="l00287"></a>00287             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00288"></a>00288               {                                                                \
<a name="l00289"></a>00289                 resu[elem2]-=flux;                                        \
<a name="l00290"></a>00290                 flux_bords(face,0)-=flux;                                \
<a name="l00291"></a>00291               }                                                                \
<a name="l00292"></a>00292           }                                                                \
<a name="l00293"></a>00293         }                                                                \
<a name="l00294"></a>00294         break;                                                                \
<a name="l00295"></a>00295       case echange_externe_impose :                                        \
<a name="l00296"></a>00296         if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \
<a name="l00297"></a>00297           const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \
<a name="l00298"></a>00298                                                                                 \
<a name="l00299"></a>00299          int boundary_index=-1;                                                 \
<a name="l00300"></a>00300           if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \
<a name="l00301"></a>00301             boundary_index=num_cl;                                                  \
<a name="l00302"></a>00302                                                                                 \
<a name="l00303"></a>00303           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00304"></a>00304             int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \
<a name="l00305"></a>00305             flux = flux_evaluateur.flux_face(donnee, boundary_index,face,local_face, cl, ndeb); \
<a name="l00306"></a>00306             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00307"></a>00307               {                                                                \
<a name="l00308"></a>00308                 resu[elem1]+=flux;                                        \
<a name="l00309"></a>00309                 flux_bords(face,0)+=flux;                                \
<a name="l00310"></a>00310               }                                                                \
<a name="l00311"></a>00311             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00312"></a>00312               {                                                                \
<a name="l00313"></a>00313                 resu[elem2]-=flux;                                        \
<a name="l00314"></a>00314                 flux_bords(face,0)-=flux;                                \
<a name="l00315"></a>00315               }                                                                \
<a name="l00316"></a>00316           }                                                                \
<a name="l00317"></a>00317         }                                                                \
<a name="l00318"></a>00318         break;                                                                \
<a name="l00319"></a>00319       case echange_global_impose :                                        \
<a name="l00320"></a>00320         if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \
<a name="l00321"></a>00321           const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \
<a name="l00322"></a>00322           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00323"></a>00323             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00324"></a>00324             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00325"></a>00325               {                                                                \
<a name="l00326"></a>00326                 resu[elem1]+=flux;                                        \
<a name="l00327"></a>00327                 flux_bords(face,0)+=flux;                                \
<a name="l00328"></a>00328               }                                                                \
<a name="l00329"></a>00329             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00330"></a>00330               {                                                                \
<a name="l00331"></a>00331                 resu[elem2]-=flux;                                        \
<a name="l00332"></a>00332                 flux_bords(face,0)-=flux;                                \
<a name="l00333"></a>00333               }                                                                \
<a name="l00334"></a>00334           }                                                                \
<a name="l00335"></a>00335         }                                                                \
<a name="l00336"></a>00336         break;                                                                \
<a name="l00337"></a>00337       case nscbc :                                                        \
<a name="l00338"></a>00338         if (flux_evaluateur.calculer_flux_faces_NSCBC()){                \
<a name="l00339"></a>00339           const NSCBC&amp; cl =(const NSCBC&amp;) (la_cl.valeur());                \
<a name="l00340"></a>00340           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00341"></a>00341             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00342"></a>00342             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00343"></a>00343               {                                                                \
<a name="l00344"></a>00344                 resu[elem1]+=flux;                                        \
<a name="l00345"></a>00345                 flux_bords(face,0)+=flux;                                \
<a name="l00346"></a>00346               }                                                                \
<a name="l00347"></a>00347             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00348"></a>00348               {                                                                \
<a name="l00349"></a>00349                 resu[elem2]-=flux;                                        \
<a name="l00350"></a>00350                 flux_bords(face,0)-=flux;                                \
<a name="l00351"></a>00351               }                                                                \
<a name="l00352"></a>00352           }                                                                \
<a name="l00353"></a>00353         }                                                                \
<a name="l00354"></a>00354         break;                                                                \
<a name="l00355"></a>00355       case periodique :                                                        \
<a name="l00356"></a>00356         if (flux_evaluateur.calculer_flux_faces_periodique()){                \
<a name="l00357"></a>00357           const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \
<a name="l00358"></a>00358           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00359"></a>00359             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00360"></a>00360             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00361"></a>00361               {                                                                \
<a name="l00362"></a>00362                 resu[elem1]+=0.5*flux;                                        \
<a name="l00363"></a>00363                 if ( face &lt; (ndeb+frontiere_dis.nb_faces()/2) )                \
<a name="l00364"></a>00364                   flux_bords(face,0)+=flux;                                \
<a name="l00365"></a>00365               }                                                                \
<a name="l00366"></a>00366             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00367"></a>00367               {                                                                \
<a name="l00368"></a>00368                 resu[elem2]-=0.5*flux;                                        \
<a name="l00369"></a>00369                 if ( (ndeb+frontiere_dis.nb_faces()/2) &lt;= face )        \
<a name="l00370"></a>00370                   flux_bords(face,0)-=flux;                                \
<a name="l00371"></a>00371               }                                                                \
<a name="l00372"></a>00372           }                                                                \
<a name="l00373"></a>00373         }                                                                \
<a name="l00374"></a>00374       case scalaire_impose_paroi :                                            \
<a name="l00375"></a>00375         break;                                                                \
<a name="l00376"></a>00376         <span class="comment">/*                                                                \</span>
<a name="l00377"></a>00377 <span class="comment">                                                                          case nouvelle_Cl_PolyMAC : \</span>
<a name="l00378"></a>00378 <span class="comment">                                                                          if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l00379"></a>00379 <span class="comment">                                                                          const Nouvelle_Cl_PolyMAC&amp; cl =(const Nouvelle_Cl_PolyMAC&amp;) (la_cl.valeur()); \</span>
<a name="l00380"></a>00380 <span class="comment">                                                                          for (face=ndeb; face&lt;nfin; face++) { \</span>
<a name="l00381"></a>00381 <span class="comment">                                                                          if ( (elem1=elem(face,0)) &gt; -1) \</span>
<a name="l00382"></a>00382 <span class="comment">                                                                          resu[elem1]+=flux_evaluateur.flux_face(donnee, face, cl, ndeb); \</span>
<a name="l00383"></a>00383 <span class="comment">                                                                          if ( (elem2=elem(face,1)) &gt; -1) \</span>
<a name="l00384"></a>00384 <span class="comment">                                                                          resu[elem2]-=flux_evaluateur.flux_face(donnee, face, cl, ndeb); \</span>
<a name="l00385"></a>00385 <span class="comment">                                                                          } \</span>
<a name="l00386"></a>00386 <span class="comment">                                                                          } \</span>
<a name="l00387"></a>00387 <span class="comment">                                                                          break; \</span>
<a name="l00388"></a>00388 <span class="comment">        */</span>                                                                \
<a name="l00389"></a>00389       default :                                                                \
<a name="l00390"></a>00390         Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \
<a name="l00391"></a>00391         Cerr &lt;&lt; &quot;Dans It_PolyMAC_Elem(_TYPE_)::ajouter_bords&quot;&lt;&lt;finl;        \
<a name="l00392"></a>00392         exit();                                                                \
<a name="l00393"></a>00393         break;                                                                \
<a name="l00394"></a>00394       }                                                                        \
<a name="l00395"></a>00395     }                                                                        \
<a name="l00396"></a>00396     return resu;                                                        \
<a name="l00397"></a>00397   }                                                                     \
<a name="l00398"></a>00398   void It_PolyMAC_Elem(_TYPE_)::calculer_flux_bord(const DoubleTab&amp; donnee) const        \
<a name="l00399"></a>00399   {                                                                        \
<a name="l00400"></a>00400     ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();                        \
<a name="l00401"></a>00401     assert(donnee.nb_dim() &lt; 3);                                                \
<a name="l00402"></a>00402     assert(la_zcl.non_nul());                                                \
<a name="l00403"></a>00403     assert(la_zone.non_nul());                                                \
<a name="l00404"></a>00404     int ncomp=1;                                                        \
<a name="l00405"></a>00405     if (donnee.nb_dim() == 2)                                                \
<a name="l00406"></a>00406       ncomp=donnee.dimension(1);                                                \
<a name="l00407"></a>00407     DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \
<a name="l00408"></a>00408     flux_bords.resize(la_zone-&gt;nb_faces_bord(),ncomp);                        \
<a name="l00409"></a>00409     flux_bords=0;                                                        \
<a name="l00410"></a>00410                                                                      \
<a name="l00411"></a>00411     if( ncomp != 1) Process ::exit();<span class="comment">/* cas scalaire */</span>                 \
<a name="l00412"></a>00412                                                                              \
<a name="l00413"></a>00413                                                                           \
<a name="l00414"></a>00414     int ndeb, nfin;                                                        \
<a name="l00415"></a>00415     int face;                                                                \
<a name="l00416"></a>00416     int num_cl=0;                                                        \
<a name="l00417"></a>00417     double flux;                                                        \
<a name="l00418"></a>00418     int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \
<a name="l00419"></a>00419     for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \
<a name="l00420"></a>00420       <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>                \
<a name="l00421"></a>00421       const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \
<a name="l00422"></a>00422       const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \
<a name="l00423"></a>00423       ndeb = frontiere_dis.num_premiere_face();                                \
<a name="l00424"></a>00424       nfin = ndeb + frontiere_dis.nb_faces();                                \
<a name="l00425"></a>00425       <span class="comment">/* Test en bidim axi */</span>                                                \
<a name="l00426"></a>00426       if (bidim_axi &amp;&amp; !sub_type(Symetrie,la_cl.valeur()))                \
<a name="l00427"></a>00427         {                                                                \
<a name="l00428"></a>00428           if (nfin&gt;ndeb &amp;&amp; est_egal(la_zone.valeur().face_surfaces()[ndeb],0)) \
<a name="l00429"></a>00429             {                                                                \
<a name="l00430"></a>00430               Cerr &lt;&lt; &quot;Error in the definition of the boundary conditions.&quot; &lt;&lt; finl; \
<a name="l00431"></a>00431               Cerr &lt;&lt; &quot;The axis of revolution for this 2D calculation is along Y.&quot; &lt;&lt; finl; \
<a name="l00432"></a>00432               Cerr &lt;&lt; &quot;So you must specify symmetry for the boundary &quot; &lt;&lt; frontiere_dis.le_nom() &lt;&lt; finl; \
<a name="l00433"></a>00433               exit();                                                        \
<a name="l00434"></a>00434             }                                                                \
<a name="l00435"></a>00435         }                                                                \
<a name="l00436"></a>00436       switch(type_cl(la_cl)){                                                \
<a name="l00437"></a>00437       case symetrie :                                                        \
<a name="l00438"></a>00438         if (flux_evaluateur.calculer_flux_faces_symetrie()){                \
<a name="l00439"></a>00439           const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \
<a name="l00440"></a>00440           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00441"></a>00441             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00442"></a>00442             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00443"></a>00443               {                                                                \
<a name="l00444"></a>00444                 flux_bords(face,0)+=flux;                                \
<a name="l00445"></a>00445               }                                                                \
<a name="l00446"></a>00446             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00447"></a>00447               {                                                                \
<a name="l00448"></a>00448                 flux_bords(face,0)-=flux;                                \
<a name="l00449"></a>00449               }                                                                \
<a name="l00450"></a>00450           }                                                                \
<a name="l00451"></a>00451         }                                                                \
<a name="l00452"></a>00452         break;                                                                \
<a name="l00453"></a>00453       case sortie_libre :                                                \
<a name="l00454"></a>00454         if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \
<a name="l00455"></a>00455           const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \
<a name="l00456"></a>00456           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00457"></a>00457             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00458"></a>00458             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00459"></a>00459               {                                                                \
<a name="l00460"></a>00460                 flux_bords(face,0)+=flux;                                \
<a name="l00461"></a>00461               }                                                                \
<a name="l00462"></a>00462             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00463"></a>00463               {                                                                \
<a name="l00464"></a>00464                 flux_bords(face,0)-=flux;                                \
<a name="l00465"></a>00465               }                                                                \
<a name="l00466"></a>00466           }                                                                \
<a name="l00467"></a>00467         }                                                                \
<a name="l00468"></a>00468         break;                                                                \
<a name="l00469"></a>00469       case entree_fluide :                                                \
<a name="l00470"></a>00470         if (flux_evaluateur.calculer_flux_faces_entree_fluide()){        \
<a name="l00471"></a>00471           const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \
<a name="l00472"></a>00472           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00473"></a>00473             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00474"></a>00474             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00475"></a>00475               {                                                                \
<a name="l00476"></a>00476                 flux_bords(face,0)+=flux;                                \
<a name="l00477"></a>00477               }                                                                \
<a name="l00478"></a>00478             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00479"></a>00479               {                                                                \
<a name="l00480"></a>00480                 flux_bords(face,0)-=flux;                                \
<a name="l00481"></a>00481               }                                                                \
<a name="l00482"></a>00482           }                                                                \
<a name="l00483"></a>00483         }                                                                \
<a name="l00484"></a>00484         break;                                                                \
<a name="l00485"></a>00485       case paroi_fixe :                                                        \
<a name="l00486"></a>00486         if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \
<a name="l00487"></a>00487           const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \
<a name="l00488"></a>00488           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00489"></a>00489             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00490"></a>00490             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00491"></a>00491               {                                                                \
<a name="l00492"></a>00492                 flux_bords(face,0)+=flux;                                \
<a name="l00493"></a>00493               }                                                                \
<a name="l00494"></a>00494             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00495"></a>00495               {                                                                \
<a name="l00496"></a>00496                 flux_bords(face,0)-=flux;                                \
<a name="l00497"></a>00497               }                                                                \
<a name="l00498"></a>00498           }                                                                \
<a name="l00499"></a>00499         }                                                                \
<a name="l00500"></a>00500         break;                                                                \
<a name="l00501"></a>00501       case paroi_defilante :                                                \
<a name="l00502"></a>00502         if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \
<a name="l00503"></a>00503           const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \
<a name="l00504"></a>00504           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00505"></a>00505             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00506"></a>00506             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00507"></a>00507               {                                                                \
<a name="l00508"></a>00508                 flux_bords(face,0)+=flux;                                \
<a name="l00509"></a>00509               }                                                                \
<a name="l00510"></a>00510             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00511"></a>00511               {                                                                \
<a name="l00512"></a>00512                 flux_bords(face,0)-=flux;                                \
<a name="l00513"></a>00513               }                                                                \
<a name="l00514"></a>00514           }                                                                \
<a name="l00515"></a>00515         }                                                                \
<a name="l00516"></a>00516         break;                                                                \
<a name="l00517"></a>00517       case paroi_adiabatique :                                                \
<a name="l00518"></a>00518         if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \
<a name="l00519"></a>00519           const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \
<a name="l00520"></a>00520           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00521"></a>00521             assert(0);exit();                                \
<a name="l00522"></a>00522             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00523"></a>00523             flux_bords(face,0)+=flux;                                        \
<a name="l00524"></a>00524             flux_bords(face,0)-=flux;                                        \
<a name="l00525"></a>00525           }                                                                \
<a name="l00526"></a>00526         }                                                                \
<a name="l00527"></a>00527         break;                                                                \
<a name="l00528"></a>00528       case paroi :                                                        \
<a name="l00529"></a>00529         if (flux_evaluateur.calculer_flux_faces_paroi()){                \
<a name="l00530"></a>00530           const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \
<a name="l00531"></a>00531           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00532"></a>00532             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00533"></a>00533             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00534"></a>00534               {                                                                \
<a name="l00535"></a>00535                 flux_bords(face,0)+=flux;                                \
<a name="l00536"></a>00536               }                                                                \
<a name="l00537"></a>00537             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00538"></a>00538               {                                                                \
<a name="l00539"></a>00539                 flux_bords(face,0)-=flux;                                \
<a name="l00540"></a>00540               }                                                                \
<a name="l00541"></a>00541           }                                                                \
<a name="l00542"></a>00542         }                                                                \
<a name="l00543"></a>00543         break;                                                                \
<a name="l00544"></a>00544       case echange_externe_impose :                                        \
<a name="l00545"></a>00545         if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \
<a name="l00546"></a>00546           const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \
<a name="l00547"></a>00547                                                                                 \
<a name="l00548"></a>00548           int boundary_index=-1;                                                        \
<a name="l00549"></a>00549           if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \
<a name="l00550"></a>00550             boundary_index=num_cl;                                                  \
<a name="l00551"></a>00551                                                                                 \
<a name="l00552"></a>00552           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00553"></a>00553             int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \
<a name="l00554"></a>00554             flux = flux_evaluateur.flux_face(donnee, boundary_index,face,local_face, cl, ndeb); \
<a name="l00555"></a>00555             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00556"></a>00556               {                                                                \
<a name="l00557"></a>00557                 flux_bords(face,0)+=flux;                                \
<a name="l00558"></a>00558               }                                                                \
<a name="l00559"></a>00559             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00560"></a>00560               {                                                                \
<a name="l00561"></a>00561                 flux_bords(face,0)-=flux;                                \
<a name="l00562"></a>00562               }                                                                \
<a name="l00563"></a>00563           }                                                                \
<a name="l00564"></a>00564         }                                                                \
<a name="l00565"></a>00565         break;                                                                \
<a name="l00566"></a>00566       case echange_global_impose :                                        \
<a name="l00567"></a>00567         if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \
<a name="l00568"></a>00568           const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \
<a name="l00569"></a>00569           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00570"></a>00570             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00571"></a>00571             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00572"></a>00572               {                                                                \
<a name="l00573"></a>00573                 flux_bords(face,0)+=flux;                                \
<a name="l00574"></a>00574               }                                                                \
<a name="l00575"></a>00575             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00576"></a>00576               {                                                                \
<a name="l00577"></a>00577                 flux_bords(face,0)-=flux;                                \
<a name="l00578"></a>00578               }                                                                \
<a name="l00579"></a>00579           }                                                                \
<a name="l00580"></a>00580         }                                                                \
<a name="l00581"></a>00581         break;                                                                \
<a name="l00582"></a>00582       case nscbc :                                                        \
<a name="l00583"></a>00583         if (flux_evaluateur.calculer_flux_faces_NSCBC()){                \
<a name="l00584"></a>00584           const NSCBC&amp; cl =(const NSCBC&amp;) (la_cl.valeur());                \
<a name="l00585"></a>00585           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00586"></a>00586             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00587"></a>00587             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00588"></a>00588               {                                                                \
<a name="l00589"></a>00589                 flux_bords(face,0)+=flux;                                \
<a name="l00590"></a>00590               }                                                                \
<a name="l00591"></a>00591             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00592"></a>00592               {                                                                \
<a name="l00593"></a>00593                 flux_bords(face,0)-=flux;                                \
<a name="l00594"></a>00594               }                                                                \
<a name="l00595"></a>00595           }                                                                \
<a name="l00596"></a>00596         }                                                                \
<a name="l00597"></a>00597         break;                                                                \
<a name="l00598"></a>00598       case periodique :                                                        \
<a name="l00599"></a>00599         if (flux_evaluateur.calculer_flux_faces_periodique()){                \
<a name="l00600"></a>00600           const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \
<a name="l00601"></a>00601           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00602"></a>00602             flux = flux_evaluateur.flux_face(donnee, face, cl, ndeb);        \
<a name="l00603"></a>00603             if ( (elem(face,0)) &gt; -1)                                \
<a name="l00604"></a>00604               {                                                                \
<a name="l00605"></a>00605                 if ( face &lt; (ndeb+frontiere_dis.nb_faces()/2) )                \
<a name="l00606"></a>00606                   flux_bords(face,0)+=flux;                                \
<a name="l00607"></a>00607               }                                                                \
<a name="l00608"></a>00608             if ( (elem(face,1)) &gt; -1)                                \
<a name="l00609"></a>00609               {                                                                \
<a name="l00610"></a>00610                 if ( (ndeb+frontiere_dis.nb_faces()/2) &lt;= face )        \
<a name="l00611"></a>00611                   flux_bords(face,0)-=flux;                                \
<a name="l00612"></a>00612               }                                                                \
<a name="l00613"></a>00613           }                                                                \
<a name="l00614"></a>00614         }                                                                \
<a name="l00615"></a>00615         break;                                                                \
<a name="l00616"></a>00616       case scalaire_impose_paroi :                                            \
<a name="l00617"></a><a class="code" href="MItPolyMACEl_8h.html#afab0d4a7eac9169cfb1145919be86630">00617</a>         break;                                                                \
<a name="l00618"></a>00618         <span class="comment">/*                                                                \</span>
<a name="l00619"></a>00619 <span class="comment">                                                                          case nouvelle_Cl_PolyMAC : \</span>
<a name="l00620"></a>00620 <span class="comment">                                                                          if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l00621"></a>00621 <span class="comment">                                                                          const Nouvelle_Cl_PolyMAC&amp; cl =(const Nouvelle_Cl_PolyMAC&amp;) (la_cl.valeur()); \</span>
<a name="l00622"></a>00622 <span class="comment">                                                                          for (face=ndeb; face&lt;nfin; face++) { \</span>
<a name="l00623"></a>00623 <span class="comment">                                                                          if ( (int elem1=elem(face,0)) &gt; -1) \</span>
<a name="l00624"></a>00624 <span class="comment">                                                                          resu[elem1]+=flux_evaluateur.flux_face(donnee, face, cl, ndeb); \</span>
<a name="l00625"></a>00625 <span class="comment">                                                                          if ( (int elem2=elem(face,1)) &gt; -1) \</span>
<a name="l00626"></a>00626 <span class="comment">                                                                          resu[elem2]-=flux_evaluateur.flux_face(donnee, face, cl, ndeb); \</span>
<a name="l00627"></a>00627 <span class="comment">                                                                          } \</span>
<a name="l00628"></a>00628 <span class="comment">                                                                          } \</span>
<a name="l00629"></a>00629 <span class="comment">                                                                          break; \</span>
<a name="l00630"></a>00630 <span class="comment">        */</span>                                                                \
<a name="l00631"></a>00631       default :                                                                \
<a name="l00632"></a>00632         Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \
<a name="l00633"></a>00633         Cerr &lt;&lt; &quot;Dans It_PolyMAC_Elem(_TYPE_)::ajouter_bords&quot;&lt;&lt;finl;        \
<a name="l00634"></a>00634         exit();                                                                \
<a name="l00635"></a>00635         break;                                                                \
<a name="l00636"></a>00636       }                                                                        \
<a name="l00637"></a>00637     } \
<a name="l00638"></a>00638 modifier_flux() ;                                               \
<a name="l00639"></a>00639   }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="preprocessor">#define implemente2_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l00642"></a>00642 <span class="preprocessor">  DoubleTab&amp; It_PolyMAC_Elem(_TYPE_)::ajouter_bords(const DoubleTab&amp; donnee, \</span>
<a name="l00643"></a>00643 <span class="preprocessor">                                                DoubleTab&amp; resu,int ncomp) const \</span>
<a name="l00644"></a>00644 <span class="preprocessor">  {                                                                        \</span>
<a name="l00645"></a>00645 <span class="preprocessor">    int elem1, elem2;                                                        \</span>
<a name="l00646"></a>00646 <span class="preprocessor">    int ndeb, nfin;                                                        \</span>
<a name="l00647"></a>00647 <span class="preprocessor">    int face,k;                                                                \</span>
<a name="l00648"></a>00648 <span class="preprocessor">    DoubleVect flux(ncomp);                                                \</span>
<a name="l00649"></a>00649 <span class="preprocessor">    int num_cl=0;                                                        \</span>
<a name="l00650"></a>00650 <span class="preprocessor">    int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \</span>
<a name="l00651"></a>00651 <span class="preprocessor">    DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \</span>
<a name="l00652"></a>00652 <span class="preprocessor">    for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \</span>
<a name="l00653"></a>00653 <span class="preprocessor">      const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \</span>
<a name="l00654"></a>00654 <span class="preprocessor">      const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \</span>
<a name="l00655"></a>00655 <span class="preprocessor">      ndeb = frontiere_dis.num_premiere_face();                                \</span>
<a name="l00656"></a>00656 <span class="preprocessor">      nfin = ndeb + frontiere_dis.nb_faces();                                \</span>
<a name="l00657"></a>00657 <span class="preprocessor">      </span><span class="comment">/* Test en bidim axi */</span>                                                \
<a name="l00658"></a>00658       if (bidim_axi &amp;&amp; !sub_type(Symetrie,la_cl.valeur()))                \
<a name="l00659"></a>00659         {                                                                \
<a name="l00660"></a>00660           if (nfin&gt;ndeb &amp;&amp; est_egal(la_zone.valeur().face_surfaces()[ndeb],0)) \
<a name="l00661"></a>00661             {                                                                \
<a name="l00662"></a>00662               Cerr &lt;&lt; &quot;Error in the definition of the boundary conditions.&quot; &lt;&lt; finl; \
<a name="l00663"></a>00663               Cerr &lt;&lt; &quot;The axis of revolution for this 2D calculation is along Y.&quot; &lt;&lt; finl; \
<a name="l00664"></a>00664               Cerr &lt;&lt; &quot;So you must specify symmetry for the boundary &quot; &lt;&lt; frontiere_dis.le_nom() &lt;&lt; finl; \
<a name="l00665"></a>00665               exit();                                                        \
<a name="l00666"></a>00666             }                                                                \
<a name="l00667"></a>00667         }                                                                \
<a name="l00668"></a>00668       switch(type_cl(la_cl)){                                                \
<a name="l00669"></a>00669       case symetrie :                                                        \
<a name="l00670"></a>00670         if (flux_evaluateur.calculer_flux_faces_symetrie()){                \
<a name="l00671"></a>00671           const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \
<a name="l00672"></a>00672           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00673"></a>00673             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00674"></a>00674             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00675"></a>00675               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00676"></a>00676                 {                                                        \
<a name="l00677"></a>00677                   resu(elem1,k) +=flux(k);                                \
<a name="l00678"></a>00678                   flux_bords(face,k)+=flux(k);                                \
<a name="l00679"></a>00679                 }                                                        \
<a name="l00680"></a>00680             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00681"></a>00681               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00682"></a>00682                 {                                                        \
<a name="l00683"></a>00683                   resu(elem2,k) -=flux(k);                                \
<a name="l00684"></a>00684                   flux_bords(face,k)-=flux(k);                                \
<a name="l00685"></a>00685                 }                                                        \
<a name="l00686"></a>00686           }                                                                \
<a name="l00687"></a>00687         }                                                                \
<a name="l00688"></a>00688         break;                                                                \
<a name="l00689"></a>00689       case sortie_libre :                                                \
<a name="l00690"></a>00690         if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \
<a name="l00691"></a>00691           const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \
<a name="l00692"></a>00692           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00693"></a>00693             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00694"></a>00694             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00695"></a>00695               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00696"></a>00696                 {                                                        \
<a name="l00697"></a>00697                   resu(elem1,k) +=flux(k);                                \
<a name="l00698"></a>00698                   flux_bords(face,k)+=flux(k);                                \
<a name="l00699"></a>00699                 }                                                        \
<a name="l00700"></a>00700             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00701"></a>00701               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00702"></a>00702                 {                                                        \
<a name="l00703"></a>00703                   resu(elem2,k) -=flux(k);                                \
<a name="l00704"></a>00704                   flux_bords(face,k)-=flux(k);                                \
<a name="l00705"></a>00705                 }                                                        \
<a name="l00706"></a>00706           }                                                                \
<a name="l00707"></a>00707         }                                                                \
<a name="l00708"></a>00708         break;                                                                \
<a name="l00709"></a>00709       case entree_fluide :                                                \
<a name="l00710"></a>00710         if (flux_evaluateur.calculer_flux_faces_entree_fluide()){        \
<a name="l00711"></a>00711           const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \
<a name="l00712"></a>00712           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00713"></a>00713             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00714"></a>00714             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00715"></a>00715               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00716"></a>00716                 {                                                        \
<a name="l00717"></a>00717                   resu(elem1,k) +=flux(k);                                \
<a name="l00718"></a>00718                   flux_bords(face,k)+=flux(k);                                \
<a name="l00719"></a>00719                 }                                                        \
<a name="l00720"></a>00720             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00721"></a>00721               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00722"></a>00722                 {                                                        \
<a name="l00723"></a>00723                   resu(elem2,k) -=flux(k);                                \
<a name="l00724"></a>00724                   flux_bords(face,k)-=flux(k);                                \
<a name="l00725"></a>00725                 }                                                        \
<a name="l00726"></a>00726           }                                                                \
<a name="l00727"></a>00727         }                                                                \
<a name="l00728"></a>00728         break;                                                                \
<a name="l00729"></a>00729       case paroi_fixe :                                                        \
<a name="l00730"></a>00730         if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \
<a name="l00731"></a>00731           const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \
<a name="l00732"></a>00732           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00733"></a>00733             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00734"></a>00734             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00735"></a>00735               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00736"></a>00736                 {                                                        \
<a name="l00737"></a>00737                   resu(elem1,k) +=flux(k);                                \
<a name="l00738"></a>00738                   flux_bords(face,k)+=flux(k);                                \
<a name="l00739"></a>00739                 }                                                        \
<a name="l00740"></a>00740             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00741"></a>00741               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00742"></a>00742                 {                                                        \
<a name="l00743"></a>00743                   resu(elem2,k) -=flux(k);                                \
<a name="l00744"></a>00744                   flux_bords(face,k)-=flux(k);                                \
<a name="l00745"></a>00745                 }                                                        \
<a name="l00746"></a>00746           }                                                                \
<a name="l00747"></a>00747         }                                                                \
<a name="l00748"></a>00748         break;                                                                \
<a name="l00749"></a>00749       case paroi_defilante :                                                \
<a name="l00750"></a>00750         if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \
<a name="l00751"></a>00751           const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \
<a name="l00752"></a>00752           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00753"></a>00753             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00754"></a>00754             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00755"></a>00755               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00756"></a>00756                 {                                                        \
<a name="l00757"></a>00757                   resu(elem1,k) +=flux(k);                                \
<a name="l00758"></a>00758                   flux_bords(face,k)+=flux(k);                                \
<a name="l00759"></a>00759                 }                                                        \
<a name="l00760"></a>00760             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00761"></a>00761               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00762"></a>00762                 {                                                        \
<a name="l00763"></a>00763                   resu(elem2,k) -=flux(k);                                \
<a name="l00764"></a>00764                   flux_bords(face,k)-=flux(k);                                \
<a name="l00765"></a>00765                 }                                                        \
<a name="l00766"></a>00766           }                                                                \
<a name="l00767"></a>00767         }                                                                \
<a name="l00768"></a>00768         break;                                                                \
<a name="l00769"></a>00769       case paroi_adiabatique :                                                \
<a name="l00770"></a>00770         if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \
<a name="l00771"></a>00771           const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \
<a name="l00772"></a>00772           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00773"></a>00773             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00774"></a>00774             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00775"></a>00775               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00776"></a>00776                 {                                                        \
<a name="l00777"></a>00777                   resu(elem1,k) +=flux(k);                                \
<a name="l00778"></a>00778                   flux_bords(face,k)+=flux(k);                                \
<a name="l00779"></a>00779                 }                                                        \
<a name="l00780"></a>00780             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00781"></a>00781               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00782"></a>00782                 {                                                        \
<a name="l00783"></a>00783                   resu(elem2,k) -=flux(k);                                \
<a name="l00784"></a>00784                   flux_bords(face,k)-=flux(k);                                \
<a name="l00785"></a>00785                 }                                                        \
<a name="l00786"></a>00786           }                                                                \
<a name="l00787"></a>00787         }                                                                \
<a name="l00788"></a>00788         break;                                                                \
<a name="l00789"></a>00789       case paroi :                                                        \
<a name="l00790"></a>00790         if (flux_evaluateur.calculer_flux_faces_paroi()){                \
<a name="l00791"></a>00791           const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \
<a name="l00792"></a>00792           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00793"></a>00793             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00794"></a>00794             <span class="comment">/* on initialise elem1 elem2 et on fait planter */</span>                \
<a name="l00795"></a>00795             elem1=-1;elem2=-1;assert(0);exit();                                \
<a name="l00796"></a>00796             for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00797"></a>00797               {                                                                \
<a name="l00798"></a>00798                 resu(elem1,k) +=flux(k);                                \
<a name="l00799"></a>00799                 flux_bords(face,k)+=flux(k);                                \
<a name="l00800"></a>00800               }                                                                \
<a name="l00801"></a>00801             for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00802"></a>00802               {                                                                \
<a name="l00803"></a>00803                 resu(elem2,k) -=flux(k);                                \
<a name="l00804"></a>00804                 flux_bords(face,k)-=flux(k);                                \
<a name="l00805"></a>00805               }                                                                \
<a name="l00806"></a>00806           }                                                                \
<a name="l00807"></a>00807         }                                                                \
<a name="l00808"></a>00808         break;                                                                \
<a name="l00809"></a>00809       case echange_externe_impose :                                        \
<a name="l00810"></a>00810         if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \
<a name="l00811"></a>00811           const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \
<a name="l00812"></a>00812                                                                                 \
<a name="l00813"></a>00813           int boundary_index=-1;                                                        \
<a name="l00814"></a>00814           if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \
<a name="l00815"></a>00815             boundary_index=num_cl;                                                  \
<a name="l00816"></a>00816                                                                                 \
<a name="l00817"></a>00817           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00818"></a>00818             int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \
<a name="l00819"></a>00819             flux_evaluateur.flux_face(donnee, boundary_index, face, local_face, cl, ndeb, flux); \
<a name="l00820"></a>00820             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00821"></a>00821               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00822"></a>00822                 {                                                        \
<a name="l00823"></a>00823                   resu(elem1,k) +=flux(k);                                \
<a name="l00824"></a>00824                   flux_bords(face,k)+=flux(k);                                \
<a name="l00825"></a>00825                 }                                                        \
<a name="l00826"></a>00826             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00827"></a>00827               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00828"></a>00828                 {                                                        \
<a name="l00829"></a>00829                   resu(elem2,k) -=flux(k);                                \
<a name="l00830"></a>00830                   flux_bords(face,k)-=flux(k);                                \
<a name="l00831"></a>00831                 }                                                        \
<a name="l00832"></a>00832           }                                                                \
<a name="l00833"></a>00833         }                                                                \
<a name="l00834"></a>00834         break;                                                                \
<a name="l00835"></a>00835       case echange_global_impose :                                        \
<a name="l00836"></a>00836         if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \
<a name="l00837"></a>00837           const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \
<a name="l00838"></a>00838           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00839"></a>00839             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00840"></a>00840             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00841"></a>00841               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00842"></a>00842                 {                                                        \
<a name="l00843"></a>00843                   resu(elem1,k) +=flux(k);                                \
<a name="l00844"></a>00844                   flux_bords(face,k)+=flux(k);                                \
<a name="l00845"></a>00845                 }                                                        \
<a name="l00846"></a>00846             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00847"></a>00847               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00848"></a>00848                 {                                                        \
<a name="l00849"></a>00849                   resu(elem2,k) -=flux(k);                                \
<a name="l00850"></a>00850                   flux_bords(face,k)-=flux(k);                                \
<a name="l00851"></a>00851                 }                                                        \
<a name="l00852"></a>00852           }                                                                \
<a name="l00853"></a>00853         }                                                                \
<a name="l00854"></a>00854         break;                                                                \
<a name="l00855"></a>00855       case periodique :                                                        \
<a name="l00856"></a>00856         if (flux_evaluateur.calculer_flux_faces_periodique()){                \
<a name="l00857"></a>00857           const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \
<a name="l00858"></a>00858           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l00859"></a>00859             flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux);        \
<a name="l00860"></a>00860             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l00861"></a>00861               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00862"></a>00862                 {                                                        \
<a name="l00863"></a><a class="code" href="MItPolyMACEl_8h.html#a8b0faf8581cdc63d1572f252ba8c3381">00863</a>                   resu(elem1,k) +=0.5*flux(k);                                \
<a name="l00864"></a>00864                   if ( face &lt; (ndeb+frontiere_dis.nb_faces()/2) )        \
<a name="l00865"></a>00865                     flux_bords(face,k)+=flux(k);                        \
<a name="l00866"></a>00866                 }                                                        \
<a name="l00867"></a>00867             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l00868"></a>00868               for (k=0; k&lt;ncomp; k++)                                        \
<a name="l00869"></a>00869                 {                                                        \
<a name="l00870"></a>00870                   resu(elem2,k) -=0.5*flux(k);                                \
<a name="l00871"></a>00871                   if ( (ndeb+frontiere_dis.nb_faces()/2) &lt;= face )        \
<a name="l00872"></a>00872                     flux_bords(face,k)-=flux(k);                        \
<a name="l00873"></a>00873                 }                                                        \
<a name="l00874"></a>00874           }                                                                \
<a name="l00875"></a>00875         }                                                                \
<a name="l00876"></a>00876         break;                                                                \
<a name="l00877"></a>00877         <span class="comment">/*                                                                \</span>
<a name="l00878"></a>00878 <span class="comment">                                                                          case nouvelle_Cl_PolyMAC : \</span>
<a name="l00879"></a>00879 <span class="comment">                                                                          if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l00880"></a>00880 <span class="comment">                                                                          const Nouvelle_Cl_PolyMAC&amp; cl =(const Nouvelle_Cl_PolyMAC&amp;) (la_cl.valeur()); \</span>
<a name="l00881"></a>00881 <span class="comment">                                                                          for (face=ndeb; face&lt;nfin; face++) { \</span>
<a name="l00882"></a>00882 <span class="comment">                                                                          flux_evaluateur.flux_face(donnee, face, cl, ndeb, flux); \</span>
<a name="l00883"></a>00883 <span class="comment">                                                                          if ( (elem1=elem(face,0)) &gt; -1) \</span>
<a name="l00884"></a>00884 <span class="comment">                                                                          for (k=0; k&lt;ncomp; k++) \</span>
<a name="l00885"></a>00885 <span class="comment">                                                                          resu(elem1,k) +=flux(k); \</span>
<a name="l00886"></a>00886 <span class="comment">                                                                          if ( (elem2=elem(face,1)) &gt; -1) \</span>
<a name="l00887"></a>00887 <span class="comment">                                                                          for (k=0; k&lt;ncomp; k++) \</span>
<a name="l00888"></a>00888 <span class="comment">                                                                          resu(elem2,k) -=flux(k); \</span>
<a name="l00889"></a>00889 <span class="comment">                                                                          } \</span>
<a name="l00890"></a>00890 <span class="comment">                                                                          } \</span>
<a name="l00891"></a>00891 <span class="comment">                                                                          break; \</span>
<a name="l00892"></a>00892 <span class="comment">        */</span>                                                                \
<a name="l00893"></a>00893       default :                                                                \
<a name="l00894"></a>00894         Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \
<a name="l00895"></a>00895         exit();                                                                \
<a name="l00896"></a>00896         break;                                                                \
<a name="l00897"></a>00897       }                                                                        \
<a name="l00898"></a>00898     }                                                                        \
<a name="l00899"></a>00899     return resu;                                                        \
<a name="l00900"></a>00900   }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <span class="preprocessor">#define implemente3_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l00903"></a>00903 <span class="preprocessor">  DoubleTab&amp; It_PolyMAC_Elem(_TYPE_)::ajouter_interne(const DoubleTab&amp; donnee, \</span>
<a name="l00904"></a>00904 <span class="preprocessor">                                                  DoubleTab&amp; resu) const \</span>
<a name="l00905"></a>00905 <span class="preprocessor">  {                                                                        \</span>
<a name="l00906"></a>00906 <span class="preprocessor">    const Zone_PolyMAC&amp; zone_PolyMAC = la_zone.valeur();                        \</span>
<a name="l00907"></a>00907 <span class="preprocessor">    double flux;                                                        \</span>
<a name="l00908"></a>00908 <span class="preprocessor">    int face;                                                                \</span>
<a name="l00909"></a>00909 <span class="preprocessor">    int ndeb = zone_PolyMAC.premiere_face_int();                                \</span>
<a name="l00910"></a>00910 <span class="preprocessor">    int nfin = zone_PolyMAC.nb_faces();                                        \</span>
<a name="l00911"></a>00911 <span class="preprocessor">    for (face=ndeb; face&lt;nfin; face++)                                        \</span>
<a name="l00912"></a>00912 <span class="preprocessor">      {                                                                        \</span>
<a name="l00913"></a>00913 <span class="preprocessor">        flux=flux_evaluateur.flux_faces_interne(donnee, face);                \</span>
<a name="l00914"></a>00914 <span class="preprocessor">        resu[elem(face,0)]+=flux;                                        \</span>
<a name="l00915"></a>00915 <span class="preprocessor">        resu[elem(face,1)]-=flux;                                        \</span>
<a name="l00916"></a>00916 <span class="preprocessor">      }                                                                        \</span>
<a name="l00917"></a>00917 <span class="preprocessor">    return resu;                                                        \</span>
<a name="l00918"></a>00918 <span class="preprocessor">  }                                                                        \</span>
<a name="l00919"></a>00919 <span class="preprocessor">  DoubleTab&amp; It_PolyMAC_Elem(_TYPE_)::ajouter_interne(const DoubleTab&amp; donnee, \</span>
<a name="l00920"></a>00920 <span class="preprocessor">                                                  DoubleTab&amp; resu,int ncomp) const \</span>
<a name="l00921"></a>00921 <span class="preprocessor">  {                                                                        \</span>
<a name="l00922"></a>00922 <span class="preprocessor">    const Zone_PolyMAC&amp; zone_PolyMAC = la_zone.valeur();                        \</span>
<a name="l00923"></a>00923 <span class="preprocessor">    DoubleVect flux(ncomp);                                                \</span>
<a name="l00924"></a>00924 <span class="preprocessor">    int face,k;                                                                \</span>
<a name="l00925"></a>00925 <span class="preprocessor">    int elem0,elem1;                                                        \</span>
<a name="l00926"></a>00926 <span class="preprocessor">    int ndeb = zone_PolyMAC.premiere_face_int();                                \</span>
<a name="l00927"></a>00927 <span class="preprocessor">    int nfin = zone_PolyMAC.nb_faces();                                        \</span>
<a name="l00928"></a>00928 <span class="preprocessor">    for (face=ndeb; face&lt;nfin; face++)                                        \</span>
<a name="l00929"></a>00929 <span class="preprocessor">      {                                                                        \</span>
<a name="l00930"></a>00930 <span class="preprocessor">        flux_evaluateur.flux_faces_interne(donnee, face, flux);                \</span>
<a name="l00931"></a>00931 <span class="preprocessor">        elem0 = elem(face,0);                                                \</span>
<a name="l00932"></a>00932 <span class="preprocessor">        elem1 = elem(face,1);                                                \</span>
<a name="l00933"></a>00933 <span class="preprocessor">        for (k=0; k&lt;ncomp; k++) {                                        \</span>
<a name="l00934"></a>00934 <span class="preprocessor">          resu(elem0,k)+=flux(k);                                        \</span>
<a name="l00935"></a>00935 <span class="preprocessor">          resu(elem1,k)-=flux(k);                                        \</span>
<a name="l00936"></a>00936 <span class="preprocessor">        }                                                                \</span>
<a name="l00937"></a>00937 <span class="preprocessor">      }                                                                        \</span>
<a name="l00938"></a>00938 <span class="preprocessor">    return resu;                                                        \</span>
<a name="l00939"></a>00939 <span class="preprocessor">  }                                                                        \</span>
<a name="l00940"></a>00940 <span class="preprocessor">  DoubleTab&amp; It_PolyMAC_Elem(_TYPE_)::calculer(const DoubleTab&amp; inco, DoubleTab&amp; resu) const \</span>
<a name="l00941"></a>00941 <span class="preprocessor">  {                                                                        \</span>
<a name="l00942"></a>00942 <span class="preprocessor">    operator_egal(resu, 0., VECT_REAL_ITEMS);                                \</span>
<a name="l00943"></a>00943 <span class="preprocessor">    return ajouter(inco,resu);                                                \</span>
<a name="l00944"></a>00944 <span class="preprocessor">  }                                                                        \</span>
<a name="l00945"></a>00945 <span class="preprocessor">  void  It_PolyMAC_Elem(_TYPE_)::modifier_flux() const                        \</span>
<a name="l00946"></a>00946 <span class="preprocessor">  {                                                                        \</span>
<a name="l00947"></a>00947 <span class="preprocessor">    if (op_base-&gt;equation().inconnue().le_nom()==&quot;temperature&quot;                \</span>
<a name="l00948"></a>00948 <span class="preprocessor">        &amp;&amp; !( sub_type(Operateur_Diff_base,op_base.valeur()) &amp;&amp; ref_cast(Operateur_Diff_base,op_base.valeur()).diffusivite().le_nom() == &quot;conductivite&quot; ) ) \</span>
<a name="l00949"></a>00949 <span class="preprocessor">      {                                                                        \</span>
<a name="l00950"></a>00950 <span class="preprocessor">        DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \</span>
<a name="l00951"></a>00951 <span class="preprocessor">        const Zone_PolyMAC&amp; la_zone_vdf=ref_cast(Zone_PolyMAC,op_base-&gt;equation().zone_dis().valeur());        \</span>
<a name="l00952"></a>00952 <span class="preprocessor">        const Champ_base&amp; rho = (op_base-&gt;equation()).milieu().masse_volumique(); \</span>
<a name="l00953"></a>00953 <span class="preprocessor">        const Champ_Don&amp; Cp = (op_base-&gt;equation()).milieu().capacite_calorifique(); \</span>
<a name="l00954"></a>00954 <span class="preprocessor">        const IntTab&amp; face_voisins=la_zone_vdf.face_voisins();                \</span>
<a name="l00955"></a>00955 <span class="preprocessor">        int rho_uniforme=(sub_type(Champ_Uniforme,rho) ? 1:0); \</span>
<a name="l00956"></a>00956 <span class="preprocessor">        int cp_uniforme=(sub_type(Champ_Uniforme,Cp.valeur()) ? 1:0); \</span>
<a name="l00957"></a>00957 <span class="preprocessor">        int is_rho_u=op_base-&gt;equation().probleme().is_dilatable();                \</span>
<a name="l00958"></a>00958 <span class="preprocessor">        if (is_rho_u)                                                   \</span>
<a name="l00959"></a>00959 <span class="preprocessor">          {                                                                \</span>
<a name="l00960"></a>00960 <span class="preprocessor">            const Operateur_base&amp; op=op_base.valeur();                        \</span>
<a name="l00961"></a>00961 <span class="preprocessor">            is_rho_u=0;                                                        \</span>
<a name="l00962"></a>00962 <span class="preprocessor">            if (sub_type(Op_Conv_PolyMAC_iterateur_base,op))                                \</span>
<a name="l00963"></a>00963 <span class="preprocessor">              if (ref_cast(Op_Conv_PolyMAC_iterateur_base,op).vitesse().le_nom()==&quot;rho_u&quot;) \</span>
<a name="l00964"></a>00964 <span class="preprocessor">                is_rho_u=1;                                                \</span>
<a name="l00965"></a>00965 <span class="preprocessor">          }                                                                \</span>
<a name="l00966"></a>00966 <span class="preprocessor">        double Cp_=0,rho_=0;                                                \</span>
<a name="l00967"></a>00967 <span class="preprocessor">        const int&amp; nb_faces_bords=la_zone_vdf.nb_faces_bord();        \</span>
<a name="l00968"></a>00968 <span class="preprocessor">        for (int face=0; face&lt;nb_faces_bords; face++)                \</span>
<a name="l00969"></a>00969 <span class="preprocessor">          {                                                                \</span>
<a name="l00970"></a>00970 <span class="preprocessor">            int num_elem=face_voisins(face,0);                        \</span>
<a name="l00971"></a>00971 <span class="preprocessor">            if (num_elem == -1) num_elem = face_voisins(face,1);        \</span>
<a name="l00972"></a>00972 <span class="preprocessor">            if (cp_uniforme) Cp_=Cp(0,0);                                \</span>
<a name="l00973"></a>00973 <span class="preprocessor">            else                                                        \</span>
<a name="l00974"></a>00974 <span class="preprocessor">              if (Cp.nb_comp()==1) Cp_=Cp(num_elem);                        \</span>
<a name="l00975"></a>00975 <span class="preprocessor">              else Cp_=Cp(num_elem,0);                                        \</span>
<a name="l00976"></a>00976 <span class="preprocessor">            if (rho_uniforme) rho_=rho(0,0);                                \</span>
<a name="l00977"></a>00977 <span class="preprocessor">            else                                                        \</span>
<a name="l00978"></a>00978 <span class="preprocessor">              if (rho.nb_comp()==1) rho_=rho(num_elem);                        \</span>
<a name="l00979"></a>00979 <span class="preprocessor">              else rho_=rho(num_elem,0);                                \</span>
<a name="l00980"></a>00980 <span class="preprocessor">            </span><span class="comment">/* si on est en QC/WC temperature on a calcule div(rhou * T) */</span> \
<a name="l00981"></a>00981             <span class="comment">/* il ne faut pas remultiplier par rho */</span>                        \
<a name="l00982"></a>00982             if (is_rho_u) rho_=1;                                        \
<a name="l00983"></a>00983             flux_bords(face,0) *= (rho_*Cp_);                                \
<a name="l00984"></a>00984           }                                                                \
<a name="l00985"></a>00985       }                                                                        \
<a name="l00986"></a>00986   }                                                                        \
<a name="l00987"></a>00987   int It_PolyMAC_Elem(_TYPE_)::impr(Sortie&amp; os) const                        \
<a name="l00988"></a>00988   {                                                                        \
<a name="l00989"></a>00989     const Zone&amp; mazone=la_zone-&gt;zone();                                        \
<a name="l00990"></a>00990     const int impr_bord=(mazone.Bords_a_imprimer().est_vide() ? 0:1);        \
<a name="l00991"></a>00991     double temps=la_zcl-&gt;equation().probleme().schema_temps().temps_courant(); \
<a name="l00992"></a>00992     Nom espace=&quot; \t&quot;;                                                        \
<a name="l00993"></a>00993     DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \
<a name="l00994"></a>00994     DoubleVect bilan(flux_bords.dimension(1));                                \
<a name="l00995"></a>00995     int k,face;                                                                \
<a name="l00996"></a>00996     int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \
<a name="l00997"></a>00997     DoubleTrav flux_bords2( 3, nb_front_Cl , flux_bords.dimension(1)) ;         \
<a name="l00998"></a>00998     flux_bords2=0;                                                              \
<a name="l00999"></a>00999     <span class="comment">/*flux_bord(k)          -&gt;   flux_bords2(0,num_cl,k) */</span> \
<a name="l01000"></a>01000     <span class="comment">/*flux_bord_perio1(k)   -&gt;   flux_bords2(1,num_cl,k) */</span>\
<a name="l01001"></a>01001     <span class="comment">/*flux_bord_perio2(k)   -&gt;   flux_bords2(2,num_cl,k) */</span>\
<a name="l01002"></a>01002     for (int num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)\
<a name="l01003"></a>01003       {\
<a name="l01004"></a>01004         const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);\
<a name="l01005"></a>01005         const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());\
<a name="l01006"></a>01006         int ndeb = frontiere_dis.num_premiere_face();\
<a name="l01007"></a>01007         int nfin = ndeb + frontiere_dis.nb_faces();\
<a name="l01008"></a>01008         int periodicite = (type_cl(la_cl)==periodique?1:0);\
<a name="l01009"></a>01009         for (face=ndeb; face&lt;nfin; face++)                                        \
<a name="l01010"></a>01010           for(k=0; k&lt;flux_bords.dimension(1); k++)\
<a name="l01011"></a>01011             {\
<a name="l01012"></a>01012               flux_bords2(0,num_cl,k)+=flux_bords(face, k);\
<a name="l01013"></a>01013               if(periodicite)\
<a name="l01014"></a>01014                 {\
<a name="l01015"></a>01015                   if( face &lt; (ndeb+frontiere_dis.nb_faces()/2) )                      \
<a name="l01016"></a>01016                     flux_bords2(1,num_cl,k)+=flux_bords(face, k);\
<a name="l01017"></a>01017                   else                                                                \
<a name="l01018"></a>01018                     flux_bords2(2,num_cl,k)+=flux_bords(face, k);\
<a name="l01019"></a>01019                 }                                                                     \
<a name="l01020"></a>01020             }                                                                       \
<a name="l01021"></a>01021       } <span class="comment">/* fin for num_cl */</span>                                                      \
<a name="l01022"></a>01022     mp_sum_for_each_item(flux_bords2);\
<a name="l01023"></a>01023     if (je_suis_maitre()) \
<a name="l01024"></a>01024     {\
<a name="l01025"></a>01025         SFichier Flux;op_base-&gt;ouvrir_fichier(Flux,&quot;&quot;,1);                        \
<a name="l01026"></a>01026         Flux&lt;&lt; temps;                                        \
<a name="l01027"></a>01027         for (int num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)\
<a name="l01028"></a>01028           {\
<a name="l01029"></a>01029             const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);\
<a name="l01030"></a>01030             int periodicite = (type_cl(la_cl)==periodique?1:0);\
<a name="l01031"></a>01031             for(k=0; k&lt;flux_bords.dimension(1); k++)\
<a name="l01032"></a>01032               {\
<a name="l01033"></a>01033                 bilan(k)+=flux_bords2(0,num_cl,k);\
<a name="l01034"></a>01034                 if(periodicite) \
<a name="l01035"></a>01035                    Flux&lt;&lt; espace &lt;&lt; flux_bords2(1,num_cl,k) &lt;&lt; espace &lt;&lt; flux_bords2(2,num_cl,k);\
<a name="l01036"></a>01036                 else                                                    \
<a name="l01037"></a><a class="code" href="MItPolyMACEl_8h.html#a0246ce6ef60c98f9b1938b7091b2d037">01037</a>                    Flux&lt;&lt; espace &lt;&lt; flux_bords2(0,num_cl,k);\
<a name="l01038"></a>01038               }                                                                       \
<a name="l01039"></a>01039           }\
<a name="l01040"></a>01040        for(k=0; k&lt;flux_bords.dimension(1); k++)\
<a name="l01041"></a>01041           Flux&lt;&lt; espace &lt;&lt; bilan(k); \
<a name="l01042"></a>01042        Flux &lt;&lt; finl;\
<a name="l01043"></a>01043      }\
<a name="l01044"></a>01044     const LIST(Nom)&amp; Liste_Bords_a_imprimer = la_zone-&gt;zone().Bords_a_imprimer();\
<a name="l01045"></a>01045     if (!Liste_Bords_a_imprimer.est_vide())\
<a name="l01046"></a>01046     { \
<a name="l01047"></a>01047        EcrFicPartage Flux_face;\
<a name="l01048"></a>01048        op_base-&gt;ouvrir_fichier_partage(Flux_face,&quot;&quot;,impr_bord); \
<a name="l01049"></a>01049        for (int num_cl=0; num_cl&lt;nb_front_Cl; num_cl++)\
<a name="l01050"></a>01050          {\
<a name="l01051"></a>01051            const Frontiere_dis_base&amp; la_fr = la_zcl-&gt;les_conditions_limites(num_cl).frontiere_dis(); \
<a name="l01052"></a>01052            const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);\
<a name="l01053"></a>01053            const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());\
<a name="l01054"></a>01054            int ndeb = frontiere_dis.num_premiere_face();\
<a name="l01055"></a>01055            int nfin = ndeb + frontiere_dis.nb_faces();\
<a name="l01056"></a>01056            if (mazone.Bords_a_imprimer().contient(la_fr.le_nom()))\
<a name="l01057"></a>01057              {\
<a name="l01058"></a>01058                Flux_face &lt;&lt; &quot;# Flux par face sur &quot; &lt;&lt; la_fr.le_nom() &lt;&lt; &quot; au temps &quot; &lt;&lt; temps &lt;&lt; &quot; : &quot; &lt;&lt; finl;\
<a name="l01059"></a>01059                for (face=ndeb; face&lt;nfin; face++)\
<a name="l01060"></a>01060                  {\
<a name="l01061"></a>01061                    if (dimension == 2)                                            \
<a name="l01062"></a>01062                      Flux_face &lt;&lt; &quot;# Face a x= &quot; &lt;&lt; la_zone-&gt;xv(face,0) &lt;&lt; &quot; y= &quot; &lt;&lt; la_zone-&gt;xv(face,1) &lt;&lt; &quot; : &quot;;\
<a name="l01063"></a>01063                    else if (dimension == 3)                                        \
<a name="l01064"></a>01064                      Flux_face &lt;&lt; &quot;# Face a x= &quot; &lt;&lt; la_zone-&gt;xv(face,0) &lt;&lt; &quot; y= &quot; &lt;&lt; la_zone-&gt;xv(face,1) &lt;&lt; &quot; z= &quot; &lt;&lt; la_zone-&gt;xv(face,2) &lt;&lt; &quot; : &quot;;\
<a name="l01065"></a>01065                    for(k=0; k&lt;flux_bords.dimension(1); k++)                        \
<a name="l01066"></a>01066                      Flux_face &lt;&lt; flux_bords(face, k) &lt;&lt; &quot; &quot;;\
<a name="l01067"></a>01067                    Flux_face &lt;&lt; finl;\
<a name="l01068"></a>01068                  }                                                                \
<a name="l01069"></a>01069                Flux_face.syncfile();\
<a name="l01070"></a>01070              }                                                                        \
<a name="l01071"></a>01071          }\
<a name="l01072"></a>01072       }\
<a name="l01073"></a>01073      return 1;\
<a name="l01074"></a>01074   }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="preprocessor">#define implemente4_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l01077"></a>01077 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::contribuer_au_second_membre(DoubleTab&amp; resu) const \</span>
<a name="l01078"></a>01078 <span class="preprocessor">  {                                                                        \</span>
<a name="l01079"></a>01079 <span class="preprocessor">    ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();                        \</span>
<a name="l01080"></a>01080 <span class="preprocessor">    assert(resu.nb_dim() &lt; 3);                                                \</span>
<a name="l01081"></a>01081 <span class="preprocessor">    assert(la_zcl.non_nul());                                                \</span>
<a name="l01082"></a>01082 <span class="preprocessor">    assert(la_zone.non_nul());                                                \</span>
<a name="l01083"></a>01083 <span class="preprocessor">    int ncomp=1;                                                        \</span>
<a name="l01084"></a>01084 <span class="preprocessor">    if (resu.nb_dim() == 2)                                                \</span>
<a name="l01085"></a>01085 <span class="preprocessor">      ncomp=resu.dimension(1);                                                \</span>
<a name="l01086"></a>01086 <span class="preprocessor">    assert(op_base-&gt;flux_bords().dimension(0)==la_zone-&gt;nb_faces_bord()); </span><span class="comment">/* resize deja fait */</span> \
<a name="l01087"></a>01087     if( ncomp == 1) <span class="comment">/* cas scalaire */</span>                                        \
<a name="l01088"></a>01088       {                                                                        \
<a name="l01089"></a>01089         contribuer_au_second_membre_bords(resu) ;                        \
<a name="l01090"></a>01090         contribuer_au_second_membre_interne(resu) ;                        \
<a name="l01091"></a>01091       }                                                                        \
<a name="l01092"></a>01092     else <span class="comment">/* cas vectoriel */</span>                                                \
<a name="l01093"></a>01093       {                                                                        \
<a name="l01094"></a>01094         contribuer_au_second_membre_bords(resu, ncomp) ;                \
<a name="l01095"></a>01095         contribuer_au_second_membre_interne(resu, ncomp) ;                \
<a name="l01096"></a>01096       }                                                                        \
<a name="l01097"></a>01097   }                                                                        \
<a name="l01098"></a>01098   void It_PolyMAC_Elem(_TYPE_)::contribuer_au_second_membre_bords(DoubleTab&amp; resu) const \
<a name="l01099"></a>01099   {                                                                        \
<a name="l01100"></a>01100     int elem1, elem2;                                                        \
<a name="l01101"></a>01101     int ndeb, nfin;                                                        \
<a name="l01102"></a>01102     int face;                                                                \
<a name="l01103"></a>01103     int num_cl=0;                                                        \
<a name="l01104"></a>01104     double flux;                                                        \
<a name="l01105"></a>01105     int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \
<a name="l01106"></a>01106     DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \
<a name="l01107"></a>01107     for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \
<a name="l01108"></a>01108       <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>                \
<a name="l01109"></a>01109       const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \
<a name="l01110"></a>01110       const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \
<a name="l01111"></a>01111       ndeb = frontiere_dis.num_premiere_face();                                \
<a name="l01112"></a>01112       nfin = ndeb + frontiere_dis.nb_faces();                                \
<a name="l01113"></a>01113       switch(type_cl(la_cl)){                                                \
<a name="l01114"></a>01114       case symetrie :                                                        \
<a name="l01115"></a>01115         if (flux_evaluateur.calculer_flux_faces_symetrie()){                \
<a name="l01116"></a>01116           const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \
<a name="l01117"></a>01117           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01118"></a>01118             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01119"></a>01119             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01120"></a>01120               {                                                                \
<a name="l01121"></a>01121                 resu[elem1]+=flux;                                        \
<a name="l01122"></a>01122                 flux_bords(face,0)+=flux;                                \
<a name="l01123"></a>01123               }                                                                \
<a name="l01124"></a>01124             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01125"></a>01125               {                                                                \
<a name="l01126"></a>01126                 resu[elem2]-=flux;                                        \
<a name="l01127"></a>01127                 flux_bords(face,0)-=flux;                                \
<a name="l01128"></a>01128               }                                                                \
<a name="l01129"></a>01129           }                                                                \
<a name="l01130"></a>01130         }                                                                \
<a name="l01131"></a>01131         break;                                                                \
<a name="l01132"></a>01132       case sortie_libre :                                                \
<a name="l01133"></a>01133         if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \
<a name="l01134"></a>01134           const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \
<a name="l01135"></a>01135           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01136"></a>01136             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01137"></a>01137             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01138"></a>01138               {                                                                \
<a name="l01139"></a>01139                 resu[elem1]+=flux;                                        \
<a name="l01140"></a>01140                 flux_bords(face,0)+=flux;                                \
<a name="l01141"></a>01141               }                                                                \
<a name="l01142"></a>01142             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01143"></a>01143               {                                                                \
<a name="l01144"></a>01144                 resu[elem2]-=flux;                                        \
<a name="l01145"></a>01145                 flux_bords(face,0)-=flux;                                \
<a name="l01146"></a>01146               }                                                                \
<a name="l01147"></a>01147           }                                                                \
<a name="l01148"></a>01148         }                                                                \
<a name="l01149"></a>01149         break;                                                                \
<a name="l01150"></a>01150       case entree_fluide :                                                \
<a name="l01151"></a>01151         if (flux_evaluateur.calculer_flux_faces_entree_fluide()){        \
<a name="l01152"></a>01152           const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \
<a name="l01153"></a>01153           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01154"></a>01154             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01155"></a>01155             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01156"></a>01156               {                                                                \
<a name="l01157"></a>01157                 resu[elem1]+=flux;                                        \
<a name="l01158"></a>01158                 flux_bords(face,0)+=flux;                                \
<a name="l01159"></a>01159               }                                                                \
<a name="l01160"></a>01160             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01161"></a>01161               {                                                                \
<a name="l01162"></a>01162                 resu[elem2]-=flux;                                        \
<a name="l01163"></a>01163                 flux_bords(face,0)-=flux;                                \
<a name="l01164"></a>01164               }                                                                \
<a name="l01165"></a>01165           }                                                                \
<a name="l01166"></a>01166         }                                                                \
<a name="l01167"></a>01167         break;                                                                \
<a name="l01168"></a>01168       case paroi_fixe :                                                        \
<a name="l01169"></a>01169         if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \
<a name="l01170"></a>01170           const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \
<a name="l01171"></a>01171           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01172"></a>01172             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01173"></a>01173             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01174"></a>01174               {                                                                \
<a name="l01175"></a>01175                 resu[elem1]+=flux;                                        \
<a name="l01176"></a>01176                 flux_bords(face,0)+=flux;                                \
<a name="l01177"></a>01177               }                                                                \
<a name="l01178"></a>01178             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01179"></a>01179               {                                                                \
<a name="l01180"></a>01180                 resu[elem2]-=flux;                                        \
<a name="l01181"></a>01181                 flux_bords(face,0)-=flux;                                \
<a name="l01182"></a>01182               }                                                                \
<a name="l01183"></a>01183           }                                                                \
<a name="l01184"></a>01184         }                                                                \
<a name="l01185"></a>01185         break;                                                                \
<a name="l01186"></a>01186       case paroi_defilante :                                                \
<a name="l01187"></a>01187         if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \
<a name="l01188"></a>01188           const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \
<a name="l01189"></a>01189           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01190"></a>01190             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01191"></a>01191             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01192"></a>01192               {                                                                \
<a name="l01193"></a>01193                 resu[elem1]+=flux;                                        \
<a name="l01194"></a>01194                 flux_bords(face,0)+=flux;                                \
<a name="l01195"></a>01195               }                                                                \
<a name="l01196"></a>01196             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01197"></a>01197               {                                                                \
<a name="l01198"></a>01198                 resu[elem2]-=flux;                                        \
<a name="l01199"></a>01199                 flux_bords(face,0)-=flux;                                \
<a name="l01200"></a>01200               }                                                                \
<a name="l01201"></a>01201           }                                                                \
<a name="l01202"></a>01202         }                                                                \
<a name="l01203"></a>01203         break;                                                                \
<a name="l01204"></a>01204       case paroi_adiabatique :                                                \
<a name="l01205"></a>01205         if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \
<a name="l01206"></a>01206           const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \
<a name="l01207"></a>01207           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01208"></a>01208             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01209"></a>01209             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01210"></a>01210               {                                                                \
<a name="l01211"></a>01211                 resu[elem1]+=flux;                                        \
<a name="l01212"></a>01212                 flux_bords(face,0)+=flux;                                \
<a name="l01213"></a>01213               }                                                                \
<a name="l01214"></a>01214             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01215"></a>01215               {                                                                \
<a name="l01216"></a>01216                 resu[elem2]-=flux;                                        \
<a name="l01217"></a>01217                 flux_bords(face,0)-=flux;                                \
<a name="l01218"></a>01218               }                                                                \
<a name="l01219"></a>01219           }                                                                \
<a name="l01220"></a>01220         }                                                                \
<a name="l01221"></a>01221         break;                                                                \
<a name="l01222"></a>01222       case paroi :                                                        \
<a name="l01223"></a>01223         if (flux_evaluateur.calculer_flux_faces_paroi()){                \
<a name="l01224"></a>01224           const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \
<a name="l01225"></a>01225           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01226"></a>01226             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01227"></a>01227             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01228"></a>01228               {                                                                \
<a name="l01229"></a>01229                 resu[elem1]+=flux;                                        \
<a name="l01230"></a>01230                 flux_bords(face,0)+=flux;                                \
<a name="l01231"></a>01231               }                                                                \
<a name="l01232"></a>01232             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01233"></a>01233               {                                                                \
<a name="l01234"></a>01234                 resu[elem2]-=flux;                                        \
<a name="l01235"></a>01235                 flux_bords(face,0)-=flux;                                \
<a name="l01236"></a>01236               }                                                                \
<a name="l01237"></a>01237           }                                                                \
<a name="l01238"></a>01238         }                                                                \
<a name="l01239"></a>01239         break;                                                                \
<a name="l01240"></a>01240       case echange_externe_impose :                                        \
<a name="l01241"></a>01241         if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \
<a name="l01242"></a>01242           const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \
<a name="l01243"></a>01243                                                                                 \
<a name="l01244"></a>01244           int boundary_index=-1;                                                        \
<a name="l01245"></a>01245           if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \
<a name="l01246"></a>01246             boundary_index=num_cl;                                                  \
<a name="l01247"></a>01247                                                                                 \
<a name="l01248"></a>01248           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01249"></a>01249             int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \
<a name="l01250"></a>01250             flux = flux_evaluateur.secmem_face(boundary_index,face,local_face, cl, ndeb); \
<a name="l01251"></a>01251             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01252"></a>01252               {                                                                \
<a name="l01253"></a>01253                 resu[elem1]+=flux;                                        \
<a name="l01254"></a>01254                 flux_bords(face,0)+=flux;                                \
<a name="l01255"></a>01255               }                                                                \
<a name="l01256"></a>01256             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01257"></a>01257               {                                                                \
<a name="l01258"></a>01258                 resu[elem2]-=flux;                                        \
<a name="l01259"></a>01259                 flux_bords(face,0)-=flux;                                \
<a name="l01260"></a>01260               }                                                                \
<a name="l01261"></a>01261           }                                                                \
<a name="l01262"></a>01262         }                                                                \
<a name="l01263"></a>01263         break;                                                                \
<a name="l01264"></a>01264       case echange_global_impose :                                        \
<a name="l01265"></a>01265         if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \
<a name="l01266"></a>01266           const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \
<a name="l01267"></a>01267           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01268"></a>01268             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01269"></a>01269             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01270"></a>01270               {                                                                \
<a name="l01271"></a>01271                 resu[elem1]+=flux;                                        \
<a name="l01272"></a>01272                 flux_bords(face,0)+=flux;                                \
<a name="l01273"></a>01273               }                                                                \
<a name="l01274"></a>01274             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01275"></a>01275               {                                                                \
<a name="l01276"></a>01276                 resu[elem2]-=flux;                                        \
<a name="l01277"></a>01277                 flux_bords(face,0)-=flux;                                \
<a name="l01278"></a>01278               }                                                                \
<a name="l01279"></a>01279           }                                                                \
<a name="l01280"></a>01280         }                                                                \
<a name="l01281"></a>01281         break;                                                                \
<a name="l01282"></a>01282       case nscbc :                                                        \
<a name="l01283"></a><a class="code" href="MItPolyMACEl_8h.html#aa3b5a1e5d14fe223d9c8a1dce0bdc805">01283</a>         if (flux_evaluateur.calculer_flux_faces_NSCBC()){                \
<a name="l01284"></a>01284           const NSCBC&amp; cl =(const NSCBC&amp;) (la_cl.valeur());                \
<a name="l01285"></a>01285           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01286"></a>01286             flux = flux_evaluateur.secmem_face(face, cl, ndeb);                \
<a name="l01287"></a>01287             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01288"></a>01288               {                                                                \
<a name="l01289"></a>01289                 resu[elem1]+=flux;                                        \
<a name="l01290"></a>01290                 flux_bords(face,0)+=flux;                                \
<a name="l01291"></a>01291               }                                                                \
<a name="l01292"></a>01292             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01293"></a>01293               {                                                                \
<a name="l01294"></a>01294                 resu[elem2]-=flux;                                        \
<a name="l01295"></a>01295                 flux_bords(face,0)-=flux;                                \
<a name="l01296"></a>01296               }                                                                \
<a name="l01297"></a>01297           }                                                                \
<a name="l01298"></a>01298         }                                                                \
<a name="l01299"></a>01299         break;                                                                \
<a name="l01300"></a>01300       case periodique :                                                        \
<a name="l01301"></a>01301         if (flux_evaluateur.calculer_flux_faces_periodique()){                \
<a name="l01302"></a>01302           const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \
<a name="l01303"></a>01303           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01304"></a>01304             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01305"></a>01305               resu[elem1]+=0.5*flux_evaluateur.secmem_face(face, cl, ndeb); \
<a name="l01306"></a>01306             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01307"></a>01307               resu[elem2]-=0.5*flux_evaluateur.secmem_face(face, cl, ndeb); \
<a name="l01308"></a>01308           }                                                                \
<a name="l01309"></a>01309         }                                                                \
<a name="l01310"></a>01310         break;                                                                \
<a name="l01311"></a>01311       case scalaire_impose_paroi :                                            \
<a name="l01312"></a>01312         break;                                                                \
<a name="l01313"></a>01313         <span class="comment">/*                                                                \</span>
<a name="l01314"></a>01314 <span class="comment">                                                                          case nouvelle_Cl_PolyMAC : \</span>
<a name="l01315"></a>01315 <span class="comment">                                                                          if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l01316"></a>01316 <span class="comment">                                                                          const Nouvelle_Cl_PolyMAC&amp; cl =(const Nouvelle_Cl_PolyMAC&amp;) (la_cl.valeur()); \</span>
<a name="l01317"></a>01317 <span class="comment">                                                                          for (face=ndeb; face&lt;nfin; face++) { \</span>
<a name="l01318"></a>01318 <span class="comment">                                                                          if ( (elem1=elem(face,0)) &gt; -1) \</span>
<a name="l01319"></a>01319 <span class="comment">                                                                          resu[elem1]+=flux_evaluateur.secmem_face(face, cl, ndeb); \</span>
<a name="l01320"></a>01320 <span class="comment">                                                                          if ( (elem2=elem(face,1)) &gt; -1) \</span>
<a name="l01321"></a>01321 <span class="comment">                                                                          resu[elem2]-=flux_evaluateur.secmem_face(face, cl, ndeb); \</span>
<a name="l01322"></a>01322 <span class="comment">                                                                          } \</span>
<a name="l01323"></a>01323 <span class="comment">                                                                          } \</span>
<a name="l01324"></a>01324 <span class="comment">                                                                          break; \</span>
<a name="l01325"></a>01325 <span class="comment">        */</span>                                                                \
<a name="l01326"></a>01326       default :                                                                \
<a name="l01327"></a>01327         Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \
<a name="l01328"></a>01328         exit();                                                                \
<a name="l01329"></a>01329         break;                                                                \
<a name="l01330"></a>01330       }                                                                        \
<a name="l01331"></a>01331     }                                                                        \
<a name="l01332"></a>01332   }
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 <span class="preprocessor">#define implemente5_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l01335"></a>01335 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::contribuer_au_second_membre_bords(DoubleTab&amp; resu,int ncomp) const \</span>
<a name="l01336"></a>01336 <span class="preprocessor">  {                                                                        \</span>
<a name="l01337"></a>01337 <span class="preprocessor">    int elem1, elem2;                                                        \</span>
<a name="l01338"></a>01338 <span class="preprocessor">    int ndeb, nfin;                                                        \</span>
<a name="l01339"></a>01339 <span class="preprocessor">    int face,k;                                                                \</span>
<a name="l01340"></a>01340 <span class="preprocessor">    DoubleVect flux(ncomp);                                                \</span>
<a name="l01341"></a>01341 <span class="preprocessor">    int num_cl=0;                                                        \</span>
<a name="l01342"></a>01342 <span class="preprocessor">    int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \</span>
<a name="l01343"></a>01343 <span class="preprocessor">    DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \</span>
<a name="l01344"></a>01344 <span class="preprocessor">    for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \</span>
<a name="l01345"></a>01345 <span class="preprocessor">      const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \</span>
<a name="l01346"></a>01346 <span class="preprocessor">      const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \</span>
<a name="l01347"></a>01347 <span class="preprocessor">      ndeb = frontiere_dis.num_premiere_face();                                \</span>
<a name="l01348"></a>01348 <span class="preprocessor">      nfin = ndeb + frontiere_dis.nb_faces();                                \</span>
<a name="l01349"></a>01349 <span class="preprocessor">      switch(type_cl(la_cl)){                                                \</span>
<a name="l01350"></a>01350 <span class="preprocessor">      case symetrie :                                                        \</span>
<a name="l01351"></a>01351 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_symetrie()){                \</span>
<a name="l01352"></a>01352 <span class="preprocessor">          const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \</span>
<a name="l01353"></a>01353 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01354"></a>01354 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01355"></a>01355 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01356"></a>01356 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01357"></a>01357 <span class="preprocessor">                {                                                        \</span>
<a name="l01358"></a>01358 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01359"></a>01359 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01360"></a>01360 <span class="preprocessor">                }                                                        \</span>
<a name="l01361"></a>01361 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01362"></a>01362 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01363"></a>01363 <span class="preprocessor">                {                                                        \</span>
<a name="l01364"></a>01364 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01365"></a>01365 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01366"></a>01366 <span class="preprocessor">                }                                                        \</span>
<a name="l01367"></a>01367 <span class="preprocessor">          }                                                                \</span>
<a name="l01368"></a>01368 <span class="preprocessor">        }                                                                \</span>
<a name="l01369"></a>01369 <span class="preprocessor">        break;                                                                \</span>
<a name="l01370"></a>01370 <span class="preprocessor">      case sortie_libre :                                                \</span>
<a name="l01371"></a>01371 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \</span>
<a name="l01372"></a>01372 <span class="preprocessor">          const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \</span>
<a name="l01373"></a>01373 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01374"></a>01374 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01375"></a>01375 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01376"></a>01376 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01377"></a>01377 <span class="preprocessor">                {                                                        \</span>
<a name="l01378"></a>01378 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01379"></a>01379 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01380"></a>01380 <span class="preprocessor">                }                                                        \</span>
<a name="l01381"></a>01381 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01382"></a>01382 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01383"></a>01383 <span class="preprocessor">                {                                                        \</span>
<a name="l01384"></a>01384 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01385"></a>01385 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01386"></a>01386 <span class="preprocessor">                }                                                        \</span>
<a name="l01387"></a>01387 <span class="preprocessor">          }                                                                \</span>
<a name="l01388"></a>01388 <span class="preprocessor">        }                                                                \</span>
<a name="l01389"></a>01389 <span class="preprocessor">        break;                                                                \</span>
<a name="l01390"></a>01390 <span class="preprocessor">      case entree_fluide :                                                \</span>
<a name="l01391"></a>01391 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_entree_fluide()){        \</span>
<a name="l01392"></a>01392 <span class="preprocessor">          const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \</span>
<a name="l01393"></a>01393 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01394"></a>01394 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01395"></a>01395 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01396"></a>01396 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01397"></a>01397 <span class="preprocessor">                {                                                        \</span>
<a name="l01398"></a>01398 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01399"></a>01399 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01400"></a>01400 <span class="preprocessor">                }                                                        \</span>
<a name="l01401"></a>01401 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01402"></a>01402 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01403"></a>01403 <span class="preprocessor">                {                                                        \</span>
<a name="l01404"></a>01404 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01405"></a>01405 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01406"></a>01406 <span class="preprocessor">                }                                                        \</span>
<a name="l01407"></a>01407 <span class="preprocessor">          }                                                                \</span>
<a name="l01408"></a>01408 <span class="preprocessor">        }                                                                \</span>
<a name="l01409"></a>01409 <span class="preprocessor">        break;                                                                \</span>
<a name="l01410"></a>01410 <span class="preprocessor">      case paroi_fixe :                                                        \</span>
<a name="l01411"></a>01411 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \</span>
<a name="l01412"></a>01412 <span class="preprocessor">          const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \</span>
<a name="l01413"></a>01413 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01414"></a>01414 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01415"></a>01415 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01416"></a>01416 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01417"></a>01417 <span class="preprocessor">                {                                                        \</span>
<a name="l01418"></a>01418 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01419"></a>01419 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01420"></a>01420 <span class="preprocessor">                }                                                        \</span>
<a name="l01421"></a>01421 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01422"></a>01422 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01423"></a>01423 <span class="preprocessor">                {                                                        \</span>
<a name="l01424"></a>01424 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01425"></a>01425 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01426"></a>01426 <span class="preprocessor">                }                                                        \</span>
<a name="l01427"></a>01427 <span class="preprocessor">          }                                                                \</span>
<a name="l01428"></a>01428 <span class="preprocessor">        }                                                                \</span>
<a name="l01429"></a>01429 <span class="preprocessor">        break;                                                                \</span>
<a name="l01430"></a>01430 <span class="preprocessor">      case paroi_defilante :                                                \</span>
<a name="l01431"></a>01431 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \</span>
<a name="l01432"></a>01432 <span class="preprocessor">          const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \</span>
<a name="l01433"></a>01433 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01434"></a>01434 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01435"></a>01435 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01436"></a>01436 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01437"></a>01437 <span class="preprocessor">                {                                                        \</span>
<a name="l01438"></a>01438 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01439"></a>01439 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01440"></a>01440 <span class="preprocessor">                }                                                        \</span>
<a name="l01441"></a>01441 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01442"></a>01442 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01443"></a>01443 <span class="preprocessor">                {                                                        \</span>
<a name="l01444"></a>01444 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01445"></a>01445 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01446"></a>01446 <span class="preprocessor">                }                                                        \</span>
<a name="l01447"></a>01447 <span class="preprocessor">          }                                                                \</span>
<a name="l01448"></a>01448 <span class="preprocessor">        }                                                                \</span>
<a name="l01449"></a>01449 <span class="preprocessor">        break;                                                                \</span>
<a name="l01450"></a>01450 <span class="preprocessor">      case paroi_adiabatique :                                                \</span>
<a name="l01451"></a>01451 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \</span>
<a name="l01452"></a>01452 <span class="preprocessor">          const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \</span>
<a name="l01453"></a>01453 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01454"></a>01454 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01455"></a>01455 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01456"></a>01456 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01457"></a>01457 <span class="preprocessor">                {                                                        \</span>
<a name="l01458"></a>01458 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01459"></a>01459 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01460"></a>01460 <span class="preprocessor">                }                                                        \</span>
<a name="l01461"></a>01461 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01462"></a>01462 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01463"></a>01463 <span class="preprocessor">                {                                                        \</span>
<a name="l01464"></a>01464 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01465"></a>01465 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01466"></a>01466 <span class="preprocessor">                }                                                        \</span>
<a name="l01467"></a>01467 <span class="preprocessor">          }                                                                \</span>
<a name="l01468"></a>01468 <span class="preprocessor">        }                                                                \</span>
<a name="l01469"></a>01469 <span class="preprocessor">        break;                                                                \</span>
<a name="l01470"></a>01470 <span class="preprocessor">      case paroi :                                                        \</span>
<a name="l01471"></a>01471 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi()){                \</span>
<a name="l01472"></a>01472 <span class="preprocessor">          const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \</span>
<a name="l01473"></a>01473 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01474"></a>01474 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01475"></a>01475 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01476"></a>01476 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01477"></a>01477 <span class="preprocessor">                {                                                        \</span>
<a name="l01478"></a>01478 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01479"></a>01479 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01480"></a>01480 <span class="preprocessor">                }                                                        \</span>
<a name="l01481"></a>01481 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01482"></a>01482 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01483"></a>01483 <span class="preprocessor">                {                                                        \</span>
<a name="l01484"></a>01484 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01485"></a>01485 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01486"></a>01486 <span class="preprocessor">                }                                                        \</span>
<a name="l01487"></a>01487 <span class="preprocessor">          }                                                                \</span>
<a name="l01488"></a>01488 <span class="preprocessor">        }                                                                \</span>
<a name="l01489"></a>01489 <span class="preprocessor">        break;                                                                \</span>
<a name="l01490"></a>01490 <span class="preprocessor">      case echange_externe_impose :                                        \</span>
<a name="l01491"></a>01491 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \</span>
<a name="l01492"></a>01492 <span class="preprocessor">          const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \</span>
<a name="l01493"></a>01493 <span class="preprocessor">                                                                                \</span>
<a name="l01494"></a>01494 <span class="preprocessor">          int boundary_index=-1;                                                        \</span>
<a name="l01495"></a>01495 <span class="preprocessor">          if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \</span>
<a name="l01496"></a>01496 <span class="preprocessor">            boundary_index=num_cl;                                                  \</span>
<a name="l01497"></a>01497 <span class="preprocessor">                                                                                \</span>
<a name="l01498"></a>01498 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01499"></a>01499 <span class="preprocessor">            int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \</span>
<a name="l01500"></a>01500 <span class="preprocessor">            flux_evaluateur.secmem_face(boundary_index,face,local_face, cl, ndeb, flux); \</span>
<a name="l01501"></a>01501 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01502"></a>01502 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01503"></a>01503 <span class="preprocessor">                {                                                        \</span>
<a name="l01504"></a>01504 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01505"></a>01505 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01506"></a>01506 <span class="preprocessor">                }                                                        \</span>
<a name="l01507"></a>01507 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01508"></a>01508 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01509"></a>01509 <span class="preprocessor">                {                                                        \</span>
<a name="l01510"></a>01510 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01511"></a>01511 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01512"></a>01512 <span class="preprocessor">                }                                                        \</span>
<a name="l01513"></a>01513 <span class="preprocessor">          }                                                                \</span>
<a name="l01514"></a><a class="code" href="MItPolyMACEl_8h.html#a1543a2629c62da26cf85e735a4f635a2">01514</a> <span class="preprocessor">        }                                                                \</span>
<a name="l01515"></a>01515 <span class="preprocessor">        break;                                                                \</span>
<a name="l01516"></a>01516 <span class="preprocessor">      case echange_global_impose :                                        \</span>
<a name="l01517"></a>01517 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l01518"></a>01518 <span class="preprocessor">          const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \</span>
<a name="l01519"></a>01519 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01520"></a>01520 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01521"></a>01521 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01522"></a>01522 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01523"></a>01523 <span class="preprocessor">                {                                                        \</span>
<a name="l01524"></a>01524 <span class="preprocessor">                  resu(elem1,k) +=flux(k);                                \</span>
<a name="l01525"></a>01525 <span class="preprocessor">                  flux_bords(face,k)+=flux(k);                                \</span>
<a name="l01526"></a>01526 <span class="preprocessor">                }                                                        \</span>
<a name="l01527"></a>01527 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01528"></a>01528 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01529"></a>01529 <span class="preprocessor">                {                                                        \</span>
<a name="l01530"></a>01530 <span class="preprocessor">                  resu(elem2,k) -=flux(k);                                \</span>
<a name="l01531"></a>01531 <span class="preprocessor">                  flux_bords(face,k)-=flux(k);                                \</span>
<a name="l01532"></a>01532 <span class="preprocessor">                }                                                        \</span>
<a name="l01533"></a>01533 <span class="preprocessor">          }                                                                \</span>
<a name="l01534"></a>01534 <span class="preprocessor">        }                                                                \</span>
<a name="l01535"></a>01535 <span class="preprocessor">        break;                                                                \</span>
<a name="l01536"></a>01536 <span class="preprocessor">      case periodique :                                                        \</span>
<a name="l01537"></a>01537 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_periodique()){                \</span>
<a name="l01538"></a>01538 <span class="preprocessor">          const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \</span>
<a name="l01539"></a>01539 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01540"></a>01540 <span class="preprocessor">            flux_evaluateur.secmem_face(face, cl, ndeb, flux);                \</span>
<a name="l01541"></a>01541 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01542"></a>01542 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01543"></a>01543 <span class="preprocessor">                {                                                        \</span>
<a name="l01544"></a>01544 <span class="preprocessor">                  resu(elem1,k) +=0.5*flux(k);                                \</span>
<a name="l01545"></a>01545 <span class="preprocessor">                  flux_bords(face,k)+=0.5*flux(k);                        \</span>
<a name="l01546"></a>01546 <span class="preprocessor">                }                                                        \</span>
<a name="l01547"></a>01547 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01548"></a>01548 <span class="preprocessor">              for (k=0; k&lt;ncomp; k++)                                        \</span>
<a name="l01549"></a><a class="code" href="MItPolyMACEl_8h.html#af511b766734cf8168b7a9380ea72b568">01549</a> <span class="preprocessor">                {                                                        \</span>
<a name="l01550"></a>01550 <span class="preprocessor">                  resu(elem2,k) -=0.5*flux(k);                                \</span>
<a name="l01551"></a>01551 <span class="preprocessor">                  flux_bords(face,k)-=0.5*flux(k);                        \</span>
<a name="l01552"></a>01552 <span class="preprocessor">                }                                                        \</span>
<a name="l01553"></a>01553 <span class="preprocessor">          }                                                                \</span>
<a name="l01554"></a>01554 <span class="preprocessor">        }                                                                \</span>
<a name="l01555"></a>01555 <span class="preprocessor">        break;                                                                \</span>
<a name="l01556"></a>01556 <span class="preprocessor">        </span><span class="comment">/*                                                                \</span>
<a name="l01557"></a>01557 <span class="comment">                                                                          case nouvelle_Cl_PolyMAC : \</span>
<a name="l01558"></a>01558 <span class="comment">                                                                          if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l01559"></a>01559 <span class="comment">                                                                          const Nouvelle_Cl_PolyMAC&amp; cl =(const Nouvelle_Cl_PolyMAC&amp;) (la_cl.valeur()); \</span>
<a name="l01560"></a>01560 <span class="comment">                                                                          for (face=ndeb; face&lt;nfin; face++) { \</span>
<a name="l01561"></a>01561 <span class="comment">                                                                          flux_evaluateur.secmem_face(face, cl, ndeb, flux); \</span>
<a name="l01562"></a>01562 <span class="comment">                                                                          if ( (elem1=elem(face,0)) &gt; -1) \</span>
<a name="l01563"></a>01563 <span class="comment">                                                                          for (k=0; k&lt;ncomp; k++) \</span>
<a name="l01564"></a>01564 <span class="comment">                                                                          resu(elem1,k) +=flux(k); \</span>
<a name="l01565"></a>01565 <span class="comment">                                                                          if ( (elem2=elem(face,1)) &gt; -1) \</span>
<a name="l01566"></a>01566 <span class="comment">                                                                          for (k=0; k&lt;ncomp; k++) \</span>
<a name="l01567"></a>01567 <span class="comment">                                                                          resu(elem2,k) -=flux(k); \</span>
<a name="l01568"></a>01568 <span class="comment">                                                                          } \</span>
<a name="l01569"></a>01569 <span class="comment">                                                                          } \</span>
<a name="l01570"></a>01570 <span class="comment">                                                                          break; \</span>
<a name="l01571"></a>01571 <span class="comment">        */</span>                                                                \
<a name="l01572"></a>01572       default :                                                                \
<a name="l01573"></a>01573         Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \
<a name="l01574"></a>01574         exit();                                                                \
<a name="l01575"></a>01575         break;                                                                \
<a name="l01576"></a>01576       }                                                                        \
<a name="l01577"></a>01577     }                                                                        \
<a name="l01578"></a>01578   }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580 <span class="preprocessor">#define implemente6_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l01581"></a>01581 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::contribuer_au_second_membre_interne(DoubleTab&amp; resu) const \</span>
<a name="l01582"></a>01582 <span class="preprocessor">  {                                                                        \</span>
<a name="l01583"></a>01583 <span class="preprocessor">    const Zone_PolyMAC&amp; zone_PolyMAC = la_zone.valeur();                        \</span>
<a name="l01584"></a>01584 <span class="preprocessor">    double flux;                                                        \</span>
<a name="l01585"></a>01585 <span class="preprocessor">    int face;                                                                \</span>
<a name="l01586"></a>01586 <span class="preprocessor">    int ndeb=zone_PolyMAC.premiere_face_int();                                \</span>
<a name="l01587"></a>01587 <span class="preprocessor">    int nfin=zone_PolyMAC.nb_faces();                                        \</span>
<a name="l01588"></a>01588 <span class="preprocessor">    for (face=ndeb; face&lt;nfin; face++)                                        \</span>
<a name="l01589"></a>01589 <span class="preprocessor">      {                                                                        \</span>
<a name="l01590"></a>01590 <span class="preprocessor">        flux=flux_evaluateur.secmem_faces_interne(face);                \</span>
<a name="l01591"></a>01591 <span class="preprocessor">        resu[elem(face,0)]+=flux;                                        \</span>
<a name="l01592"></a>01592 <span class="preprocessor">        resu[elem(face,1)]-=flux;                                        \</span>
<a name="l01593"></a>01593 <span class="preprocessor">      }                                                                        \</span>
<a name="l01594"></a>01594 <span class="preprocessor">  }                                                                        \</span>
<a name="l01595"></a>01595 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::contribuer_au_second_membre_interne( DoubleTab&amp; resu,int ncomp) const \</span>
<a name="l01596"></a>01596 <span class="preprocessor">  {                                                                        \</span>
<a name="l01597"></a>01597 <span class="preprocessor">    const Zone_PolyMAC&amp; zone_PolyMAC = la_zone.valeur();                        \</span>
<a name="l01598"></a>01598 <span class="preprocessor">    DoubleVect flux(ncomp);                                                \</span>
<a name="l01599"></a>01599 <span class="preprocessor">    int face,k;                                                                \</span>
<a name="l01600"></a>01600 <span class="preprocessor">    int elem0,elem1;                                                        \</span>
<a name="l01601"></a>01601 <span class="preprocessor">    int ndeb=zone_PolyMAC.premiere_face_int();                                \</span>
<a name="l01602"></a>01602 <span class="preprocessor">    int nfin=zone_PolyMAC.nb_faces();                                        \</span>
<a name="l01603"></a>01603 <span class="preprocessor">    for (face=ndeb; face&lt;nfin; face++)                                        \</span>
<a name="l01604"></a>01604 <span class="preprocessor">      {                                                                        \</span>
<a name="l01605"></a>01605 <span class="preprocessor">        flux_evaluateur.secmem_faces_interne(face, flux);                \</span>
<a name="l01606"></a>01606 <span class="preprocessor">        elem0 = elem(face,0);                                                \</span>
<a name="l01607"></a>01607 <span class="preprocessor">        elem1 = elem(face,1);                                                \</span>
<a name="l01608"></a>01608 <span class="preprocessor">        for (k=0; k&lt;ncomp; k++) {                                        \</span>
<a name="l01609"></a>01609 <span class="preprocessor">          resu(elem0,k)+=flux(k);                                        \</span>
<a name="l01610"></a>01610 <span class="preprocessor">          resu(elem1,k)-=flux(k);                                        \</span>
<a name="l01611"></a>01611 <span class="preprocessor">        }                                                                \</span>
<a name="l01612"></a>01612 <span class="preprocessor">      }                                                                        \</span>
<a name="l01613"></a>01613 <span class="preprocessor">  }</span>
<a name="l01614"></a>01614 <span class="preprocessor"></span>
<a name="l01615"></a>01615 <span class="preprocessor">#define implemente7_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l01616"></a>01616 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::ajouter_contribution(const DoubleTab&amp; inco, Matrice_Morse&amp; matrice) const \</span>
<a name="l01617"></a>01617 <span class="preprocessor">  {                                                                        \</span>
<a name="l01618"></a>01618 <span class="preprocessor">    ((_TYPE_&amp;) flux_evaluateur).mettre_a_jour();                        \</span>
<a name="l01619"></a>01619 <span class="preprocessor">    assert(inco.nb_dim() &lt; 3);                                                \</span>
<a name="l01620"></a>01620 <span class="preprocessor">    assert(la_zcl.non_nul());                                                \</span>
<a name="l01621"></a>01621 <span class="preprocessor">    assert(la_zone.non_nul());                                                \</span>
<a name="l01622"></a>01622 <span class="preprocessor">    int ncomp=1;                                                        \</span>
<a name="l01623"></a>01623 <span class="preprocessor">    if (inco.nb_dim() == 2)                                                \</span>
<a name="l01624"></a>01624 <span class="preprocessor">      ncomp=inco.dimension(1);                                                \</span>
<a name="l01625"></a>01625 <span class="preprocessor">    DoubleTab&amp; flux_bords=op_base-&gt;flux_bords();                        \</span>
<a name="l01626"></a>01626 <span class="preprocessor">    flux_bords.resize(la_zone-&gt;nb_faces_bord(),ncomp);                        \</span>
<a name="l01627"></a>01627 <span class="preprocessor">    flux_bords=0;                                                        \</span>
<a name="l01628"></a>01628 <span class="preprocessor">    if( ncomp == 1) </span><span class="comment">/* cas scalaire */</span>                                        \
<a name="l01629"></a>01629       {                                                                        \
<a name="l01630"></a>01630         ajouter_contribution_bords(inco, matrice) ;                        \
<a name="l01631"></a>01631         ajouter_contribution_interne(inco, matrice) ;                        \
<a name="l01632"></a>01632       }                                                                        \
<a name="l01633"></a>01633     else <span class="comment">/* cas vectoriel */</span>                                                \
<a name="l01634"></a>01634       {                                                                        \
<a name="l01635"></a>01635         ajouter_contribution_bords(inco, matrice, ncomp) ;                \
<a name="l01636"></a>01636         ajouter_contribution_interne(inco, matrice, ncomp) ;                \
<a name="l01637"></a>01637       }                                                                        \
<a name="l01638"></a>01638   }                                                                        \
<a name="l01639"></a>01639   void It_PolyMAC_Elem(_TYPE_)::ajouter_contribution_bords(const DoubleTab&amp; inco, Matrice_Morse&amp; matrice ) const \
<a name="l01640"></a>01640   {                                                                        \
<a name="l01641"></a>01641     int elem1, elem2;                                                        \
<a name="l01642"></a>01642     double aii=0, ajj=0;                                                \
<a name="l01643"></a>01643     int ndeb, nfin;                                                        \
<a name="l01644"></a>01644     int face;                                                                \
<a name="l01645"></a>01645     int num_cl=0;                                                        \
<a name="l01646"></a>01646     int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \
<a name="l01647"></a>01647     for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \
<a name="l01648"></a>01648       <span class="comment">/* pour chaque Condition Limite on regarde son type */</span>                \
<a name="l01649"></a>01649       const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \
<a name="l01650"></a>01650       const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \
<a name="l01651"></a>01651       ndeb = frontiere_dis.num_premiere_face();                                \
<a name="l01652"></a>01652       nfin = ndeb + frontiere_dis.nb_faces();                                \
<a name="l01653"></a>01653       switch(type_cl(la_cl)){                                                \
<a name="l01654"></a>01654       case symetrie :                                                        \
<a name="l01655"></a>01655         if (flux_evaluateur.calculer_flux_faces_symetrie()){                \
<a name="l01656"></a>01656           const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \
<a name="l01657"></a>01657           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01658"></a>01658             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01659"></a>01659             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01660"></a>01660               {                                                                \
<a name="l01661"></a>01661                 matrice(elem1,elem1)+=aii;                                \
<a name="l01662"></a>01662               }                                                                \
<a name="l01663"></a>01663             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01664"></a>01664               {                                                                \
<a name="l01665"></a>01665                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01666"></a>01666               }                                                                \
<a name="l01667"></a>01667           }                                                                \
<a name="l01668"></a>01668         }                                                                \
<a name="l01669"></a>01669         break;                                                                \
<a name="l01670"></a>01670       case sortie_libre :                                                \
<a name="l01671"></a>01671         if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \
<a name="l01672"></a>01672           const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \
<a name="l01673"></a>01673           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01674"></a>01674             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01675"></a>01675             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01676"></a>01676               {                                                                \
<a name="l01677"></a>01677                 matrice(elem1,elem1)+=aii;                                \
<a name="l01678"></a>01678               }                                                                \
<a name="l01679"></a>01679             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01680"></a>01680               {                                                                \
<a name="l01681"></a>01681                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01682"></a>01682               }                                                                \
<a name="l01683"></a>01683           }                                                                \
<a name="l01684"></a>01684         }                                                                \
<a name="l01685"></a>01685         break;                                                                \
<a name="l01686"></a>01686       case entree_fluide :                                                \
<a name="l01687"></a>01687         if (flux_evaluateur.calculer_flux_faces_entree_fluide()){        \
<a name="l01688"></a>01688           const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \
<a name="l01689"></a>01689           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01690"></a>01690             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01691"></a>01691             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01692"></a>01692               {                                                                \
<a name="l01693"></a>01693                 matrice(elem1,elem1)+=aii;                                \
<a name="l01694"></a>01694               }                                                                \
<a name="l01695"></a>01695             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01696"></a>01696               {                                                                \
<a name="l01697"></a>01697                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01698"></a>01698               }                                                                \
<a name="l01699"></a>01699           }                                                                \
<a name="l01700"></a>01700         }                                                                \
<a name="l01701"></a>01701         break;                                                                \
<a name="l01702"></a>01702       case paroi_fixe :                                                        \
<a name="l01703"></a>01703         if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \
<a name="l01704"></a>01704           const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \
<a name="l01705"></a>01705           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01706"></a>01706             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01707"></a>01707             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01708"></a>01708               {                                                                \
<a name="l01709"></a>01709                 matrice(elem1,elem1)+=aii;                                \
<a name="l01710"></a>01710               }                                                                \
<a name="l01711"></a>01711             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01712"></a>01712               {                                                                \
<a name="l01713"></a>01713                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01714"></a>01714               }                                                                \
<a name="l01715"></a>01715           }                                                                \
<a name="l01716"></a>01716         }                                                                \
<a name="l01717"></a>01717         break;                                                                \
<a name="l01718"></a>01718       case paroi_defilante :                                                \
<a name="l01719"></a>01719         if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \
<a name="l01720"></a>01720           const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \
<a name="l01721"></a>01721           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01722"></a>01722             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01723"></a>01723             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01724"></a>01724               {                                                                \
<a name="l01725"></a>01725                 matrice(elem1,elem1)+=aii;                                \
<a name="l01726"></a>01726               }                                                                \
<a name="l01727"></a>01727             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01728"></a>01728               {                                                                \
<a name="l01729"></a>01729                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01730"></a>01730               }                                                                \
<a name="l01731"></a>01731           }                                                                \
<a name="l01732"></a>01732         }                                                                \
<a name="l01733"></a>01733         break;                                                                \
<a name="l01734"></a>01734       case paroi_adiabatique :                                                \
<a name="l01735"></a>01735         if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \
<a name="l01736"></a>01736           const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \
<a name="l01737"></a>01737           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01738"></a>01738             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01739"></a>01739             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01740"></a>01740               {                                                                \
<a name="l01741"></a>01741                 matrice(elem1,elem1)+=aii;                                \
<a name="l01742"></a>01742               }                                                                \
<a name="l01743"></a>01743             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01744"></a>01744               {                                                                \
<a name="l01745"></a>01745                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01746"></a>01746               }                                                                \
<a name="l01747"></a>01747           }                                                                \
<a name="l01748"></a>01748         }                                                                \
<a name="l01749"></a>01749         break;                                                                \
<a name="l01750"></a>01750       case paroi :                                                        \
<a name="l01751"></a>01751         if (flux_evaluateur.calculer_flux_faces_paroi()){                \
<a name="l01752"></a>01752           const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \
<a name="l01753"></a>01753           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01754"></a>01754             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01755"></a>01755             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01756"></a>01756               {                                                                \
<a name="l01757"></a>01757                 matrice(elem1,elem1)+=aii;                                \
<a name="l01758"></a>01758               }                                                                \
<a name="l01759"></a>01759             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01760"></a>01760               {                                                                \
<a name="l01761"></a>01761                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01762"></a>01762               }                                                                \
<a name="l01763"></a>01763           }                                                                \
<a name="l01764"></a>01764         }                                                                \
<a name="l01765"></a>01765         break;                                                                \
<a name="l01766"></a>01766       case echange_externe_impose :                                        \
<a name="l01767"></a>01767         if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \
<a name="l01768"></a>01768           const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \
<a name="l01769"></a>01769                                                                                 \
<a name="l01770"></a>01770           int boundary_index=-1;                                                        \
<a name="l01771"></a>01771           if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \
<a name="l01772"></a>01772             boundary_index=num_cl;                                                  \
<a name="l01773"></a>01773                                                                                 \
<a name="l01774"></a>01774           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01775"></a>01775             int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \
<a name="l01776"></a>01776             flux_evaluateur.coeffs_face(boundary_index,face,local_face,ndeb, cl, aii, ajj); \
<a name="l01777"></a>01777             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01778"></a>01778               {                                                                \
<a name="l01779"></a>01779                 matrice(elem1,elem1)+=aii;                                \
<a name="l01780"></a><a class="code" href="MItPolyMACEl_8h.html#ab42191dff93a7505eca63808d3739982">01780</a>               }                                                                \
<a name="l01781"></a>01781             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01782"></a>01782               {                                                                \
<a name="l01783"></a>01783                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01784"></a>01784               }                                                                \
<a name="l01785"></a>01785           }                                                                \
<a name="l01786"></a>01786         }                                                                \
<a name="l01787"></a>01787         break;                                                                \
<a name="l01788"></a>01788       case echange_global_impose :                                        \
<a name="l01789"></a>01789         if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \
<a name="l01790"></a>01790           const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \
<a name="l01791"></a>01791           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01792"></a>01792             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01793"></a>01793             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01794"></a>01794               {                                                                \
<a name="l01795"></a>01795                 matrice(elem1,elem1)+=aii;                                \
<a name="l01796"></a>01796               }                                                                \
<a name="l01797"></a>01797             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01798"></a>01798               {                                                                \
<a name="l01799"></a>01799                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01800"></a>01800               }                                                                \
<a name="l01801"></a>01801           }                                                                \
<a name="l01802"></a>01802         }                                                                \
<a name="l01803"></a>01803         break;                                                                \
<a name="l01804"></a>01804       case nscbc :                                                        \
<a name="l01805"></a>01805         if (flux_evaluateur.calculer_flux_faces_NSCBC()){                \
<a name="l01806"></a>01806           const NSCBC&amp; cl =(const NSCBC&amp;) (la_cl.valeur());                \
<a name="l01807"></a>01807           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01808"></a>01808             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01809"></a>01809             if ( (elem1=elem(face,0)) &gt; -1)                                \
<a name="l01810"></a>01810               {                                                                \
<a name="l01811"></a>01811                 matrice(elem1,elem1)+=aii;                                \
<a name="l01812"></a>01812               }                                                                \
<a name="l01813"></a>01813             if ( (elem2=elem(face,1)) &gt; -1)                                \
<a name="l01814"></a>01814               {                                                                \
<a name="l01815"></a>01815                 matrice(elem2,elem2)+=ajj;                                \
<a name="l01816"></a>01816               }                                                                \
<a name="l01817"></a>01817           }                                                                \
<a name="l01818"></a>01818         }                                                                \
<a name="l01819"></a>01819         break;                                                                \
<a name="l01820"></a>01820       case periodique :                                                        \
<a name="l01821"></a>01821         if (flux_evaluateur.calculer_flux_faces_periodique()){                \
<a name="l01822"></a>01822           const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \
<a name="l01823"></a>01823           for (face=ndeb; face&lt;nfin; face++) {                                \
<a name="l01824"></a>01824             <span class="comment">/* GF Qui a mis l&#39;appel au coeffs faces_internes ??? . Cest faux ...*/</span> \
<a name="l01825"></a>01825             <span class="comment">/* flux_evaluateur.coeffs_faces_interne(face, aii, ajj); */</span>        \
<a name="l01826"></a>01826             flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \
<a name="l01827"></a>01827             elem1 = elem(face,0);                                        \
<a name="l01828"></a>01828             elem2 = elem(face,1);                                        \
<a name="l01829"></a>01829             matrice(elem1,elem1)+=0.5*aii;                                \
<a name="l01830"></a>01830             matrice(elem1,elem2)-=0.5*ajj;                                \
<a name="l01831"></a>01831             matrice(elem2,elem2)+=0.5*ajj;                                \
<a name="l01832"></a>01832             matrice(elem2,elem1)-=0.5*aii;                                \
<a name="l01833"></a>01833           }                                                                \
<a name="l01834"></a>01834         }                                                                \
<a name="l01835"></a>01835         break;                                                                \
<a name="l01836"></a>01836       case scalaire_impose_paroi :                                            \
<a name="l01837"></a>01837         break;                                                                \
<a name="l01838"></a>01838       default :                                                                \
<a name="l01839"></a>01839         Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \
<a name="l01840"></a>01840         exit();                                                                \
<a name="l01841"></a>01841         break;                                                                \
<a name="l01842"></a>01842       }                                                                        \
<a name="l01843"></a>01843     }                                                                        \
<a name="l01844"></a>01844   }
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 <span class="preprocessor">#define implemente8_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l01847"></a>01847 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::ajouter_contribution_bords(const DoubleTab&amp; inco, Matrice_Morse&amp; matrice ,int ncomp) const \</span>
<a name="l01848"></a>01848 <span class="preprocessor">  {                                                                        \</span>
<a name="l01849"></a>01849 <span class="preprocessor">    int elem1, elem2;                                                        \</span>
<a name="l01850"></a>01850 <span class="preprocessor">    DoubleVect aii(ncomp), ajj(ncomp);                                        \</span>
<a name="l01851"></a>01851 <span class="preprocessor">    int ndeb, nfin;                                                        \</span>
<a name="l01852"></a>01852 <span class="preprocessor">    int face,i;                                                                \</span>
<a name="l01853"></a>01853 <span class="preprocessor">    int num_cl=0;                                                        \</span>
<a name="l01854"></a>01854 <span class="preprocessor">    int nb_front_Cl=la_zone-&gt;nb_front_Cl();                                \</span>
<a name="l01855"></a>01855 <span class="preprocessor">    for (; num_cl&lt;nb_front_Cl; num_cl++) {                                \</span>
<a name="l01856"></a>01856 <span class="preprocessor">      const Cond_lim&amp; la_cl = la_zcl-&gt;les_conditions_limites(num_cl);        \</span>
<a name="l01857"></a>01857 <span class="preprocessor">      const Front_VF&amp; frontiere_dis = ref_cast(Front_VF,la_cl.frontiere_dis());        \</span>
<a name="l01858"></a>01858 <span class="preprocessor">      ndeb = frontiere_dis.num_premiere_face();                                \</span>
<a name="l01859"></a>01859 <span class="preprocessor">      nfin = ndeb + frontiere_dis.nb_faces();                                \</span>
<a name="l01860"></a>01860 <span class="preprocessor">      switch(type_cl(la_cl)){                                                \</span>
<a name="l01861"></a>01861 <span class="preprocessor">      case symetrie :                                                        \</span>
<a name="l01862"></a>01862 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_symetrie()){                \</span>
<a name="l01863"></a>01863 <span class="preprocessor">          const Symetrie&amp; cl =(const Symetrie&amp;) (la_cl.valeur());        \</span>
<a name="l01864"></a>01864 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01865"></a>01865 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l01866"></a>01866 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l01867"></a>01867 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01868"></a>01868 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01869"></a>01869 <span class="preprocessor">              {                                                                \</span>
<a name="l01870"></a>01870 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01871"></a>01871 <span class="preprocessor">                  {                                                        \</span>
<a name="l01872"></a>01872 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l01873"></a>01873 <span class="preprocessor">                  }                                                        \</span>
<a name="l01874"></a>01874 <span class="preprocessor">              }                                                                \</span>
<a name="l01875"></a>01875 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01876"></a>01876 <span class="preprocessor">              {                                                                \</span>
<a name="l01877"></a>01877 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01878"></a>01878 <span class="preprocessor">                  {                                                        \</span>
<a name="l01879"></a>01879 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l01880"></a>01880 <span class="preprocessor">                  }                                                        \</span>
<a name="l01881"></a>01881 <span class="preprocessor">              }                                                                \</span>
<a name="l01882"></a>01882 <span class="preprocessor">          }                                                                \</span>
<a name="l01883"></a>01883 <span class="preprocessor">        }                                                                \</span>
<a name="l01884"></a>01884 <span class="preprocessor">        break;                                                                \</span>
<a name="l01885"></a>01885 <span class="preprocessor">      case sortie_libre :                                                \</span>
<a name="l01886"></a>01886 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_sortie_libre()){        \</span>
<a name="l01887"></a>01887 <span class="preprocessor">          const Neumann_sortie_libre&amp; cl =(const Neumann_sortie_libre&amp;) (la_cl.valeur()); \</span>
<a name="l01888"></a>01888 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01889"></a>01889 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01890"></a>01890 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l01891"></a>01891 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l01892"></a>01892 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01893"></a>01893 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01894"></a>01894 <span class="preprocessor">              {                                                                \</span>
<a name="l01895"></a>01895 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01896"></a>01896 <span class="preprocessor">                  {                                                        \</span>
<a name="l01897"></a>01897 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l01898"></a>01898 <span class="preprocessor">                  }                                                        \</span>
<a name="l01899"></a>01899 <span class="preprocessor">              }                                                                \</span>
<a name="l01900"></a>01900 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01901"></a>01901 <span class="preprocessor">              {                                                                \</span>
<a name="l01902"></a>01902 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01903"></a>01903 <span class="preprocessor">                  {                                                        \</span>
<a name="l01904"></a>01904 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l01905"></a>01905 <span class="preprocessor">                  }                                                        \</span>
<a name="l01906"></a>01906 <span class="preprocessor">              }                                                                \</span>
<a name="l01907"></a>01907 <span class="preprocessor">          }                                                                \</span>
<a name="l01908"></a>01908 <span class="preprocessor">        }                                                                \</span>
<a name="l01909"></a>01909 <span class="preprocessor">        break;                                                                \</span>
<a name="l01910"></a>01910 <span class="preprocessor">      case entree_fluide :                                                \</span>
<a name="l01911"></a>01911 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_entree_fluide()){        \</span>
<a name="l01912"></a>01912 <span class="preprocessor">          const Dirichlet_entree_fluide&amp; cl =(const Dirichlet_entree_fluide&amp;) (la_cl.valeur());        \</span>
<a name="l01913"></a>01913 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01914"></a>01914 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01915"></a>01915 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l01916"></a>01916 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l01917"></a>01917 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01918"></a>01918 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01919"></a>01919 <span class="preprocessor">              {                                                                \</span>
<a name="l01920"></a>01920 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01921"></a>01921 <span class="preprocessor">                  {                                                        \</span>
<a name="l01922"></a>01922 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l01923"></a>01923 <span class="preprocessor">                  }                                                        \</span>
<a name="l01924"></a>01924 <span class="preprocessor">              }                                                                \</span>
<a name="l01925"></a>01925 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01926"></a>01926 <span class="preprocessor">              {                                                                \</span>
<a name="l01927"></a>01927 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01928"></a>01928 <span class="preprocessor">                  {                                                        \</span>
<a name="l01929"></a>01929 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l01930"></a>01930 <span class="preprocessor">                  }                                                        \</span>
<a name="l01931"></a>01931 <span class="preprocessor">              }                                                                \</span>
<a name="l01932"></a>01932 <span class="preprocessor">          }                                                                \</span>
<a name="l01933"></a>01933 <span class="preprocessor">        }                                                                \</span>
<a name="l01934"></a>01934 <span class="preprocessor">        break;                                                                \</span>
<a name="l01935"></a>01935 <span class="preprocessor">      case paroi_fixe :                                                        \</span>
<a name="l01936"></a>01936 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi_fixe()){                \</span>
<a name="l01937"></a>01937 <span class="preprocessor">          const Dirichlet_paroi_fixe&amp; cl =(const Dirichlet_paroi_fixe&amp;) (la_cl.valeur()); \</span>
<a name="l01938"></a>01938 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01939"></a>01939 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01940"></a>01940 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l01941"></a>01941 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l01942"></a>01942 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01943"></a>01943 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01944"></a>01944 <span class="preprocessor">              {                                                                \</span>
<a name="l01945"></a>01945 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01946"></a>01946 <span class="preprocessor">                  {                                                        \</span>
<a name="l01947"></a>01947 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l01948"></a>01948 <span class="preprocessor">                  }                                                        \</span>
<a name="l01949"></a>01949 <span class="preprocessor">              }                                                                \</span>
<a name="l01950"></a>01950 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01951"></a>01951 <span class="preprocessor">              {                                                                \</span>
<a name="l01952"></a>01952 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01953"></a>01953 <span class="preprocessor">                  {                                                        \</span>
<a name="l01954"></a>01954 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l01955"></a>01955 <span class="preprocessor">                  }                                                        \</span>
<a name="l01956"></a>01956 <span class="preprocessor">              }                                                                \</span>
<a name="l01957"></a>01957 <span class="preprocessor">          }                                                                \</span>
<a name="l01958"></a>01958 <span class="preprocessor">        }                                                                \</span>
<a name="l01959"></a>01959 <span class="preprocessor">        break;                                                                \</span>
<a name="l01960"></a>01960 <span class="preprocessor">      case paroi_defilante :                                                \</span>
<a name="l01961"></a>01961 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi_defilante()){        \</span>
<a name="l01962"></a>01962 <span class="preprocessor">          const Dirichlet_paroi_defilante&amp; cl =(const Dirichlet_paroi_defilante&amp;) (la_cl.valeur()); \</span>
<a name="l01963"></a>01963 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01964"></a>01964 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01965"></a>01965 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l01966"></a>01966 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l01967"></a>01967 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01968"></a>01968 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01969"></a>01969 <span class="preprocessor">              {                                                                \</span>
<a name="l01970"></a>01970 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01971"></a>01971 <span class="preprocessor">                  {                                                        \</span>
<a name="l01972"></a>01972 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l01973"></a>01973 <span class="preprocessor">                  }                                                        \</span>
<a name="l01974"></a>01974 <span class="preprocessor">              }                                                                \</span>
<a name="l01975"></a>01975 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l01976"></a>01976 <span class="preprocessor">              {                                                                \</span>
<a name="l01977"></a>01977 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01978"></a>01978 <span class="preprocessor">                  {                                                        \</span>
<a name="l01979"></a>01979 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l01980"></a>01980 <span class="preprocessor">                  }                                                        \</span>
<a name="l01981"></a>01981 <span class="preprocessor">              }                                                                \</span>
<a name="l01982"></a>01982 <span class="preprocessor">          }                                                                \</span>
<a name="l01983"></a>01983 <span class="preprocessor">        }                                                                \</span>
<a name="l01984"></a>01984 <span class="preprocessor">        break;                                                                \</span>
<a name="l01985"></a>01985 <span class="preprocessor">      case paroi_adiabatique :                                                \</span>
<a name="l01986"></a>01986 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi_adiabatique()){        \</span>
<a name="l01987"></a>01987 <span class="preprocessor">          const Neumann_paroi_adiabatique&amp; cl =(const Neumann_paroi_adiabatique&amp;) (la_cl.valeur()); \</span>
<a name="l01988"></a>01988 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l01989"></a>01989 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01990"></a>01990 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l01991"></a>01991 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l01992"></a>01992 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l01993"></a>01993 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l01994"></a>01994 <span class="preprocessor">              {                                                                \</span>
<a name="l01995"></a>01995 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l01996"></a>01996 <span class="preprocessor">                  {                                                        \</span>
<a name="l01997"></a>01997 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l01998"></a>01998 <span class="preprocessor">                  }                                                        \</span>
<a name="l01999"></a>01999 <span class="preprocessor">              }                                                                \</span>
<a name="l02000"></a>02000 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l02001"></a>02001 <span class="preprocessor">              {                                                                \</span>
<a name="l02002"></a>02002 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02003"></a>02003 <span class="preprocessor">                  {                                                        \</span>
<a name="l02004"></a>02004 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l02005"></a>02005 <span class="preprocessor">                  }                                                        \</span>
<a name="l02006"></a>02006 <span class="preprocessor">              }                                                                \</span>
<a name="l02007"></a>02007 <span class="preprocessor">          }                                                                \</span>
<a name="l02008"></a>02008 <span class="preprocessor">        }                                                                \</span>
<a name="l02009"></a>02009 <span class="preprocessor">        break;                                                                \</span>
<a name="l02010"></a>02010 <span class="preprocessor">      case paroi :                                                        \</span>
<a name="l02011"></a>02011 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_paroi()){                \</span>
<a name="l02012"></a>02012 <span class="preprocessor">          const Neumann_paroi&amp; cl =(const Neumann_paroi&amp;) (la_cl.valeur()); \</span>
<a name="l02013"></a>02013 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l02014"></a>02014 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l02015"></a>02015 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l02016"></a>02016 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l02017"></a>02017 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l02018"></a>02018 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l02019"></a>02019 <span class="preprocessor">              {                                                                \</span>
<a name="l02020"></a>02020 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02021"></a>02021 <span class="preprocessor">                  {                                                        \</span>
<a name="l02022"></a>02022 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l02023"></a>02023 <span class="preprocessor">                  }                                                        \</span>
<a name="l02024"></a>02024 <span class="preprocessor">              }                                                                \</span>
<a name="l02025"></a>02025 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l02026"></a>02026 <span class="preprocessor">              {                                                                \</span>
<a name="l02027"></a>02027 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02028"></a>02028 <span class="preprocessor">                  {                                                        \</span>
<a name="l02029"></a>02029 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l02030"></a>02030 <span class="preprocessor">                  }                                                        \</span>
<a name="l02031"></a>02031 <span class="preprocessor">              }                                                                \</span>
<a name="l02032"></a>02032 <span class="preprocessor">          }                                                                \</span>
<a name="l02033"></a>02033 <span class="preprocessor">        }                                                                \</span>
<a name="l02034"></a>02034 <span class="preprocessor">        break;                                                                \</span>
<a name="l02035"></a>02035 <span class="preprocessor">      case echange_externe_impose :                                        \</span>
<a name="l02036"></a>02036 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_echange_externe_impose()){ \</span>
<a name="l02037"></a>02037 <span class="preprocessor">          const Echange_externe_impose&amp; cl =(const Echange_externe_impose&amp;) (la_cl.valeur()); \</span>
<a name="l02038"></a>02038 <span class="preprocessor">                                                                                \</span>
<a name="l02039"></a>02039 <span class="preprocessor">          int boundary_index=-1;                                                        \</span>
<a name="l02040"></a>02040 <span class="preprocessor">          if (la_zone.valeur().front_VF(num_cl).le_nom() == frontiere_dis.le_nom()) \</span>
<a name="l02041"></a>02041 <span class="preprocessor">            boundary_index=num_cl;                                                  \</span>
<a name="l02042"></a>02042 <span class="preprocessor">                                                                                \</span>
<a name="l02043"></a>02043 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l02044"></a>02044 <span class="preprocessor">            int local_face=la_zone.valeur().front_VF(boundary_index).num_local_face(face); \</span>
<a name="l02045"></a>02045 <span class="preprocessor">            flux_evaluateur.coeffs_face(boundary_index,face,local_face,ndeb, cl, aii, ajj); \</span>
<a name="l02046"></a>02046 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l02047"></a>02047 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l02048"></a>02048 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l02049"></a>02049 <span class="preprocessor">              {                                                                \</span>
<a name="l02050"></a>02050 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02051"></a>02051 <span class="preprocessor">                  {                                                        \</span>
<a name="l02052"></a>02052 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l02053"></a>02053 <span class="preprocessor">                  }                                                        \</span>
<a name="l02054"></a><a class="code" href="MItPolyMACEl_8h.html#a6f4514898dbef3ddbc1ce55d1e80e1e6">02054</a> <span class="preprocessor">              }                                                                \</span>
<a name="l02055"></a>02055 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l02056"></a>02056 <span class="preprocessor">              {                                                                \</span>
<a name="l02057"></a>02057 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02058"></a>02058 <span class="preprocessor">                  {                                                        \</span>
<a name="l02059"></a>02059 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=aii(i);        \</span>
<a name="l02060"></a>02060 <span class="preprocessor">                  }                                                        \</span>
<a name="l02061"></a>02061 <span class="preprocessor">              }                                                                \</span>
<a name="l02062"></a>02062 <span class="preprocessor">          }                                                                \</span>
<a name="l02063"></a>02063 <span class="preprocessor">        }                                                                \</span>
<a name="l02064"></a>02064 <span class="preprocessor">        break;                                                                \</span>
<a name="l02065"></a>02065 <span class="preprocessor">      case echange_global_impose :                                        \</span>
<a name="l02066"></a>02066 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_echange_global_impose()){ \</span>
<a name="l02067"></a>02067 <span class="preprocessor">          const Echange_global_impose&amp; cl =(const Echange_global_impose&amp;) (la_cl.valeur()); \</span>
<a name="l02068"></a>02068 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l02069"></a>02069 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l02070"></a>02070 <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l02071"></a>02071 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l02072"></a>02072 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l02073"></a>02073 <span class="preprocessor">            if ( (elem1=elem(face,0)) &gt; -1)                                \</span>
<a name="l02074"></a>02074 <span class="preprocessor">              {                                                                \</span>
<a name="l02075"></a>02075 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02076"></a>02076 <span class="preprocessor">                  {                                                        \</span>
<a name="l02077"></a>02077 <span class="preprocessor">                    matrice(elem1*ncomp+i,elem1*ncomp+i)+=aii(i);        \</span>
<a name="l02078"></a>02078 <span class="preprocessor">                  }                                                        \</span>
<a name="l02079"></a>02079 <span class="preprocessor">              }                                                                \</span>
<a name="l02080"></a>02080 <span class="preprocessor">            if ( (elem2=elem(face,1)) &gt; -1)                                \</span>
<a name="l02081"></a>02081 <span class="preprocessor">              {                                                                \</span>
<a name="l02082"></a>02082 <span class="preprocessor">                for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02083"></a>02083 <span class="preprocessor">                  {                                                        \</span>
<a name="l02084"></a>02084 <span class="preprocessor">                    matrice(elem2*ncomp+i,elem2*ncomp+i)+=ajj(i);        \</span>
<a name="l02085"></a>02085 <span class="preprocessor">                  }                                                        \</span>
<a name="l02086"></a>02086 <span class="preprocessor">              }                                                                \</span>
<a name="l02087"></a>02087 <span class="preprocessor">          }                                                                \</span>
<a name="l02088"></a>02088 <span class="preprocessor">        }                                                                \</span>
<a name="l02089"></a>02089 <span class="preprocessor">        break;                                                                \</span>
<a name="l02090"></a>02090 <span class="preprocessor">      case periodique :                                                        \</span>
<a name="l02091"></a>02091 <span class="preprocessor">        if (flux_evaluateur.calculer_flux_faces_periodique()){                \</span>
<a name="l02092"></a>02092 <span class="preprocessor">          const Periodique&amp; cl =(const Periodique&amp;) (la_cl.valeur());        \</span>
<a name="l02093"></a>02093 <span class="preprocessor">          for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l02094"></a>02094 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l02095"></a><a class="code" href="MItPolyMACEl_8h.html#ad49110b65c9622ddba4bf547a9692c3a">02095</a> <span class="preprocessor">            elem1 = elem(face,0);                                        \</span>
<a name="l02096"></a>02096 <span class="preprocessor">            elem2 = elem(face,1);                                        \</span>
<a name="l02097"></a>02097 <span class="preprocessor">            flux_evaluateur.coeffs_face(face,ndeb, cl, aii, ajj);        \</span>
<a name="l02098"></a>02098 <span class="preprocessor">            {                                                                \</span>
<a name="l02099"></a>02099 <span class="preprocessor">              for (i=0; i&lt;ncomp; i++)                                        \</span>
<a name="l02100"></a>02100 <span class="preprocessor">                {                                                        \</span>
<a name="l02101"></a>02101 <span class="preprocessor">                  int n1=elem1*ncomp+i;                                        \</span>
<a name="l02102"></a>02102 <span class="preprocessor">                  int n2=elem2*ncomp+i;                                        \</span>
<a name="l02103"></a>02103 <span class="preprocessor">                  matrice(n1,n1)+=0.5*aii(i);                                \</span>
<a name="l02104"></a>02104 <span class="preprocessor">                  matrice(n1,n2)-=0.5*ajj(i);                                \</span>
<a name="l02105"></a>02105 <span class="preprocessor">                  matrice(n2,n2)+=0.5*ajj(i);                                \</span>
<a name="l02106"></a>02106 <span class="preprocessor">                  matrice(n2,n1)-=0.5*aii(i);                                \</span>
<a name="l02107"></a>02107 <span class="preprocessor">                }                                                        \</span>
<a name="l02108"></a>02108 <span class="preprocessor">            }                                                                \</span>
<a name="l02109"></a>02109 <span class="preprocessor">          }                                                                \</span>
<a name="l02110"></a>02110 <span class="preprocessor">        }                                                                \</span>
<a name="l02111"></a>02111 <span class="preprocessor">        break;                                                                \</span>
<a name="l02112"></a>02112 <span class="preprocessor">      default :                                                                \</span>
<a name="l02113"></a>02113 <span class="preprocessor">        Cerr &lt;&lt; &quot;On ne reconnait pas la condition limite : &quot; &lt;&lt; la_cl.valeur();        \</span>
<a name="l02114"></a>02114 <span class="preprocessor">        exit();                                                                \</span>
<a name="l02115"></a>02115 <span class="preprocessor">        break;                                                                \</span>
<a name="l02116"></a>02116 <span class="preprocessor">      }                                                                        \</span>
<a name="l02117"></a>02117 <span class="preprocessor">    }                                                                        \</span>
<a name="l02118"></a>02118 <span class="preprocessor">  }</span>
<a name="l02119"></a>02119 <span class="preprocessor"></span>
<a name="l02120"></a>02120 <span class="preprocessor">#define implemente9_It_PolyMAC_Elem(_TYPE_)                                        \</span>
<a name="l02121"></a>02121 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::ajouter_contribution_interne(const DoubleTab&amp; inco, Matrice_Morse&amp; matrice ) const \</span>
<a name="l02122"></a>02122 <span class="preprocessor">  {                                                                        \</span>
<a name="l02123"></a>02123 <span class="preprocessor">    const Zone_PolyMAC&amp; zone_PolyMAC = la_zone.valeur();                        \</span>
<a name="l02124"></a>02124 <span class="preprocessor">    int face;                                                                \</span>
<a name="l02125"></a>02125 <span class="preprocessor">    double aii=0, ajj=0;                                                \</span>
<a name="l02126"></a>02126 <span class="preprocessor">    int elem1,elem2;                                                        \</span>
<a name="l02127"></a>02127 <span class="preprocessor">    int ndeb=zone_PolyMAC.premiere_face_int();                                \</span>
<a name="l02128"></a>02128 <span class="preprocessor">    int nfin=zone_PolyMAC.nb_faces();                                        \</span>
<a name="l02129"></a>02129 <span class="preprocessor">    for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l02130"></a>02130 <span class="preprocessor">      elem1 = elem(face,0);                                                \</span>
<a name="l02131"></a>02131 <span class="preprocessor">      elem2 = elem(face,1);                                                \</span>
<a name="l02132"></a>02132 <span class="preprocessor">      flux_evaluateur.coeffs_faces_interne(face, aii, ajj);                \</span>
<a name="l02133"></a>02133 <span class="preprocessor">      matrice(elem1,elem1)+=aii;                                        \</span>
<a name="l02134"></a>02134 <span class="preprocessor">      matrice(elem1,elem2)-=ajj;                                        \</span>
<a name="l02135"></a>02135 <span class="preprocessor">      matrice(elem2,elem2)+=ajj;                                        \</span>
<a name="l02136"></a>02136 <span class="preprocessor">      matrice(elem2,elem1)-=aii;                                        \</span>
<a name="l02137"></a>02137 <span class="preprocessor">    }                                                                        \</span>
<a name="l02138"></a>02138 <span class="preprocessor">  }                                                                        \</span>
<a name="l02139"></a>02139 <span class="preprocessor">  void It_PolyMAC_Elem(_TYPE_)::ajouter_contribution_interne(const DoubleTab&amp; inco, Matrice_Morse&amp; matrice ,int ncomp) const \</span>
<a name="l02140"></a>02140 <span class="preprocessor">  {                                                                        \</span>
<a name="l02141"></a>02141 <span class="preprocessor">    const Zone_PolyMAC&amp; zone_PolyMAC = la_zone.valeur();                        \</span>
<a name="l02142"></a>02142 <span class="preprocessor">    int face,i;                                                                \</span>
<a name="l02143"></a>02143 <span class="preprocessor">    DoubleVect aii(ncomp), ajj(ncomp);                                        \</span>
<a name="l02144"></a>02144 <span class="preprocessor">    int elem1,elem2;                                                        \</span>
<a name="l02145"></a>02145 <span class="preprocessor">    int ndeb=zone_PolyMAC.premiere_face_int();                                \</span>
<a name="l02146"></a>02146 <span class="preprocessor">    int nfin=zone_PolyMAC.nb_faces();                                        \</span>
<a name="l02147"></a>02147 <span class="preprocessor">    for (face=ndeb; face&lt;nfin; face++) {                                \</span>
<a name="l02148"></a>02148 <span class="preprocessor">      elem1 = elem(face,0);                                                \</span>
<a name="l02149"></a>02149 <span class="preprocessor">      elem2 = elem(face,1);                                                \</span>
<a name="l02150"></a>02150 <span class="preprocessor">      flux_evaluateur.coeffs_faces_interne(face, aii, ajj);                \</span>
<a name="l02151"></a>02151 <span class="preprocessor">      for (i=0; i&lt;ncomp; i++) {                                                \</span>
<a name="l02152"></a>02152 <span class="preprocessor">        int i0=elem1*ncomp+i,j0=elem2*ncomp+i;                                \</span>
<a name="l02153"></a>02153 <span class="preprocessor">        matrice(i0,i0)+=aii(i) ;                                        \</span>
<a name="l02154"></a>02154 <span class="preprocessor">        matrice(i0,j0)-=ajj(i) ;                                        \</span>
<a name="l02155"></a>02155 <span class="preprocessor">        matrice(j0,j0)+=ajj(i) ;                                        \</span>
<a name="l02156"></a>02156 <span class="preprocessor">        matrice(j0,i0)-=aii(i) ;                                        \</span>
<a name="l02157"></a>02157 <span class="preprocessor">      }                                                                        \</span>
<a name="l02158"></a>02158 <span class="preprocessor">    }                                                                        \</span>
<a name="l02159"></a>02159 <span class="preprocessor">  }</span>
<a name="l02160"></a>02160 <span class="preprocessor"></span>
<a name="l02161"></a>02161 <span class="preprocessor">#define implemente_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02162"></a>02162 <span class="preprocessor">  implemente1_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02163"></a>02163 <span class="preprocessor">    implemente2_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02164"></a>02164 <span class="preprocessor">    implemente3_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02165"></a>02165 <span class="preprocessor">    implemente4_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02166"></a>02166 <span class="preprocessor">    implemente5_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02167"></a>02167 <span class="preprocessor">    implemente6_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02168"></a>02168 <span class="preprocessor">    implemente7_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02169"></a>02169 <span class="preprocessor">    implemente8_It_PolyMAC_Elem(_TYPE_)                \</span>
<a name="l02170"></a>02170 <span class="preprocessor">    implemente9_It_PolyMAC_Elem(_TYPE_)</span>
<a name="l02171"></a>02171 <span class="preprocessor"></span>
<a name="l02172"></a>02172 <span class="preprocessor">#endif</span>
<a name="l02173"></a>02173 <span class="preprocessor"></span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:29 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
