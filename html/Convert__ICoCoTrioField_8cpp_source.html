<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TRUST: src/Kernel/ICoCo/Convert_ICoCoTrioField.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TRUST&#160;<span id="projectnumber">1.8.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">src/Kernel/ICoCo/Convert_ICoCoTrioField.cpp</div>  </div>
</div>
<div class="contents">
<a href="Convert__ICoCoTrioField_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">* Copyright (c) 2021, CEA</span>
<a name="l00003"></a>00003 <span class="comment">* All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment">*</span>
<a name="l00005"></a>00005 <span class="comment">* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment">* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00007"></a>00007 <span class="comment">* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00008"></a>00008 <span class="comment">* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00009"></a>00009 <span class="comment">*</span>
<a name="l00010"></a>00010 <span class="comment">* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00011"></a>00011 <span class="comment">* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;</span>
<a name="l00012"></a>00012 <span class="comment">* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00013"></a>00013 <span class="comment">*</span>
<a name="l00014"></a>00014 <span class="comment">*****************************************************************************/</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// File:        Convert_ICoCoTrioField.cpp</span>
<a name="l00018"></a>00018 <span class="comment">// Directory:   $TRUST_ROOT/src/Kernel/ICoCo</span>
<a name="l00019"></a>00019 <span class="comment">// Version:     1</span>
<a name="l00020"></a>00020 <span class="comment">// </span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Convert__ICoCoTrioField_8h.html">Convert_ICoCoTrioField.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;ICoCoTrioField.h&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;ICoCoMEDDoubleField.hxx&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="Domaine_8h.html">Domaine.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="Champ__Generique__base_8h.html">Champ_Generique_base.h</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="Zone__VF_8h.html">Zone_VF.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="PE__Groups_8h.html">PE_Groups.h</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="Comm__Group_8h.html">Comm_Group.h</a>&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="Convert__ICoCoTrioField_8h.html#a640b3089830d2065c5895027f61dc1c1">00033</a> <span class="keywordtype">void</span> <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a640b3089830d2065c5895027f61dc1c1">affecte_double_avec_doubletab</a>(<span class="keywordtype">double</span>** p, <span class="keyword">const</span> <a class="code" href="classArrOfDouble.html" title="Represente un tableau d&#39;elements de type double. L&#39;etat du tableau est caracterise par la valeur de p...">ArrOfDouble</a>&amp; trio)
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035   *p=<span class="keyword">new</span> <span class="keywordtype">double</span>[trio.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()];
<a name="l00036"></a>00036   memcpy(*p,trio.<a class="code" href="classArrOfDouble.html#a95357a1390c11dbd481d385257f2e983" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(),trio.<a class="code" href="classArrOfDouble.html#a3c3b33bea0e88b87315c21ee94bee05f" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>()*<span class="keyword">sizeof</span>(double));
<a name="l00037"></a>00037 }
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="Convert__ICoCoTrioField_8h.html#ae1c4d801eb787fe395e7971a44bbad39">00039</a> <span class="keywordtype">void</span> <a class="code" href="Convert__ICoCoTrioField_8cpp.html#ae1c4d801eb787fe395e7971a44bbad39">affecte_int_avec_inttab</a>(<span class="keywordtype">int</span>** p, <span class="keyword">const</span> <a class="code" href="classArrOfInt.html" title="Represente un tableau d&#39;elements de type int. L&#39;etat du tableau est caracterise par la valeur de p_ e...">ArrOfInt</a>&amp; trio)
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="keywordtype">int</span> <a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>=trio.<a class="code" href="classArrOfInt.html#a0f41611fce0a58c3ef3409dc1af8904d" title="Renvoie la taille du tableau (nombre d&#39;elements declares a la construction ou a resize_array()). C&#39;est le nombre d&#39;elements accessibles a operator[].">size_array</a>();
<a name="l00042"></a>00042   *p=<span class="keyword">new</span> <span class="keywordtype">int</span>[<a class="code" href="Nom_8cpp.html#a0e1ea19fb9fa7881d15d84eff4c090e1">sz</a>];
<a name="l00043"></a>00043   memcpy(*p,trio.<a class="code" href="classArrOfInt.html#ad0b31250e60cd9040ea60be55db73c3d" title="Renvoie un pointeur sur le premier element du tableau. Le pointeur est nul si le tableau est &quot;detach...">addr</a>(),sz*<span class="keyword">sizeof</span>(int));
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 
<a name="l00046"></a><a class="code" href="Convert__ICoCoTrioField_8h.html#a9e0b58c964c69165fc7c262e66ebe9b9">00046</a> <span class="keywordtype">void</span> <a class="code" href="Convert__ICoCoTrioField_8cpp.html#af50d611167938cbd08d21539b668f6dd">build_triofield</a>(<span class="keyword">const</span> <a class="code" href="classChamp__Generique__base.html" title="Classe de base des champs generiques pour importation d un champ discret et actions elementaires sur ...">Champ_Generique_base</a>&amp; ch, ICoCo::TrioField&amp; afield)
<a name="l00047"></a>00047 {
<a name="l00048"></a>00048   <span class="keyword">const</span> <a class="code" href="classZone__VF.html" title="class Zone_VF Cette classe abstraite contient les informations geometriques communes aux methodes de ...">Zone_VF</a>&amp; zvf = <a class="code" href="Cast_8h.html#ad116a7acb85c9c91e5687c44941a0d0c">ref_cast</a>(<a class="code" href="classZone__VF.html" title="class Zone_VF Cette classe abstraite contient les informations geometriques communes aux methodes de ...">Zone_VF</a>, ch.<a class="code" href="classChamp__Generique__base.html#aca8f6eab28f080ca436b0a29cdeec668" title="Renvoie une ref a la zone_discretisee du domaine sur lequel sera evalue l espace de stockage...">get_ref_zone_dis_base</a>());
<a name="l00049"></a>00049   <span class="keyword">const</span> <a class="code" href="classDomaine.html" title="Classe Domaine Un Domaine represente le domaine (spatial) de resolution d&#39;un Probleme. Un Domaine a un Nom, il est constitue d&#39;une ou plusieurs Zone qui peuvent etre eventuellement decoupees en Sous_Zone. Un Domaine porte l&#39;ensemble des sommets utilises par ses Zones. On peut vouloir resoudre des problemes de type different sur plusieurs domaines, geometriquement les domaines sont alors couples par des surfaces qu&#39;on appelle Raccord.">Domaine</a>&amp; dom = zvf.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a379ad2206b5a13a4f4f3df6d44c7546a" title="Renvoie le domaine dont la zone fait partie. (version const)">domaine</a>();
<a name="l00050"></a>00050 
<a name="l00051"></a>00051   afield.clear();
<a name="l00052"></a>00052   afield.setName(ch.<a class="code" href="classObjet__U.html#a70413a8785d36bf5105fced1c89d0d2b" title="Donne le nom de l&#39;Objet_U Methode a surcharger : renvoie &quot;neant&quot; dans cette implementation.">le_nom</a>().<a class="code" href="classNom.html#a855d8cd96b5c73c2aa55cb7c0a870640">getString</a>());
<a name="l00053"></a>00053   afield._type = ch.<a class="code" href="classChamp__Generique__base.html#a4c857f500646447b57af75f6da153810" title="Renvoie le type des entites geometriques sur auxquelles les valeurs discretes sont attachees (NODE po...">get_localisation</a>() == <a class="code" href="Champ__Generique__base_8h.html#a2228f5f8d54732b2077779d47c6f5ffba59a889456a2d742fdca191dccb3e871d">NODE</a>;
<a name="l00054"></a>00054   afield._time1 = afield._time2 = ch.<a class="code" href="classChamp__Generique__base.html#acc289b962772667eaea575faca208ed1" title="Renvoie le temps du Champ_Generique.">get_time</a>(), afield._itnumber = 0;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056   <span class="comment">/* tableau des sommets : copie de celui du domaine */</span>
<a name="l00057"></a>00057   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; coord = dom.les_sommets();
<a name="l00058"></a>00058   afield._space_dim = dom.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>;
<a name="l00059"></a>00059   afield._nbnodes = coord.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(0);
<a name="l00060"></a>00060   <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a640b3089830d2065c5895027f61dc1c1">affecte_double_avec_doubletab</a>(&amp;afield._coords, coord);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">/* dimension des elements du domaine */</span>
<a name="l00063"></a>00063   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> type_elem_ = zvf.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a18cf83cd0f9c368dcfa32fb802a0ac94" title="Renvoie un element geometrique du type de ceux qui constituent la zone. (version const)">type_elem</a>()-&gt;<a class="code" href="classObjet__U.html#aa58e9a81c0ddc2c1149053b8f96698ac" title="renvoie la chaine identifiant la classe.">que_suis_je</a>();
<a name="l00064"></a>00064   <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a> <a class="code" href="Raffiner__Simplexes_8cpp.html#a358dc168d8905bbafc12587204bc9fb8">type_elem</a>(type_elem_);
<a name="l00065"></a>00065   type_elem.<a class="code" href="classNom.html#aa296fc70f7abcf978968e09582d8fb06">prefix</a>(<span class="stringliteral">&quot;_AXI&quot;</span>);
<a name="l00066"></a>00066   <span class="keywordflow">if</span> (type_elem != <a class="code" href="classMotcle.html" title="Une chaine de caractere (Nom) en majuscules.">Motcle</a>(type_elem_))
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068       <span class="keywordflow">if</span> (type_elem == <span class="stringliteral">&quot;QUADRILATERE_2D&quot;</span>)
<a name="l00069"></a>00069         type_elem = <span class="stringliteral">&quot;SEGMENT_2D&quot;</span>;
<a name="l00070"></a>00070       <span class="keywordflow">if</span> (type_elem == <span class="stringliteral">&quot;RECTANGLE_2D&quot;</span>)
<a name="l00071"></a>00071         type_elem = <span class="stringliteral">&quot;RECTANGLE&quot;</span>;
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073   <span class="keywordflow">if</span> ((type_elem == <span class="stringliteral">&quot;RECTANGLE&quot;</span>) || (type_elem == <span class="stringliteral">&quot;QUADRANGLE&quot;</span>) || (type_elem == <span class="stringliteral">&quot;TRIANGLE&quot;</span>) || (type_elem == <span class="stringliteral">&quot;TRIANGLE_3D&quot;</span>) || (type_elem == <span class="stringliteral">&quot;QUADRANGLE_3D&quot;</span>) || (type_elem == <span class="stringliteral">&quot;POLYGONE&quot;</span>) || (type_elem == <span class="stringliteral">&quot;POLYGONE_3D&quot;</span>))
<a name="l00074"></a>00074     afield._mesh_dim=2;
<a name="l00075"></a>00075   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((type_elem == <span class="stringliteral">&quot;HEXAEDRE&quot;</span>) || (type_elem == <span class="stringliteral">&quot;HEXAEDRE_VEF&quot;</span>) || (type_elem == <span class="stringliteral">&quot;POLYEDRE&quot;</span>) || (type_elem == <span class="stringliteral">&quot;PRISME&quot;</span>) || (type_elem == <span class="stringliteral">&quot;TETRAEDRE&quot;</span>))
<a name="l00076"></a>00076     afield._mesh_dim=3;
<a name="l00077"></a>00077   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((type_elem == <span class="stringliteral">&quot;SEGMENT_2D&quot;</span>) || (type_elem == <span class="stringliteral">&quot;SEGMENT&quot;</span>))
<a name="l00078"></a>00078     afield._mesh_dim=1;
<a name="l00079"></a>00079   <span class="keywordflow">else</span>
<a name="l00080"></a>00080     {
<a name="l00081"></a>00081       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a> &lt;&lt; <span class="stringliteral">&quot;build_triofield: &quot;</span> &lt;&lt; type_elem&lt;&lt; <span class="stringliteral">&quot; not coded&quot;</span> &lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00082"></a>00082       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085   <span class="comment">/* elements : ceux du domaine si le champ est aux sommets/elements, les faces si le champ est aux faces */</span>
<a name="l00086"></a>00086   <span class="keywordtype">int</span> loc_faces = ch.<a class="code" href="classChamp__Generique__base.html#a4c857f500646447b57af75f6da153810" title="Renvoie le type des entites geometriques sur auxquelles les valeurs discretes sont attachees (NODE po...">get_localisation</a>() == <a class="code" href="Champ__Generique__base_8h.html#a2228f5f8d54732b2077779d47c6f5ffba5cfae78048cf95359061c2e812e7d691">FACE</a>;
<a name="l00087"></a>00087   <span class="keywordflow">if</span> (loc_faces) afield._mesh_dim--;
<a name="l00088"></a>00088   afield._nb_elems = loc_faces ? zvf.<a class="code" href="classZone__VF.html#aede27992d9f2eedd52c24d4a80ff7ffb" title="renvoie le nombre global de faces.">nb_faces</a>() : zvf.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#a7f249429803b27139a1c54436f6164a5" title="Renvoie le nombre d&#39;elements de la zone.">nb_elem</a>();
<a name="l00089"></a>00089   <span class="keywordflow">if</span> (loc_faces || type_elem != <span class="stringliteral">&quot;POLYEDRE&quot;</span>) <span class="comment">//maillage de faces -&gt; connectivity = face_sommets</span>
<a name="l00090"></a>00090     {
<a name="l00091"></a>00091       <span class="keyword">const</span> <a class="code" href="classIntTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un IntVect avec calculs de l&#39;indice corespondant Voir les co...">IntTab</a>&amp; conn = loc_faces ? zvf.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>() : zvf.<a class="code" href="classZone__dis__base.html#a0bb3a4512e111f91fa2c352de44653a4" title="Renvoie la Zone associee a l&#39;objet. (version const)">zone</a>().<a class="code" href="classZone.html#ac115e8342be89afb882b7b61cc343267" title="Renvoie le tableau des sommets des elements.">les_elems</a>();
<a name="l00092"></a>00092 <span class="comment">// le seul moyen qu&#39;on a d&#39;eviter que des polygones soient pris pour des quadrilateres est d&#39;avoir un tableau de connectivite de largeur &gt; 4...</span>
<a name="l00093"></a>00093       afield._nodes_per_elem = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(conn.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1), type_elem == <span class="stringliteral">&quot;POLYGONE&quot;</span> || type_elem == <span class="stringliteral">&quot;POLYGONE_3D&quot;</span>  || type_elem == <span class="stringliteral">&quot;POLYEDRE&quot;</span>  ? 5 : 0);
<a name="l00094"></a>00094       afield._connectivity = <span class="keyword">new</span> <span class="keywordtype">int</span>[afield._nb_elems * afield._nodes_per_elem];
<a name="l00095"></a>00095       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; afield._nb_elems; i++) <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; afield._nodes_per_elem; j++)
<a name="l00096"></a>00096           afield._connectivity[afield._nodes_per_elem * i + j] = j &lt; conn.<a class="code" href="classIntTab.html#abc3b32c94925a82f69d5b153a356e359" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) ? conn(i, j) : -1;
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098   <span class="keywordflow">else</span> <span class="comment">//maillage de polyedres -&gt; connectivite au format MEDCoupling, a faire a la main</span>
<a name="l00099"></a>00099     {
<a name="l00100"></a>00100       afield._nodes_per_elem = <a class="code" href="Double_8h.html#a1c45761573e6cbc97cfacac78d905016">max</a>(zvf.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>().dimension(1) * (zvf.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>().dimension(1) + 1), 9); <span class="comment">//un -1 apres chaque face : au moins 9 pour eviter un papillonage</span>
<a name="l00101"></a>00101       <span class="keywordtype">int</span> *p = afield._connectivity = <span class="keyword">new</span> <span class="keywordtype">int</span>[afield._nb_elems * afield._nodes_per_elem];
<a name="l00102"></a>00102       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> e = 0, f, s, i, j; e &lt; afield._nb_elems; e++)
<a name="l00103"></a>00103         {
<a name="l00104"></a>00104           <span class="comment">/* insertion de la connectivite de chaque face, suivie d&#39;un -1 */</span>
<a name="l00105"></a>00105           <span class="keywordflow">for</span> (i = 0; i &lt; zvf.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>().dimension(1) &amp;&amp; (f = zvf.<a class="code" href="classZone__VF.html#a067e462dcd3ab92b0f6d945b19e4eb37" title="renvoie le numero de le ieme face de la maille num_elem la facon dont ces faces sont numerotees est l...">elem_faces</a>(e, i)) &gt;= 0; i++, *p = -1, p++)
<a name="l00106"></a>00106             <span class="keywordflow">for</span> (j = 0; j &lt; zvf.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>().dimension(1) &amp;&amp; (s = zvf.<a class="code" href="classZone__VF.html#a298e73b18e17da55f421b1fb0879bd46" title="renvoie le numero du ieme sommet de la face num_face.">face_sommets</a>(f, j)) &gt;= 0; j++) *p = s, p++;
<a name="l00107"></a>00107           <span class="comment">/* des -1 jusqu&#39;a la ligne suivante */</span>
<a name="l00108"></a>00108           <span class="keywordflow">for</span> ( ; p &lt; afield._connectivity + (e + 1) * afield._nodes_per_elem; p++) *p = -1;
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="comment">/* copie des valeurs du champ */</span>
<a name="l00113"></a>00113   afield._has_field_ownership = <span class="keyword">true</span>;
<a name="l00114"></a>00114   <a class="code" href="classChamp.html" title="class Champ Cette classe sert a representer n&#39;importe quelle classe derivee de la classe Champ_base...">Champ</a> espace_stockage;
<a name="l00115"></a>00115   <span class="keyword">const</span> <a class="code" href="classChamp__base.html" title="classe Champ_base Cette classe est la base de la hierarchie des champs. Ses membres sont les attribut...">Champ_base</a>&amp; champ_ecriture = ch.<a class="code" href="classChamp__Generique__base.html#a89c71fecd51b71f50702bc2cb270fabd">get_champ</a>(espace_stockage);
<a name="l00116"></a>00116   <span class="keyword">const</span> <a class="code" href="classDoubleTab.html" title="Tableau a n entrees pour n&lt;= 4 Repose sur un DoubleVect avec calculs de l&#39;indice corespondant Voir les...">DoubleTab</a>&amp; vals = champ_ecriture.<a class="code" href="classChamp__Proto.html#a9d8c69f11d1b0a8e378cc6ca41793614">valeurs</a>();
<a name="l00117"></a>00117   afield._nb_field_components = vals.<a class="code" href="classDoubleTab.html#ae6dda48778e7107e1beb723beef1f75b" title="Returns the number of dimensions of the array (&gt;= 1)">nb_dim</a>() &gt; 1 ? vals.<a class="code" href="classDoubleTab.html#ac3805e2637a3b880ba2d3e650c69dac4" title="Returns one of the &quot;real&quot; dimensions of the multi-dimensionnal array, as defined by: dimension(0) = s...">dimension</a>(1) : 1;
<a name="l00118"></a>00118   <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a640b3089830d2065c5895027f61dc1c1">affecte_double_avec_doubletab</a>(&amp;afield._field, vals);
<a name="l00119"></a>00119 }
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="preprocessor">#ifndef NO_MEDFIELD</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">#include &lt;MEDCouplingUMesh.hxx&gt;</span>
<a name="l00123"></a>00123 <span class="preprocessor">#include &lt;MEDCouplingFieldDouble.hxx&gt;</span>
<a name="l00124"></a>00124 <span class="preprocessor">#include &lt;MCAuto.hxx&gt;</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00127"></a>00127 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00128"></a>00128 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keyword">using</span> ICoCo::TrioField;
<a name="l00131"></a>00131 <span class="keyword">using</span> ICoCo::MEDDoubleField;
<a name="l00132"></a>00132 <span class="keyword">using</span> std::vector;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment"></span>
<a name="l00135"></a>00135 <span class="comment">/*!</span>
<a name="l00136"></a>00136 <span class="comment"> * This method is non const only due to this-&gt;_field that can be modified (to point to the same zone than returned object).</span>
<a name="l00137"></a>00137 <span class="comment"> * So \b warning, to access to \a this-&gt;_field only when the returned object is alive.</span>
<a name="l00138"></a>00138 <span class="comment"> */</span>
<a name="l00139"></a><a class="code" href="Convert__ICoCoTrioField_8cpp.html#a404cc2e811af5311a59c4eee05e4b0f5">00139</a> MEDDoubleField <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a404cc2e811af5311a59c4eee05e4b0f5">build_medfield</a>(TrioField&amp; triofield)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141   MEDCoupling::MCAuto&lt;MEDCoupling::MEDCouplingUMesh&gt; mesh(MEDCoupling::MEDCouplingUMesh::New(<span class="stringliteral">&quot;&quot;</span>,triofield._mesh_dim));
<a name="l00142"></a>00142   MEDCoupling::MCAuto&lt;MEDCoupling::DataArrayDouble&gt; coo(MEDCoupling::DataArrayDouble::New());
<a name="l00143"></a>00143   coo-&gt;alloc(triofield._nbnodes,triofield._space_dim);
<a name="l00144"></a>00144   mesh-&gt;setCoords(coo);
<a name="l00145"></a>00145   <span class="keywordtype">double</span> *ptr(coo-&gt;getPointer());
<a name="l00146"></a>00146   std::copy(triofield._coords,triofield._coords+triofield._space_dim*triofield._nbnodes,ptr);
<a name="l00147"></a>00147   mesh-&gt;allocateCells(triofield._nb_elems);
<a name="l00148"></a>00148   INTERP_KERNEL::NormalizedCellType elemtype;
<a name="l00149"></a>00149   <span class="keywordflow">switch</span>(triofield._mesh_dim)
<a name="l00150"></a>00150     {
<a name="l00151"></a>00151     <span class="keywordflow">case</span> 0 :
<a name="l00152"></a>00152       {
<a name="l00153"></a>00153         <span class="keywordflow">switch</span> (triofield._nodes_per_elem)
<a name="l00154"></a>00154           {
<a name="l00155"></a>00155           <span class="keywordflow">case</span> 0: <span class="comment">//!&lt; cas field vide</span>
<a name="l00156"></a>00156 <span class="comment"></span>            elemtype=INTERP_KERNEL::NORM_SEG2; <span class="comment">//!&lt; pour eviter warning</span>
<a name="l00157"></a>00157 <span class="comment"></span>            <span class="keywordflow">break</span>;
<a name="l00158"></a>00158           <span class="keywordflow">default</span>:
<a name="l00159"></a>00159             <span class="keywordflow">throw</span> INTERP_KERNEL::Exception(<span class="stringliteral">&quot;incompatible Trio field - wrong nb of nodes per elem&quot;</span>);
<a name="l00160"></a>00160           }
<a name="l00161"></a>00161         <span class="keywordflow">break</span>;
<a name="l00162"></a>00162       }
<a name="l00163"></a>00163     <span class="keywordflow">case</span> 1:
<a name="l00164"></a>00164       {
<a name="l00165"></a>00165         <span class="keywordflow">switch</span> (triofield._nodes_per_elem)
<a name="l00166"></a>00166           {
<a name="l00167"></a>00167           <span class="keywordflow">case</span> 2:
<a name="l00168"></a>00168             elemtype=INTERP_KERNEL::NORM_SEG2;
<a name="l00169"></a>00169             <span class="keywordflow">break</span>;
<a name="l00170"></a>00170           <span class="keywordflow">default</span>:
<a name="l00171"></a>00171             <span class="keywordflow">throw</span> INTERP_KERNEL::Exception(<span class="stringliteral">&quot;incompatible Trio field - wrong nb of nodes per elem&quot;</span>);
<a name="l00172"></a>00172           }
<a name="l00173"></a>00173         <span class="keywordflow">break</span>;
<a name="l00174"></a>00174       }
<a name="l00175"></a>00175     <span class="keywordflow">case</span> 2:
<a name="l00176"></a>00176       {
<a name="l00177"></a>00177         <span class="keywordflow">switch</span> (triofield._nodes_per_elem)
<a name="l00178"></a>00178           {
<a name="l00179"></a>00179           <span class="keywordflow">case</span> 3:
<a name="l00180"></a>00180             elemtype=INTERP_KERNEL::NORM_TRI3;
<a name="l00181"></a>00181             <span class="keywordflow">break</span>;
<a name="l00182"></a>00182           <span class="keywordflow">case</span> 4 :
<a name="l00183"></a>00183             elemtype=INTERP_KERNEL::NORM_QUAD4;
<a name="l00184"></a>00184             <span class="keywordflow">break</span>;
<a name="l00185"></a>00185           <span class="keywordflow">default</span>:
<a name="l00186"></a>00186             elemtype=INTERP_KERNEL::NORM_POLYGON;
<a name="l00187"></a>00187           }
<a name="l00188"></a>00188         <span class="keywordflow">break</span>;
<a name="l00189"></a>00189       }
<a name="l00190"></a>00190     <span class="keywordflow">case</span> 3:
<a name="l00191"></a>00191       {
<a name="l00192"></a>00192         <span class="keywordflow">switch</span> (triofield._nodes_per_elem)
<a name="l00193"></a>00193           {
<a name="l00194"></a>00194           <span class="keywordflow">case</span> 4:
<a name="l00195"></a>00195             elemtype=INTERP_KERNEL::NORM_TETRA4;
<a name="l00196"></a>00196             <span class="keywordflow">break</span>;
<a name="l00197"></a>00197           <span class="keywordflow">case</span> 8 :
<a name="l00198"></a>00198             elemtype=INTERP_KERNEL::NORM_HEXA8;
<a name="l00199"></a>00199             <span class="keywordflow">break</span>;
<a name="l00200"></a>00200           <span class="keywordflow">default</span>:
<a name="l00201"></a>00201             elemtype=INTERP_KERNEL::NORM_POLYHED;
<a name="l00202"></a>00202           }
<a name="l00203"></a>00203         <span class="keywordflow">break</span>;
<a name="l00204"></a>00204       <span class="keywordflow">default</span>:
<a name="l00205"></a>00205         <span class="keywordflow">throw</span> INTERP_KERNEL::Exception(<span class="stringliteral">&quot;incompatible Trio field - wrong mesh dimension&quot;</span>);
<a name="l00206"></a>00206       }
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208 <span class="comment">// creating a connectivity table that complies to MED (1 indexing) &lt;- en fait non</span>
<a name="l00209"></a>00209 <span class="comment">// and passing it to _mesh</span>
<a name="l00210"></a>00210   MEDCoupling::MCAuto&lt;MEDCoupling::MEDCouplingFieldDouble&gt; field;
<a name="l00211"></a>00211   <span class="keywordtype">int</span> *conn(<span class="keyword">new</span> <span class="keywordtype">int</span>[triofield._nodes_per_elem]);
<a name="l00212"></a>00212   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;triofield._nb_elems; i++)
<a name="l00213"></a>00213     {
<a name="l00214"></a>00214 
<a name="l00215"></a>00215       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;triofield._nodes_per_elem; j++)
<a name="l00216"></a>00216         {
<a name="l00217"></a>00217           conn[j]=triofield._connectivity[i*triofield._nodes_per_elem+j];
<a name="l00218"></a>00218         }
<a name="l00219"></a>00219       <span class="keywordflow">if</span> (elemtype==INTERP_KERNEL::NORM_QUAD4)
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221 <span class="comment">// dans trio pas la meme numerotation</span>
<a name="l00222"></a>00222           <span class="keywordtype">int</span> tmp=conn[3];
<a name="l00223"></a>00223           conn[3]=conn[2];
<a name="l00224"></a>00224           conn[2]=tmp;
<a name="l00225"></a>00225         }
<a name="l00226"></a>00226       <span class="keywordflow">if</span> (elemtype==INTERP_KERNEL::NORM_HEXA8)
<a name="l00227"></a>00227         {
<a name="l00228"></a>00228 <span class="comment">// dans trio pas la meme numerotation</span>
<a name="l00229"></a>00229           <span class="keywordtype">int</span> tmp=conn[3];
<a name="l00230"></a>00230           conn[3]=conn[2];
<a name="l00231"></a>00231           conn[2]=tmp;
<a name="l00232"></a>00232           tmp=conn[7];
<a name="l00233"></a>00233           conn[7]=conn[6];
<a name="l00234"></a>00234           conn[6]=tmp;
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236       <span class="keywordtype">int</span> size = triofield._nodes_per_elem;
<a name="l00237"></a>00237       <span class="keywordflow">while</span> (conn[size - 1] == -1) size--; <span class="comment">//on enleve les -1 a la fin de la connectivite</span>
<a name="l00238"></a>00238       mesh-&gt;insertNextCell(elemtype,size,conn);
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240   <span class="keyword">delete</span> [] conn;
<a name="l00241"></a>00241   mesh-&gt;finishInsertingCells();
<a name="l00242"></a>00242 <span class="comment">// </span>
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   std::vector&lt;int&gt; cells;
<a name="l00246"></a>00246 <span class="comment">// if ((mesh-&gt;getSpaceDimension() == 2 || mesh-&gt;getSpaceDimension() == 3) &amp;&amp; mesh-&gt;getMeshDimension() == 2)</span>
<a name="l00247"></a>00247 <span class="comment">// mesh-&gt;checkButterflyCells(cells);</span>
<a name="l00248"></a>00248   <span class="keywordflow">if</span> (!cells.empty())
<a name="l00249"></a>00249     {
<a name="l00250"></a>00250       <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot; cells are butterflyed &quot;</span>&lt;&lt;cells[0]&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00251"></a>00251       <a class="code" href="classPE__Groups.html#af38ed6631e572dc5117361b3f26a47a3" title="Renvoie une reference au groupe de tous les processeurs TRUST.">PE_Groups::groupe_TRUST</a>().<a class="code" href="classComm__Group.html#a9eaa1dfaa2f51ddd7d72da0e7bc4f3d2">abort</a>();
<a name="l00252"></a>00252       <a class="code" href="classProcess.html#a6a4b64571b10f150a70db229b839e881" title="Routine de sortie de Trio-U sur une erreur abort()">Process::abort</a>();
<a name="l00253"></a>00253       <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 <span class="comment">// field on the sending end</span>
<a name="l00256"></a>00256   <span class="keywordtype">int</span> nb_case=triofield.nb_values();
<a name="l00257"></a>00257   <span class="keywordflow">if</span> (triofield._type==0)
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259       field =  MEDCoupling::MEDCouplingFieldDouble::New(MEDCoupling::ON_CELLS,MEDCoupling::ONE_TIME);
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261   <span class="keywordflow">else</span>
<a name="l00262"></a>00262     {
<a name="l00263"></a>00263       field =  MEDCoupling::MEDCouplingFieldDouble::New(MEDCoupling::ON_NODES,MEDCoupling::ONE_TIME );
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265   field-&gt;setMesh(mesh);
<a name="l00266"></a>00266   field-&gt;setNature(MEDCoupling::IntensiveMaximum);
<a name="l00267"></a>00267   MEDCoupling::MCAuto&lt;MEDCoupling::DataArrayDouble&gt; fieldArr(MEDCoupling::DataArrayDouble::New());
<a name="l00268"></a>00268   fieldArr-&gt;alloc(field-&gt;getNumberOfTuplesExpected(),triofield._nb_field_components);
<a name="l00269"></a>00269   field-&gt;setName(triofield.getName().c_str());
<a name="l00270"></a>00270   std::string meshName(<span class="stringliteral">&quot;SupportOf_&quot;</span>);
<a name="l00271"></a>00271   meshName+=triofield.getName();
<a name="l00272"></a>00272   mesh-&gt;setName(meshName.c_str());
<a name="l00273"></a>00273   field-&gt;setTime(triofield._time1,0,triofield._itnumber);
<a name="l00274"></a>00274   <span class="keywordflow">if</span> (triofield._field!=0)
<a name="l00275"></a>00275     {
<a name="l00276"></a>00276       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i&lt;nb_case; i++)
<a name="l00277"></a>00277         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;triofield._nb_field_components; j++)
<a name="l00278"></a>00278           {
<a name="l00279"></a>00279             fieldArr-&gt;setIJ(i,j,triofield._field[i*triofield._nb_field_components+j]);
<a name="l00280"></a>00280           }
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282 <span class="comment">// field on the receiving end</span>
<a name="l00283"></a>00283   <span class="keywordflow">else</span>
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285 <span class="comment">// the trio field points to the pointer inside the MED field</span>
<a name="l00286"></a>00286       triofield._field=fieldArr-&gt;getPointer();
<a name="l00287"></a>00287       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;triofield._nb_field_components*nb_case; i++)
<a name="l00288"></a>00288         triofield._field[i]=0.0;
<a name="l00289"></a>00289     }
<a name="l00290"></a>00290   field-&gt;setArray(fieldArr);
<a name="l00291"></a>00291   <span class="keywordflow">return</span> MEDDoubleField(field);
<a name="l00292"></a>00292 }
<a name="l00293"></a><a class="code" href="Convert__ICoCoTrioField_8h.html#a407774752f7ddb1679cff7c276d110b7">00293</a> MEDDoubleField <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a404cc2e811af5311a59c4eee05e4b0f5">build_medfield</a>(<span class="keyword">const</span> <a class="code" href="classChamp__Generique__base.html" title="Classe de base des champs generiques pour importation d un champ discret et actions elementaires sur ...">Champ_Generique_base</a>&amp; ch)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295   TrioField fl;
<a name="l00296"></a>00296   <a class="code" href="Convert__ICoCoTrioField_8cpp.html#af50d611167938cbd08d21539b668f6dd">build_triofield</a>(ch, fl);
<a name="l00297"></a>00297   <span class="keywordflow">return</span> <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a404cc2e811af5311a59c4eee05e4b0f5">build_medfield</a>(fl);
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="preprocessor">#else</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span><span class="keyword">namespace </span>ICoCo
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304 <span class="keyword">class </span>MEDDoubleField
<a name="l00305"></a>00305 {
<a name="l00306"></a>00306 };
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 ICoCo::MEDDoubleField <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a404cc2e811af5311a59c4eee05e4b0f5">build_medfield</a>(ICoCo::TrioField&amp; ch)
<a name="l00309"></a>00309 {
<a name="l00310"></a>00310   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Version compiled without MEDCoupling&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00311"></a>00311   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00312"></a>00312   <span class="keywordflow">throw</span>;
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 ICoCo::MEDDoubleField <a class="code" href="Convert__ICoCoTrioField_8cpp.html#a404cc2e811af5311a59c4eee05e4b0f5">build_medfield</a>(<span class="keyword">const</span> <a class="code" href="classChamp__Generique__base.html" title="Classe de base des champs generiques pour importation d un champ discret et actions elementaires sur ...">Champ_Generique_base</a>&amp; ch)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316   <a class="code" href="EntreeSortie_8h.html#a5ebb6b5243d6167369bddecb78d0b5b8">Cerr</a>&lt;&lt;<span class="stringliteral">&quot;Version compiled without MEDCoupling&quot;</span>&lt;&lt;<a class="code" href="EntreeSortie_8h.html#a7f716d3c5b6411631d5d0700ead09467">finl</a>;
<a name="l00317"></a>00317   <a class="code" href="classProcess.html#acc2fbbe761e08e5870ae605c0705491c" title="Routine de sortie de Trio-U sur une erreur Sauvegarde la memoire et le hierarchie dans les fichiers &quot;...">Process::exit</a>();
<a name="l00318"></a>00318   <span class="keywordflow">throw</span>;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 <span class="preprocessor">#endif</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Dec 14 2021 19:35:21 for TRUST by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
